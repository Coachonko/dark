{"version":3,"file":"125.build.js","mappings":"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","sources":["webpack:///./api/index.ts","webpack:///./components/animated-route.tsx","webpack:///./components/error.tsx","webpack:///./components/product-list.tsx","webpack:///../../../packages/core/src/use-resource/use-resource.ts","webpack:///../../../packages/web-router/src/use-match/use-match.ts"],"sourcesContent":["type ProductBrief = {\r\n  id: number;\r\n  title: string;\r\n};\r\n\r\ntype Product = {\r\n  id: number;\r\n  title: string;\r\n  description: string;\r\n};\r\n\r\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\nconst PRODUCTS_KEY = 'products';\r\nconst PRODUCT_KEY = 'product';\r\nconst cache: Record<string, any> = {\r\n  [PRODUCTS_KEY]: null,\r\n  [PRODUCT_KEY]: {},\r\n};\r\nconst isServer = typeof globalThis.process !== 'undefined';\r\n\r\nconst api = {\r\n  async fetchProductList() {\r\n    if (isServer || !cache[PRODUCTS_KEY]) {\r\n      await sleep(isServer ? 100 : 600);\r\n      const products: Array<ProductBrief> = new Array(10)\r\n        .fill(null)\r\n        .map((_, idx) => ({ id: idx + 1, title: `Product #${idx + 1}` }));\r\n\r\n      cache[PRODUCTS_KEY] = products;\r\n    }\r\n\r\n    return cache[PRODUCTS_KEY] as Array<ProductBrief>;\r\n  },\r\n  async fetchProduct(id: number) {\r\n    if (isServer || !cache[PRODUCT_KEY][id]) {\r\n      await sleep(isServer ? 100 : 600);\r\n      if (typeof id !== 'number' || Number.isNaN(id)) throw new Error('Invalid id!');\r\n      const product: Product = {\r\n        id,\r\n        title: `Product #${id}`,\r\n        description:\r\n          'Lorem ipsum dolor sit amet consectetur, adipisicing elit. Nostrum blanditiis quia minus corrupti quidem. Ipsam quae ad velit repudiandae molestias unde ab officiis harum atque? Quo veritatis maxime illo asperiores.',\r\n      };\r\n\r\n      cache[PRODUCT_KEY][id] = product;\r\n    }\r\n\r\n    return cache[PRODUCT_KEY][id] as Product;\r\n  },\r\n};\r\n\r\nexport { api };\r\n","import { styled, keyframes } from '@dark-engine/styled';\r\n\r\nconst fade = keyframes`\r\n  0% {\r\n    opacity: 0;\r\n  }\r\n\r\n  100% {\r\n    opacity: 1;\r\n  }\r\n`;\r\n\r\nconst AnimatedRoute = styled.div`\r\n  animation-name: ${fade};\r\n  animation-iteration-count: 1;\r\n  animation-duration: 600ms;\r\n  animation-fill-mode: both;\r\n  animation-timing-function: ease-in-out;\r\n`;\r\n\r\nexport { AnimatedRoute };\r\n","import { h, component } from '@dark-engine/core';\r\n\r\nconst Error = component<{ value: string }>(({ value }) => <div>{value} ðŸ« </div>);\r\n\r\nexport { Error };\r\n","import { type DarkElement, h, component, useResource } from '@dark-engine/core';\r\nimport { RouterLink, useMatch } from '@dark-engine/web-router';\r\n\r\nimport { api } from '../api';\r\nimport { Spinner } from './spinner';\r\nimport { Error } from './error';\r\nimport { AnimatedRoute } from './animated-route';\r\n\r\nconst ProductList = component<{ slot: DarkElement }>(({ slot }) => {\r\n  const { url } = useMatch();\r\n  const resource = useResource(() => api.fetchProductList());\r\n  const { loading, data, error } = resource;\r\n  const renderList = () => {\r\n    return (\r\n      <ul>\r\n        {data.map(x => {\r\n          return (\r\n            <li>\r\n              <RouterLink to={`${url}${x.id}`}>{x.title}</RouterLink>\r\n            </li>\r\n          );\r\n        })}\r\n      </ul>\r\n    );\r\n  };\r\n\r\n  if (loading) return <Spinner />;\r\n  if (error) return <Error value={error} />;\r\n\r\n  return (\r\n    <AnimatedRoute>\r\n      <h2>List</h2>\r\n      {slot || renderList()}\r\n    </AnimatedRoute>\r\n  );\r\n});\r\n\r\nexport default ProductList;\r\n","import { useLayoutEffect } from '../use-layout-effect';\r\nimport { type AppResource } from '../shared';\r\nimport { detectIsServer } from '../platform';\r\nimport { useEffect } from '../use-effect';\r\nimport { useSuspense } from '../suspense';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { $$scope } from '../scope';\r\nimport { error } from '../utils';\r\n\r\nfunction useResource<T>(fetch: FetchFn<T>, deps: Array<any> = []) {\r\n  const state = useMemo<State<T>>(() => ({ isFetching: true, isLoaded: false, data: null, error: null }), []);\r\n  const { register, unregister } = useSuspense();\r\n  const [mounted, firstTime] = useMounted();\r\n  const update = useUpdate();\r\n  const $update = () => mounted() && update();\r\n  const $scope = $$scope();\r\n  const id = useMemo(() => $scope.getNextResourceId(), []);\r\n  const $id = String(id);\r\n  const isServer = detectIsServer();\r\n  const isHydrateZone = $scope.getIsHydrateZone();\r\n  const make = async (isRefetch?: boolean, ...args: Array<any>) => {\r\n    try {\r\n      if (!isServer && !firstTime()) {\r\n        state.isFetching = true;\r\n        $update();\r\n      }\r\n      const data = await fetch(...(isRefetch ? args : deps));\r\n\r\n      if (isServer) {\r\n        $scope.setResource(id, [data, null]);\r\n      } else {\r\n        unregister($id);\r\n        state.data = data;\r\n        state.isFetching = false;\r\n        state.error = null;\r\n      }\r\n\r\n      return data;\r\n    } catch (err) {\r\n      error(err);\r\n\r\n      if (isServer) {\r\n        $scope.setResource(id, [null, String(err)]);\r\n      } else {\r\n        unregister($id);\r\n        state.isFetching = false;\r\n        state.error = String(err);\r\n      }\r\n    } finally {\r\n      if (!isServer) {\r\n        state.isLoaded = true;\r\n        $update();\r\n      }\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    !isHydrateZone && make();\r\n  }, [...deps]);\r\n\r\n  useEffect(() => () => unregister($id), []);\r\n\r\n  if (isServer || isHydrateZone) {\r\n    const cache = $scope.getResource(id) as AppResource<T>;\r\n\r\n    if (isServer) {\r\n      if (cache) {\r\n        mutate(state, cache);\r\n      } else {\r\n        $scope.defer(make);\r\n      }\r\n    } else if (isHydrateZone) {\r\n      if (!cache) throw new Error('[Dark]: can not read app state from the server!');\r\n      mutate(state, cache);\r\n    }\r\n  } else {\r\n    firstTime() && register($id);\r\n  }\r\n\r\n  const value: Resource<T> = {\r\n    loading: state.isFetching,\r\n    data: state.data,\r\n    error: state.error,\r\n    refetch: (...args: Array<any>) => make(true, ...args),\r\n  };\r\n\r\n  return value;\r\n}\r\n\r\nfunction mutate<T>(state: State<T>, cache: AppResource<T>) {\r\n  const [data, error] = cache;\r\n\r\n  state.isFetching = false;\r\n  state.isLoaded = true;\r\n  state.data = data;\r\n  state.error = error;\r\n}\r\n\r\nfunction useMounted() {\r\n  const scope = useMemo(() => ({ isMounted: true, isFirstTime: true }), []);\r\n  const { isFirstTime } = scope;\r\n\r\n  useLayoutEffect(() => {\r\n    scope.isFirstTime = false;\r\n    return () => (scope.isMounted = false);\r\n  }, []);\r\n\r\n  return [() => scope.isMounted, () => isFirstTime] as [BooleanFn, BooleanFn];\r\n}\r\n\r\ntype BooleanFn = () => boolean;\r\n\r\ntype State<T> = {\r\n  isFetching: boolean;\r\n  isLoaded: boolean;\r\n  data: T;\r\n  error: string;\r\n};\r\n\r\ntype Resource<T> = {\r\n  loading: boolean;\r\n  data: T;\r\n  error: string;\r\n  refetch: FetchFn<T>;\r\n};\r\n\r\ntype FetchFn<T> = (...args: Array<any>) => Promise<T>;\r\n\r\nexport { useResource };\r\n","import { useMemo } from '@dark-engine/core';\r\n\r\nimport { useActiveRouteContext, useCurrentPathContext, checkContextValue } from '../context';\r\nimport { createPathname } from '../create-routes';\r\n\r\nexport type Match = {\r\n  path: string;\r\n  url: string;\r\n};\r\n\r\nfunction useMatch(): Match {\r\n  const activeRoute = useActiveRouteContext();\r\n  checkContextValue(activeRoute);\r\n  const path = useCurrentPathContext();\r\n  const {\r\n    location: { pathname },\r\n  } = activeRoute;\r\n  const url = useMemo(() => (path ? createPathname(pathname, path) : ''), [path, pathname]);\r\n  const value: Match = { path, url };\r\n\r\n  return value;\r\n}\r\n\r\nexport { useMatch };\r\n"],"names":["sleep","ms","Promise","resolve","setTimeout","PRODUCTS_KEY","PRODUCT_KEY","cache","isServer","globalThis","process","api","async","products","Array","fill","map","_","idx","id","title","Number","isNaN","Error","product","description","fade","AnimatedRoute","value","slot","url","resource","loading","data","error","x","to","useResource","fetch","deps","state","isFetching","isLoaded","register","unregister","mounted","firstTime","scope","isMounted","isFirstTime","useMounted","update","$update","$scope","getNextResourceId","$id","String","isHydrateZone","getIsHydrateZone","make","isRefetch","args","setResource","err","getResource","mutate","defer","refetch","useMatch","activeRoute","path","location","pathname"],"sourceRoot":""}