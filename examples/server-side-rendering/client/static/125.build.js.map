{"version":3,"file":"125.build.js","mappings":"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","sources":["webpack:///./components/product-list.tsx","webpack:///../../../packages/core/src/use-resource/use-resource.ts","webpack:///../../../packages/web-router/src/use-match/use-match.ts"],"sourcesContent":["import { type DarkElement, h, component, useResource } from '@dark-engine/core';\r\nimport { RouterLink, useMatch, useLocation } from '@dark-engine/web-router';\r\nimport { styled } from '@dark-engine/styled';\r\n\r\nimport { State, api } from '../api';\r\nimport { Spinner, Error, AnimationFade, Button } from './ui';\r\n\r\nconst Header = styled.header`\r\n  display: grid;\r\n  grid-template-columns: 1fr 4fr;\r\n  grid-template-rows: auto;\r\n  padding: 16px 0;\r\n\r\n  & h2 {\r\n    margin: 0;\r\n  }\r\n`;\r\n\r\nconst List = styled.ul`\r\n  list-style: none;\r\n  padding: 0;\r\n  margin: 0;\r\n`;\r\n\r\nconst ListItem = styled.li`\r\n  width: 100%;\r\n  background-color: #fff;\r\n  margin: 6px 0;\r\n  padding: 16px;\r\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);\r\n\r\n  &:first-child {\r\n    margin-top: 0;\r\n  }\r\n`;\r\n\r\nconst ProductList = component<{ slot: DarkElement }>(({ slot }) => {\r\n  const { url } = useMatch();\r\n  const { pathname } = useLocation();\r\n  const { data, loading, error } = useResource(() => api.fetchProductList(), { key: State.PRODUCTS });\r\n  const isList = pathname.endsWith('list/');\r\n  const addUrl = url + 'add/';\r\n  const renderList = () => {\r\n    return (\r\n      <List>\r\n        {data.map(x => {\r\n          return (\r\n            <ListItem key={x.id}>\r\n              <RouterLink to={`${url}${x.id}`}>{x.name}</RouterLink>\r\n            </ListItem>\r\n          );\r\n        })}\r\n      </List>\r\n    );\r\n  };\r\n\r\n  if (loading) return <Spinner />;\r\n  if (error) return <Error value={error} />;\r\n\r\n  return (\r\n    <AnimationFade>\r\n      <Header>\r\n        <div>\r\n          {isList ? (\r\n            <Button as={RouterLink} to={addUrl}>\r\n              Add product\r\n            </Button>\r\n          ) : (\r\n            <Button onClick={() => history.back()}>Back</Button>\r\n          )}\r\n        </div>\r\n      </Header>\r\n      <AnimationFade key={pathname}>{slot || renderList()}</AnimationFade>\r\n    </AnimationFade>\r\n  );\r\n});\r\n\r\nexport default ProductList;\r\n","import { type InMemoryCache, useCache, CACHE_ROOT_ID } from '../cache';\r\nimport { type AppResource, type Callback, type TextBased } from '../shared';\r\nimport { useLayoutEffect } from '../use-layout-effect';\r\nimport { error, detectIsFunction } from '../utils';\r\nimport { detectIsServer } from '../platform';\r\nimport { useEffect } from '../use-effect';\r\nimport { useSuspense } from '../suspense';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { $$scope } from '../scope';\r\n\r\ntype UseResourceOptions<V extends Variables> = {\r\n  variables?: V;\r\n  key?: string;\r\n  extractId?: (x: V) => TextBased;\r\n};\r\n\r\nfunction useResource<T, V extends Variables>(query: Query<T, V>, options?: UseResourceOptions<V>) {\r\n  const { variables = {} as V, key, extractId = () => CACHE_ROOT_ID } = options || { variables: {} as V };\r\n  const cache = useCache();\r\n  const cacheId = extractId(variables);\r\n  const state = useMemo<State<T, V>>(() => createState<T, V>(cache, key, cacheId), []);\r\n  const { register, unregister } = useSuspense();\r\n  const [mounted, firstTime] = useMounted();\r\n  const update = useUpdate();\r\n  const $update = () => mounted() && update();\r\n  const $scope = $$scope();\r\n  const id = useMemo(() => $scope.getNextResourceId(), []);\r\n  const $id = String(id);\r\n  const isServer = detectIsServer();\r\n  const isHydrateZone = $scope.getIsHydrateZone();\r\n  const { isLoaded } = state;\r\n\r\n  state.variables = variables;\r\n\r\n  const make = async (isRefetch?: boolean, $variables?: V) => {\r\n    const $$variables = isRefetch ? $variables : variables;\r\n\r\n    try {\r\n      if (!isServer && !firstTime()) {\r\n        state.isFetching = true;\r\n        $update();\r\n      }\r\n      const data = await query($$variables);\r\n\r\n      if (isServer) {\r\n        $scope.setResource(id, [data, null]);\r\n      } else {\r\n        unregister($id);\r\n        state.data = data;\r\n        state.isFetching = false;\r\n        state.error = null;\r\n        key && data && cache?.write({ key, id: extractId($$variables), data });\r\n      }\r\n\r\n      return data;\r\n    } catch (err) {\r\n      error(err);\r\n\r\n      if (isServer) {\r\n        $scope.setResource(id, [null, String(err)]);\r\n      } else {\r\n        unregister($id);\r\n        state.isFetching = false;\r\n        state.error = String(err);\r\n      }\r\n    } finally {\r\n      if (!isServer) {\r\n        state.isLoaded = true;\r\n        $update();\r\n      }\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (isHydrateZone) return;\r\n    if (key && cache) {\r\n      const record = cache.read({ key, id: cacheId });\r\n\r\n      if (record?.isValid) return;\r\n    }\r\n\r\n    make();\r\n  }, [...mapRecord(variables)]);\r\n\r\n  useEffect(() => {\r\n    let off: Callback = null;\r\n\r\n    if (cache) {\r\n      off = cache.onChange(({ type, key: $key, id: $id }) => {\r\n        if ($key === key && $id === extractId(state.variables)) {\r\n          if (type === 'invalidate' || type === 'optimistic') {\r\n            make();\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    return () => {\r\n      unregister($id);\r\n      detectIsFunction(off) && off();\r\n    };\r\n  }, []);\r\n\r\n  if (isServer || isHydrateZone) {\r\n    const res = $scope.getResource(id) as AppResource<T>;\r\n\r\n    if (isServer) {\r\n      if (res) {\r\n        mutate(state, res);\r\n      } else {\r\n        $scope.defer(make);\r\n      }\r\n    } else if (isHydrateZone) {\r\n      if (!res) throw new Error('[Dark]: can not read app state from the server!');\r\n      mutate(state, res);\r\n    }\r\n  } else {\r\n    firstTime() && !isLoaded && register($id);\r\n  }\r\n\r\n  const result: Result<T> = {\r\n    loading: state.isFetching,\r\n    data: state.data,\r\n    error: state.error,\r\n    refetch: (variables: V) => make(true, variables),\r\n  };\r\n\r\n  return result;\r\n}\r\n\r\nfunction createState<T, V>(cache: InMemoryCache, key: string, id: TextBased) {\r\n  const state: State<T, V> = { isFetching: true, isLoaded: false, data: null, error: null, variables: null };\r\n\r\n  if (cache) {\r\n    const record = cache.read({ key, id });\r\n\r\n    if (record) {\r\n      state.isFetching = false;\r\n      state.isLoaded = true;\r\n      state.data = record.data as T;\r\n    }\r\n  }\r\n\r\n  return state;\r\n}\r\n\r\nfunction mutate<T>(state: State<T>, res: AppResource<T>) {\r\n  const [data, error] = res;\r\n\r\n  state.isFetching = false;\r\n  state.isLoaded = true;\r\n  state.data = data;\r\n  state.error = error;\r\n}\r\n\r\nfunction useMounted() {\r\n  const scope = useMemo(() => ({ isMounted: true, isFirstTime: true }), []);\r\n  const { isFirstTime } = scope;\r\n\r\n  useLayoutEffect(() => {\r\n    scope.isFirstTime = false;\r\n    return () => (scope.isMounted = false);\r\n  }, []);\r\n\r\n  return [() => scope.isMounted, () => isFirstTime] as [BooleanFn, BooleanFn];\r\n}\r\n\r\nconst mapRecord = (record: object) => Object.keys(record).map(x => record[x]);\r\n\r\ntype BooleanFn = () => boolean;\r\n\r\ntype State<T, V = unknown> = {\r\n  isFetching: boolean;\r\n  isLoaded: boolean;\r\n  data: T;\r\n  error: string;\r\n  variables: V;\r\n};\r\n\r\ntype Result<T> = {\r\n  loading: boolean;\r\n  data: T;\r\n  error: string;\r\n  refetch: Query<T>;\r\n};\r\n\r\ntype Variables<K extends string = string, V = any> = Record<K, V>;\r\n\r\ntype Query<T, V extends Variables = Variables> = (variables: V) => Promise<T>;\r\n\r\ntype FetchPolicy = 'no-cache' | 'cache-only' | 'cache-first' | 'network-only' | 'cache-and-network';\r\n\r\nexport { useResource };\r\n","import { useMemo } from '@dark-engine/core';\r\n\r\nimport { useActiveRouteContext, useCurrentPathContext, checkContextValue } from '../context';\r\nimport { createPathname } from '../create-routes';\r\n\r\nexport type Match = {\r\n  path: string;\r\n  url: string;\r\n};\r\n\r\nfunction useMatch(): Match {\r\n  const activeRoute = useActiveRouteContext();\r\n  checkContextValue(activeRoute);\r\n  const path = useCurrentPathContext();\r\n  const {\r\n    location: { pathname },\r\n  } = activeRoute;\r\n  const url = useMemo(() => (path ? createPathname(pathname, path) : ''), [path, pathname]);\r\n  const value: Match = { path, url };\r\n\r\n  return value;\r\n}\r\n\r\nexport { useMatch };\r\n"],"names":["Header","List","ListItem","slot","url","pathname","data","loading","error","key","isList","endsWith","addUrl","value","as","to","onClick","history","back","map","x","id","name","useResource","query","options","variables","extractId","cache","cacheId","state","isFetching","isLoaded","record","read","createState","register","unregister","mounted","firstTime","scope","isMounted","isFirstTime","useMounted","update","$update","$scope","getNextResourceId","$id","String","isServer","isHydrateZone","getIsHydrateZone","make","async","isRefetch","$variables","$$variables","setResource","write","err","isValid","mapRecord","off","onChange","type","$key","res","getResource","mutate","defer","Error","result","refetch","Object","keys","useMatch","activeRoute","path","location"],"sourceRoot":""}