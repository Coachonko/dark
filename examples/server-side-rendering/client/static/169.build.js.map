{"version":3,"file":"169.build.js","mappings":"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","sources":["webpack:///./api/index.ts","webpack:///./components/error.tsx","webpack:///./components/product-card.tsx","webpack:///../../../packages/web-router/src/use-params/use-params.ts","webpack:///../../../packages/core/src/use-resource/use-resource.ts","webpack:///../../../packages/web-router/src/use-match/use-match.ts"],"sourcesContent":["type ProductBrief = {\r\n  id: number;\r\n  title: string;\r\n};\r\n\r\ntype Product = {\r\n  id: number;\r\n  title: string;\r\n  description: string;\r\n};\r\n\r\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\nconst PRODUCTS_KEY = 'products';\r\nconst PRODUCT_KEY = 'product';\r\nconst cache: Record<string, any> = {\r\n  [PRODUCTS_KEY]: null,\r\n  [PRODUCT_KEY]: {},\r\n};\r\nconst isServer = typeof globalThis.process !== 'undefined';\r\n\r\nconst api = {\r\n  async fetchProductList() {\r\n    if (isServer || !cache[PRODUCTS_KEY]) {\r\n      await sleep(isServer ? 100 : 600);\r\n      const products: Array<ProductBrief> = new Array(10)\r\n        .fill(null)\r\n        .map((_, idx) => ({ id: idx + 1, title: `Product #${idx + 1}` }));\r\n\r\n      cache[PRODUCTS_KEY] = products;\r\n    }\r\n\r\n    return cache[PRODUCTS_KEY] as Array<ProductBrief>;\r\n  },\r\n  async fetchProduct(id: number) {\r\n    if (isServer || !cache[PRODUCT_KEY][id]) {\r\n      await sleep(isServer ? 100 : 600);\r\n      if (typeof id !== 'number' || Number.isNaN(id)) throw new Error('Invalid id!');\r\n      const product: Product = {\r\n        id,\r\n        title: `Product #${id}`,\r\n        description:\r\n          'Lorem ipsum dolor sit amet consectetur, adipisicing elit. Nostrum blanditiis quia minus corrupti quidem. Ipsam quae ad velit repudiandae molestias unde ab officiis harum atque? Quo veritatis maxime illo asperiores.',\r\n      };\r\n\r\n      cache[PRODUCT_KEY][id] = product;\r\n    }\r\n\r\n    return cache[PRODUCT_KEY][id] as Product;\r\n  },\r\n};\r\n\r\nexport { api };\r\n","import { h, component } from '@dark-engine/core';\r\n\r\nconst Error = component<{ value: string }>(({ value }) => <div>{value} ðŸ« </div>);\r\n\r\nexport { Error };\r\n","import { h, component, useResource } from '@dark-engine/core';\r\nimport { RouterLink, useMatch, useParams } from '@dark-engine/web-router';\r\nimport { styled } from '@dark-engine/styled';\r\n\r\nimport { api } from '../api';\r\nimport { Spinner } from './spinner';\r\nimport { Error } from './error';\r\n\r\nconst Card = styled.article`\r\n  padding: 16px;\r\n  border: 1px solid #673ab7;\r\n`;\r\n\r\nconst ProductCard = component(() => {\r\n  const params = useParams();\r\n  const { url } = useMatch();\r\n  const id = Number(params.get('id'));\r\n  const resource = useResource(id => api.fetchProduct(id), [id]);\r\n  const { loading, data, error } = resource;\r\n  const back = url.replace(id + '/', '');\r\n\r\n  if (loading) return <Spinner />;\r\n  if (error) return <Error value={error} />;\r\n\r\n  return (\r\n    <Card>\r\n      <h3>{data.title}</h3>\r\n      <p>{data.description}</p>\r\n      <RouterLink to={back} className='router-back-link'>\r\n        Back\r\n      </RouterLink>\r\n    </Card>\r\n  );\r\n});\r\n\r\nexport default ProductCard;\r\n","import { useActiveRouteContext, checkContextValue } from '../context';\r\nimport { type Params } from '../create-routes';\r\n\r\nfunction useParams(): Params {\r\n  const value = useActiveRouteContext();\r\n\r\n  checkContextValue(value);\r\n\r\n  return value.params;\r\n}\r\n\r\nexport { Params, useParams };\r\n","import { useLayoutEffect } from '../use-layout-effect';\r\nimport { type AppResource } from '../shared';\r\nimport { detectIsServer } from '../platform';\r\nimport { useEffect } from '../use-effect';\r\nimport { useSuspense } from '../suspense';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { $$scope } from '../scope';\r\nimport { error } from '../utils';\r\n\r\nfunction useResource<T>(fetch: FetchFn<T>, deps: Array<any> = []) {\r\n  const state = useMemo<State<T>>(() => ({ isFetching: true, isLoaded: false, data: null, error: null }), []);\r\n  const { register, unregister } = useSuspense();\r\n  const [mounted, firstTime] = useMounted();\r\n  const update = useUpdate();\r\n  const $update = () => mounted() && update();\r\n  const $scope = $$scope();\r\n  const id = useMemo(() => $scope.getNextResourceId(), []);\r\n  const $id = String(id);\r\n  const isServer = detectIsServer();\r\n  const isHydrateZone = $scope.getIsHydrateZone();\r\n  const make = async (isRefetch?: boolean, ...args: Array<any>) => {\r\n    try {\r\n      if (!isServer && !firstTime()) {\r\n        state.isFetching = true;\r\n        $update();\r\n      }\r\n      const data = await fetch(...(isRefetch ? args : deps));\r\n\r\n      if (isServer) {\r\n        $scope.setResource(id, [data, null]);\r\n      } else {\r\n        unregister($id);\r\n        state.data = data;\r\n        state.isFetching = false;\r\n        state.error = null;\r\n      }\r\n\r\n      return data;\r\n    } catch (err) {\r\n      error(err);\r\n\r\n      if (isServer) {\r\n        $scope.setResource(id, [null, String(err)]);\r\n      } else {\r\n        unregister($id);\r\n        state.isFetching = false;\r\n        state.error = String(err);\r\n      }\r\n    } finally {\r\n      if (!isServer) {\r\n        state.isLoaded = true;\r\n        $update();\r\n      }\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    !isHydrateZone && make();\r\n  }, [...deps]);\r\n\r\n  useEffect(() => () => unregister($id), []);\r\n\r\n  if (isServer || isHydrateZone) {\r\n    const cache = $scope.getResource(id) as AppResource<T>;\r\n\r\n    if (isServer) {\r\n      if (cache) {\r\n        mutate(state, cache);\r\n      } else {\r\n        $scope.defer(make);\r\n      }\r\n    } else if (isHydrateZone) {\r\n      if (!cache) throw new Error('[Dark]: can not read app state from the server!');\r\n      mutate(state, cache);\r\n    }\r\n  } else {\r\n    firstTime() && register($id);\r\n  }\r\n\r\n  const value: Resource<T> = {\r\n    loading: state.isFetching,\r\n    data: state.data,\r\n    error: state.error,\r\n    refetch: (...args: Array<any>) => make(true, ...args),\r\n  };\r\n\r\n  return value;\r\n}\r\n\r\nfunction mutate<T>(state: State<T>, cache: AppResource<T>) {\r\n  const [data, error] = cache;\r\n\r\n  state.isFetching = false;\r\n  state.isLoaded = true;\r\n  state.data = data;\r\n  state.error = error;\r\n}\r\n\r\nfunction useMounted() {\r\n  const scope = useMemo(() => ({ isMounted: true, isFirstTime: true }), []);\r\n  const { isFirstTime } = scope;\r\n\r\n  useLayoutEffect(() => {\r\n    scope.isFirstTime = false;\r\n    return () => (scope.isMounted = false);\r\n  }, []);\r\n\r\n  return [() => scope.isMounted, () => isFirstTime] as [BooleanFn, BooleanFn];\r\n}\r\n\r\ntype BooleanFn = () => boolean;\r\n\r\ntype State<T> = {\r\n  isFetching: boolean;\r\n  isLoaded: boolean;\r\n  data: T;\r\n  error: string;\r\n};\r\n\r\ntype Resource<T> = {\r\n  loading: boolean;\r\n  data: T;\r\n  error: string;\r\n  refetch: FetchFn<T>;\r\n};\r\n\r\ntype FetchFn<T> = (...args: Array<any>) => Promise<T>;\r\n\r\nexport { useResource };\r\n","import { useMemo } from '@dark-engine/core';\r\n\r\nimport { useActiveRouteContext, useCurrentPathContext, checkContextValue } from '../context';\r\nimport { createPathname } from '../create-routes';\r\n\r\nexport type Match = {\r\n  path: string;\r\n  url: string;\r\n};\r\n\r\nfunction useMatch(): Match {\r\n  const activeRoute = useActiveRouteContext();\r\n  checkContextValue(activeRoute);\r\n  const path = useCurrentPathContext();\r\n  const {\r\n    location: { pathname },\r\n  } = activeRoute;\r\n  const url = useMemo(() => (path ? createPathname(pathname, path) : ''), [path, pathname]);\r\n  const value: Match = { path, url };\r\n\r\n  return value;\r\n}\r\n\r\nexport { useMatch };\r\n"],"names":["sleep","ms","Promise","resolve","setTimeout","PRODUCTS_KEY","PRODUCT_KEY","cache","isServer","globalThis","process","api","async","products","Array","fill","map","_","idx","id","title","Number","isNaN","Error","product","description","value","Card","styled","component","params","useParams","url","get","resource","loading","data","error","back","replace","to","className","useResource","fetch","deps","state","isFetching","isLoaded","register","unregister","mounted","firstTime","scope","isMounted","isFirstTime","useMounted","update","$update","$scope","getNextResourceId","$id","String","isHydrateZone","getIsHydrateZone","make","isRefetch","args","setResource","err","getResource","mutate","defer","refetch","useMatch","activeRoute","path","location","pathname"],"sourceRoot":""}