{"version":3,"file":"374.build.js","mappings":"wNAMA,MA+CA,GA/CsB,SAAU,KAC9B,MAAM,IAAEA,IAAQ,SACVC,GAAU,SACVC,GAAS,SACTC,EAAKC,OAAOF,EAAOG,IAAI,OAEvBC,GADQ,UACOC,KAAc,CAAEC,IAAK,iBAAoBL,QACvDM,GAAe,QAAEC,KAAa,OAAY,kBAAmB,CAClEC,WAAYC,IACV,MAAMN,EAASM,EAAML,KAA0B,CAAEC,IAAK,eAEtD,GAAIF,EAAQ,CACV,MAAMO,EAAWP,EAAOQ,KAClBC,EAAMF,EAASG,WAAUC,GAAKA,EAAEd,KAAOA,KAEhC,IAATY,IACFF,EAASK,OAAOH,EAAK,GACrBH,EAAMO,WAAW,CAAEX,IAAK,aAAgBM,KAAMD,IAElD,CAEAD,EAAMQ,OAAO,CAAEZ,IAAK,iBAAoBL,MAAK,IAG3CkB,EAAUrB,EAAIsB,QAAQ,GAAGnB,YAAc,IAQ7C,OACE,OAAC,KAAI,UAAWO,GACbJ,GACC,iBACE,iB,kCAAoCH,E,SACpC,OAAC,KAAM,CAACoB,QAXKC,UACfd,UACED,EAAcN,GACpBF,EAAQwB,KAAKJ,GAAQ,GAQc,QAC7B,OAAC,KAAM,CAACE,QAAS,IAAMtB,EAAQyB,QAAM,QAGvC,iB,sCAAwCvB,E,OAG7C,G,8ECxCH,SAASwB,EAAgCC,EAAaC,GAGpD,MAAM,eAAEC,EAAiB,GAAE,WAAEnB,GAAekB,GAAW,CAAC,EAClDE,GAAS,SACTnB,GAAQ,UACRoB,GAAQ,QAA8B,KAAM,CAAGC,YAAY,EAAOnB,KAAM,KAAMoB,MAAO,QAAS,IA2BpG,MAAO,CA1BMV,SAAUW,KACrB,IAAIrB,EAAsB,KAE1B,IACEkB,EAAMC,YAAa,EACnBD,EAAME,MAAQ,KACdH,IACAjB,QAAcc,KAAYO,IAC1B,QAAiBxB,IAAeA,EAAWC,EAAOE,GAClDgB,EAAeM,SAAQnB,GAAKL,EAAMyB,WAAW,CAAE7B,IAAKS,KAOtD,CANE,MAAOqB,IACP,QAAMA,GACNN,EAAME,MAAQK,OAAOD,EACvB,C,QACEN,EAAMC,YAAa,EACnBF,GACF,CAEA,OAAOjB,CAAI,EAEyB,CACpCJ,QAASsB,EAAMC,WACfnB,KAAMkB,EAAMlB,KACZoB,MAAOF,EAAME,OAIjB,C,oEClCA,SAASM,IACP,MAAMC,GAAc,WACpB,QAAkBA,GAClB,MAAMC,GAAO,WAEXC,UAAU,SAAEC,IACVH,EACEzC,GAAM,QAAQ,IAAO0C,GAAO,QAAeE,EAAUF,GAAQ,IAAK,CAACA,EAAME,IAG/E,MAFqB,CAAEF,OAAM1C,MAG/B,C,gDClBA,SAAS6C,IACP,MAAMC,GAAQ,UAId,OAFA,QAAkBA,GAEXA,EAAM5C,MACf,C","sources":["webpack:///./components/product-remove.tsx","webpack:///../../../packages/core/src/use-mutation/use-mutation.ts","webpack:///../../../packages/web-router/src/use-match/use-match.ts","webpack:///../../../packages/web-router/src/use-params/use-params.ts"],"sourcesContent":["import { h, Fragment, component, useMutation, useCache } from '@dark-engine/core';\r\nimport { useMatch, useHistory, useParams } from '@dark-engine/web-router';\r\n\r\nimport { type ProductBrief, type Product, State, api } from '../api';\r\nimport { Card, Button } from './ui';\r\n\r\nconst ProductRemove = component(() => {\r\n  const { url } = useMatch();\r\n  const history = useHistory();\r\n  const params = useParams();\r\n  const id = Number(params.get('id'));\r\n  const cache = useCache();\r\n  const record = cache.read<Product>({ key: State.PRODUCT_ITEM, id });\r\n  const [removeProduct, { loading }] = useMutation(api.removeProduct, {\r\n    onComplete: cache => {\r\n      const record = cache.read<Array<ProductBrief>>({ key: State.PRODUCTS });\r\n\r\n      if (record) {\r\n        const products = record.data;\r\n        const idx = products.findIndex(x => x.id === id);\r\n\r\n        if (idx !== -1) {\r\n          products.splice(idx, 1);\r\n          cache.optimistic({ key: State.PRODUCTS, data: products });\r\n        }\r\n      }\r\n\r\n      cache.delete({ key: State.PRODUCT_ITEM, id });\r\n    },\r\n  });\r\n  const backUrl = url.replace(`${id}/remove/`, '');\r\n\r\n  const handleRemove = async () => {\r\n    if (loading) return;\r\n    await removeProduct(id);\r\n    history.push(backUrl);\r\n  };\r\n\r\n  return (\r\n    <Card $loading={loading}>\r\n      {record ? (\r\n        <>\r\n          <h3>Do you want to remove product #{id}? ðŸ¤”</h3>\r\n          <Button onClick={handleRemove}>Yes</Button>\r\n          <Button onClick={() => history.back()}>No</Button>\r\n        </>\r\n      ) : (\r\n        <h3>It seems there is no product with #{id} ðŸ¤«</h3>\r\n      )}\r\n    </Card>\r\n  );\r\n});\r\n\r\nexport default ProductRemove;\r\n","import { error, detectIsFunction } from '../utils';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { type InMemoryCache, useCache } from '../cache';\r\n\r\ntype UseMutatinOptions<T> = {\r\n  refetchQueries?: Array<string>;\r\n  onComplete?: (x: InMemoryCache, data: T) => void;\r\n};\r\n\r\nfunction useMutation<M extends Mutation>(mutation: M, options?: UseMutatinOptions<Awaited<ReturnType<M>>>) {\r\n  type Params = Parameters<M>;\r\n  type AwaitedResult = Awaited<ReturnType<M>>;\r\n  const { refetchQueries = [], onComplete } = options || {};\r\n  const update = useUpdate();\r\n  const cache = useCache();\r\n  const state = useMemo<State<AwaitedResult>>(() => ({ isFetching: false, data: null, error: null }), []);\r\n  const make = async (...args: Params) => {\r\n    let data: AwaitedResult = null;\r\n\r\n    try {\r\n      state.isFetching = true;\r\n      state.error = null;\r\n      update();\r\n      data = (await mutation(...args)) as AwaitedResult;\r\n      detectIsFunction(onComplete) && onComplete(cache, data);\r\n      refetchQueries.forEach(x => cache.invalidate({ key: x }));\r\n    } catch (err) {\r\n      error(err);\r\n      state.error = String(err);\r\n    } finally {\r\n      state.isFetching = false;\r\n      update();\r\n    }\r\n\r\n    return data;\r\n  };\r\n  const result: Result<AwaitedResult> = {\r\n    loading: state.isFetching,\r\n    data: state.data,\r\n    error: state.error,\r\n  };\r\n\r\n  return [make, result] as [(...args: Params) => ReturnType<M>, Result<AwaitedResult>];\r\n}\r\n\r\ntype State<T> = {\r\n  isFetching: boolean;\r\n  data: T;\r\n  error: string;\r\n};\r\n\r\ntype Result<T> = {\r\n  loading: boolean;\r\n} & Pick<State<T>, 'data' | 'error'>;\r\n\r\ntype Mutation = (...args: Array<unknown>) => Promise<unknown>;\r\n\r\nexport { useMutation };\r\n","import { useMemo } from '@dark-engine/core';\r\n\r\nimport { useActiveRouteContext, useCurrentPathContext, checkContextValue } from '../context';\r\nimport { createPathname } from '../create-routes';\r\n\r\nexport type Match = {\r\n  path: string;\r\n  url: string;\r\n};\r\n\r\nfunction useMatch(): Match {\r\n  const activeRoute = useActiveRouteContext();\r\n  checkContextValue(activeRoute);\r\n  const path = useCurrentPathContext();\r\n  const {\r\n    location: { pathname },\r\n  } = activeRoute;\r\n  const url = useMemo(() => (path ? createPathname(pathname, path) : ''), [path, pathname]);\r\n  const value: Match = { path, url };\r\n\r\n  return value;\r\n}\r\n\r\nexport { useMatch };\r\n","import { useActiveRouteContext, checkContextValue } from '../context';\r\nimport { type Params } from '../create-routes';\r\n\r\nfunction useParams(): Params {\r\n  const value = useActiveRouteContext();\r\n\r\n  checkContextValue(value);\r\n\r\n  return value.params;\r\n}\r\n\r\nexport { Params, useParams };\r\n"],"names":["url","history","params","id","Number","get","record","read","key","removeProduct","loading","onComplete","cache","products","data","idx","findIndex","x","splice","optimistic","delete","backUrl","replace","onClick","async","push","back","useMutation","mutation","options","refetchQueries","update","state","isFetching","error","args","forEach","invalidate","err","String","useMatch","activeRoute","path","location","pathname","useParams","value"],"sourceRoot":""}