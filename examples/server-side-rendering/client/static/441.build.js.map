{"version":3,"file":"441.build.js","mappings":"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","sources":["webpack:///./api/index.ts","webpack:///./components/product-edit.tsx","webpack:///../../../packages/core/src/use-mutation/use-mutation.ts","webpack:///../../../packages/web-router/src/use-match/use-match.ts","webpack:///../../../packages/web-router/src/use-params/use-params.ts"],"sourcesContent":["export type ProductBrief = {\r\n  id: number;\r\n  name: string;\r\n};\r\n\r\nexport type Product = {\r\n  id: number;\r\n  name: string;\r\n  description: string;\r\n};\r\n\r\nexport enum State {\r\n  PRODUCTS = 'products',\r\n  PRODUCT_ITEM = 'product-item',\r\n}\r\n\r\nconst IS_SERVER = typeof globalThis.window === 'undefined';\r\nconst TIMEOUT = IS_SERVER ? 100 : 600;\r\n\r\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\n// sumulates the database\r\nlet nextId = 0;\r\nconst products: Array<Product> = new Array(50).fill(null).map(() => ({\r\n  id: ++nextId,\r\n  name: `Product #${nextId}`,\r\n  description:\r\n    'Lorem ipsum dolor sit amet consectetur, adipisicing elit. Nostrum blanditiis quia minus corrupti quidem. Ipsam quae ad velit repudiandae molestias unde'.repeat(\r\n      3,\r\n    ),\r\n}));\r\n\r\n// api\r\nconst api = {\r\n  async fetchProductList() {\r\n    console.log('[fetch]: product-list');\r\n    await sleep(TIMEOUT);\r\n    const briefs = products.map(x => ({ ...x, description: null })) as Array<ProductBrief>;\r\n\r\n    return briefs;\r\n  },\r\n  async fetchProduct(id: number) {\r\n    console.log('[fetch]: product', id);\r\n    if (!detectIsValidId(id)) throwError();\r\n    await sleep(TIMEOUT);\r\n    const product = products.find(x => x.id === id) || null;\r\n\r\n    return product;\r\n  },\r\n  async addProduct(product: Partial<Product>) {\r\n    if (detectIsValidId(product.id)) throwError();\r\n    await sleep(TIMEOUT);\r\n\r\n    product.id = ++nextId;\r\n    products.push(product as Product);\r\n\r\n    return product as Product;\r\n  },\r\n  async changeProduct(product: Product) {\r\n    if (!detectIsValidId(product.id)) throwError();\r\n    if (!product) return null;\r\n    await sleep(TIMEOUT);\r\n    const idx = products.findIndex(x => x.id === product.id);\r\n\r\n    if (idx !== -1) {\r\n      products.splice(idx, 1, product);\r\n    }\r\n\r\n    return product;\r\n  },\r\n  async removeProduct(id: number) {\r\n    if (!detectIsValidId(id)) throwError();\r\n    await sleep(TIMEOUT);\r\n    const idx = products.findIndex(x => x.id === id);\r\n\r\n    if (idx !== -1) {\r\n      products.splice(idx, 1);\r\n    }\r\n\r\n    return true;\r\n  },\r\n};\r\n\r\nconst detectIsValidId = (id: unknown) => typeof id === 'number' && !Number.isNaN(id);\r\n\r\nconst throwError = () => {\r\n  throw new Error('Invalid id!');\r\n};\r\n\r\nexport { api };\r\n","import { h, component, useMutation, useCache } from '@dark-engine/core';\r\nimport { type SyntheticEvent } from '@dark-engine/platform-browser';\r\nimport { useMatch, useHistory, useParams } from '@dark-engine/web-router';\r\n\r\nimport { type Product, type ProductBrief, State, api } from '../api';\r\nimport { Card, Input, Textarea, Form, Button } from './ui';\r\n\r\nconst ProductEdit = component(() => {\r\n  const params = useParams();\r\n  const id = Number(params.get('id'));\r\n  const [changeProduct, { loading }] = useMutation(api.changeProduct, {\r\n    onComplete: (cache, product) => {\r\n      const record = cache.read<Array<ProductBrief>>({ key: State.PRODUCTS });\r\n\r\n      if (record) {\r\n        const products = record.data;\r\n        const $product = products.find(x => x.id === id);\r\n\r\n        $product.name = product.name;\r\n        cache.optimistic({ key: State.PRODUCTS, data: products });\r\n        cache.optimistic({ key: State.PRODUCT_ITEM, data: product, id });\r\n      }\r\n    },\r\n  });\r\n  const { url } = useMatch();\r\n  const history = useHistory();\r\n  const urlToList = url.replace(`${id}/edit/`, '');\r\n  const cache = useCache();\r\n  const record = cache.read<Product>({ key: State.PRODUCT_ITEM, id });\r\n  const product = record?.data;\r\n\r\n  const handleSubmit = async (e: SyntheticEvent<InputEvent, HTMLFormElement>) => {\r\n    e.preventDefault();\r\n    const name = e.target.elements['name'].value as string;\r\n    const description = e.target.elements['desc'].value as string;\r\n\r\n    if (loading) return;\r\n    await changeProduct({ ...product, name, description });\r\n    history.push(urlToList);\r\n  };\r\n\r\n  return (\r\n    <Card $loading={loading}>\r\n      <h3>Edit product</h3>\r\n      {product ? (\r\n        <Form onSubmit={handleSubmit}>\r\n          <label for='name'>Name:</label>\r\n          <Input id='name' required value={product.name} />\r\n          <label for='desc'>Description:</label>\r\n          <Textarea id='desc' required rows={5} value={product.description} />\r\n          <Button type='submit'>Edit</Button>\r\n        </Form>\r\n      ) : (\r\n        <div>It seems there is no product with #{id} ðŸ¤«</div>\r\n      )}\r\n    </Card>\r\n  );\r\n});\r\n\r\nexport default ProductEdit;\r\n","import { error, detectIsFunction } from '../utils';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { type InMemoryCache, useCache } from '../cache';\r\n\r\ntype UseMutatinOptions<T> = {\r\n  refetchQueries?: Array<string>;\r\n  onComplete?: (x: InMemoryCache, data: T) => void;\r\n};\r\n\r\nfunction useMutation<M extends Mutation>(mutation: M, options?: UseMutatinOptions<Awaited<ReturnType<M>>>) {\r\n  type Params = Parameters<M>;\r\n  type AwaitedResult = Awaited<ReturnType<M>>;\r\n  const { refetchQueries = [], onComplete } = options || {};\r\n  const update = useUpdate();\r\n  const cache = useCache();\r\n  const state = useMemo<State<AwaitedResult>>(() => ({ isFetching: false, data: null, error: null }), []);\r\n  const make = async (...args: Params) => {\r\n    let data: AwaitedResult = null;\r\n\r\n    try {\r\n      state.isFetching = true;\r\n      state.error = null;\r\n      update();\r\n      data = (await mutation(...args)) as AwaitedResult;\r\n      detectIsFunction(onComplete) && onComplete(cache, data);\r\n      refetchQueries.forEach(x => cache.invalidate({ key: x }));\r\n    } catch (err) {\r\n      error(err);\r\n      state.error = String(err);\r\n    } finally {\r\n      state.isFetching = false;\r\n      update();\r\n    }\r\n\r\n    return data;\r\n  };\r\n  const result: Result<AwaitedResult> = {\r\n    loading: state.isFetching,\r\n    data: state.data,\r\n    error: state.error,\r\n  };\r\n\r\n  return [make, result] as [(...args: Params) => ReturnType<M>, Result<AwaitedResult>];\r\n}\r\n\r\ntype State<T> = {\r\n  isFetching: boolean;\r\n  data: T;\r\n  error: string;\r\n};\r\n\r\ntype Result<T> = {\r\n  loading: boolean;\r\n} & Pick<State<T>, 'data' | 'error'>;\r\n\r\ntype Mutation = (...args: Array<unknown>) => Promise<unknown>;\r\n\r\nexport { useMutation };\r\n","import { useMemo } from '@dark-engine/core';\r\n\r\nimport { useActiveRouteContext, useCurrentPathContext, checkContextValue } from '../context';\r\nimport { createPathname } from '../create-routes';\r\n\r\nexport type Match = {\r\n  path: string;\r\n  url: string;\r\n};\r\n\r\nfunction useMatch(): Match {\r\n  const activeRoute = useActiveRouteContext();\r\n  checkContextValue(activeRoute);\r\n  const path = useCurrentPathContext();\r\n  const {\r\n    location: { pathname },\r\n  } = activeRoute;\r\n  const url = useMemo(() => (path ? createPathname(pathname, path) : ''), [path, pathname]);\r\n  const value: Match = { path, url };\r\n\r\n  return value;\r\n}\r\n\r\nexport { useMatch };\r\n","import { useActiveRouteContext, checkContextValue } from '../context';\r\nimport { type Params } from '../create-routes';\r\n\r\nfunction useParams(): Params {\r\n  const value = useActiveRouteContext();\r\n\r\n  checkContextValue(value);\r\n\r\n  return value.params;\r\n}\r\n\r\nexport { Params, useParams };\r\n"],"names":["State","TIMEOUT","globalThis","window","sleep","ms","Promise","resolve","setTimeout","nextId","products","Array","fill","map","id","name","description","repeat","api","async","console","log","x","detectIsValidId","throwError","find","product","push","idx","findIndex","splice","Number","isNaN","Error","params","get","changeProduct","loading","onComplete","cache","record","read","key","data","optimistic","url","history","urlToList","replace","onSubmit","e","preventDefault","target","elements","value","for","required","rows","type","useMutation","mutation","options","refetchQueries","update","state","isFetching","error","args","forEach","invalidate","err","String","useMatch","activeRoute","path","location","pathname","useParams"],"sourceRoot":""}