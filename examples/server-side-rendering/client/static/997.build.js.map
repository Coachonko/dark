{"version":3,"file":"997.build.js","mappings":"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","sources":["webpack:///./components/product-card.tsx","webpack:///../../../packages/core/src/use-resource/use-resource.ts","webpack:///../../../packages/web-router/src/use-match/use-match.ts","webpack:///../../../packages/web-router/src/use-params/use-params.ts"],"sourcesContent":["import { type DarkElement, h, component, Fragment, useResource } from '@dark-engine/core';\r\nimport { RouterLink, useMatch, useParams } from '@dark-engine/web-router';\r\n\r\nimport { State, api } from '../api';\r\nimport { Spinner, Error, Card, Button } from './ui';\r\n\r\ntype ProductCardProps = {\r\n  slot: DarkElement;\r\n};\r\n\r\nconst ProductCard = component<ProductCardProps>(({ slot }) => {\r\n  const params = useParams();\r\n  const { url } = useMatch();\r\n  const id = Number(params.get('id'));\r\n  const { data, loading, error } = useResource(({ id }) => api.fetchProduct(id), {\r\n    variables: { id },\r\n    key: State.PRODUCT_ITEM,\r\n    extractId: x => x.id,\r\n  });\r\n  const editUrl = url + 'edit/';\r\n  const removeUrl = url + 'remove/';\r\n\r\n  if (loading) return <Spinner />;\r\n  if (error) return <Error value={error} />;\r\n  if (slot) return slot;\r\n\r\n  return (\r\n    <Card>\r\n      {data ? (\r\n        <>\r\n          <h3>{data.name}</h3>\r\n          <p>{data.description}</p>\r\n        </>\r\n      ) : (\r\n        <h3>Item not found ðŸ˜Ÿ</h3>\r\n      )}\r\n      {data && (\r\n        <>\r\n          <Button as={RouterLink} to={editUrl}>\r\n            Edit\r\n          </Button>\r\n          <Button as={RouterLink} to={removeUrl}>\r\n            Remove\r\n          </Button>\r\n        </>\r\n      )}\r\n    </Card>\r\n  );\r\n});\r\n\r\nexport default ProductCard;\r\n","import { type InMemoryCache, useCache, CACHE_ROOT_ID } from '../cache';\r\nimport { type AppResource, type Callback, type TextBased } from '../shared';\r\nimport { error, detectIsFunction, mapRecord } from '../utils';\r\nimport { useLayoutEffect } from '../use-layout-effect';\r\nimport { detectIsServer } from '../platform';\r\nimport { useEffect } from '../use-effect';\r\nimport { useSuspense } from '../suspense';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { $$scope } from '../scope';\r\n\r\ntype UseResourceOptions<V extends Variables> = {\r\n  variables?: V;\r\n  key?: string;\r\n  extractId?: (x: V) => TextBased;\r\n};\r\n\r\nfunction useResource<T, V extends Variables>(query: Query<T, V>, options?: UseResourceOptions<V>) {\r\n  const { variables = {} as V, key: cacheKey, extractId = () => CACHE_ROOT_ID } = options || { variables: {} as V };\r\n  const $scope = $$scope();\r\n  const cache = useCache();\r\n  const cacheId = extractId(variables);\r\n  const id = useMemo(() => $scope.getNextResourceId(), []);\r\n  const state = useMemo<State<T>>(() => createState<T>(cache, cacheKey, cacheId), []);\r\n  const { register, unregister } = useSuspense();\r\n  const [mounted, firstTime] = useMounted();\r\n  const update = useUpdate();\r\n  const $update = () => mounted() && update();\r\n  const isServer = detectIsServer();\r\n  const isHydrateZone = $scope.getIsHydrateZone();\r\n  const { isLoaded } = state;\r\n\r\n  state.cacheKey = cacheKey;\r\n  state.cacheId = cacheId;\r\n\r\n  const make = async (isRefetch?: boolean, $variables?: V) => {\r\n    const $$variables = isRefetch ? $variables : variables;\r\n    const $cacheId = extractId($$variables);\r\n\r\n    try {\r\n      if (!isServer && !firstTime()) {\r\n        state.isFetching = true;\r\n        $update();\r\n      }\r\n      const data = await query($$variables);\r\n\r\n      if (isServer) {\r\n        $scope.setResource(id, [data, null]);\r\n      } else {\r\n        unregister(id);\r\n        state.data = data;\r\n        state.isFetching = false;\r\n        state.error = null;\r\n      }\r\n\r\n      if (cacheKey && cache && data) {\r\n        cache.write({ key: cacheKey, id: $cacheId, data });\r\n      }\r\n\r\n      return data;\r\n    } catch (err) {\r\n      error(err);\r\n\r\n      if (isServer) {\r\n        $scope.setResource(id, [null, String(err)]);\r\n      } else {\r\n        unregister(id);\r\n        state.isFetching = false;\r\n        state.error = String(err);\r\n      }\r\n    } finally {\r\n      if (!isServer) {\r\n        state.isLoaded = true;\r\n        $update();\r\n      }\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (isHydrateZone) return;\r\n    if (cacheKey && cache) {\r\n      const record = cache.read({ key: cacheKey, id: cacheId });\r\n\r\n      if (record?.valid) return;\r\n    }\r\n\r\n    make();\r\n  }, [...mapRecord(variables)]);\r\n\r\n  useEffect(() => {\r\n    let off: Callback = null;\r\n\r\n    if (cache) {\r\n      off = cache.onChange(({ type, key, id }) => {\r\n        if (key === state.cacheKey && id === state.cacheId) {\r\n          if (type === 'invalidate' || type === 'optimistic') {\r\n            make();\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    return () => {\r\n      unregister(id);\r\n      detectIsFunction(off) && off();\r\n    };\r\n  }, []);\r\n\r\n  if (isServer || isHydrateZone) {\r\n    const res = $scope.getResource(id) as AppResource<T>;\r\n\r\n    if (isServer) {\r\n      if (res) {\r\n        mutate(state, res);\r\n      } else {\r\n        $scope.defer(make);\r\n      }\r\n    } else if (isHydrateZone) {\r\n      if (!res) throw new Error('[Dark]: can not read app state from the server!');\r\n      const [data] = res;\r\n\r\n      mutate(state, res);\r\n\r\n      if (cacheKey && cache && data) {\r\n        cache.write({ key: cacheKey, id: cacheId, data });\r\n      }\r\n    }\r\n  } else {\r\n    firstTime() && !isLoaded && register(id);\r\n  }\r\n\r\n  const result: Result<T> = {\r\n    loading: state.isFetching,\r\n    data: state.data,\r\n    error: state.error,\r\n    refetch: (variables: V) => make(true, variables),\r\n  };\r\n\r\n  return result;\r\n}\r\n\r\nfunction createState<T>(cache: InMemoryCache, cacheKey: string, cacheId: TextBased) {\r\n  const state: State<T> = {\r\n    isFetching: true,\r\n    isLoaded: false,\r\n    data: null,\r\n    error: null,\r\n    cacheKey,\r\n    cacheId,\r\n  };\r\n\r\n  if (cache) {\r\n    const record = cache.read({ key: cacheKey, id: cacheId });\r\n\r\n    if (record) {\r\n      state.isFetching = false;\r\n      state.isLoaded = true;\r\n      state.data = record.data as T;\r\n    }\r\n  }\r\n\r\n  return state;\r\n}\r\n\r\nfunction mutate<T>(state: State<T>, res: AppResource<T>) {\r\n  const [data, error] = res;\r\n\r\n  state.isFetching = false;\r\n  state.isLoaded = true;\r\n  state.data = data;\r\n  state.error = error;\r\n}\r\n\r\nfunction useMounted() {\r\n  const scope = useMemo(() => ({ isMounted: true, isFirstTime: true }), []);\r\n  const { isFirstTime } = scope;\r\n\r\n  useLayoutEffect(() => {\r\n    scope.isFirstTime = false;\r\n    return () => (scope.isMounted = false);\r\n  }, []);\r\n\r\n  return [() => scope.isMounted, () => isFirstTime] as [BooleanFn, BooleanFn];\r\n}\r\n\r\ntype BooleanFn = () => boolean;\r\n\r\ntype State<T> = {\r\n  isFetching: boolean;\r\n  isLoaded: boolean;\r\n  data: T;\r\n  error: string;\r\n  cacheId: TextBased;\r\n  cacheKey: string;\r\n};\r\n\r\ntype Result<T> = {\r\n  loading: boolean;\r\n  data: T;\r\n  error: string;\r\n  refetch: Query<T>;\r\n};\r\n\r\ntype Variables<K extends string = string, V = any> = Record<K, V>;\r\n\r\ntype Query<T, V extends Variables = Variables> = (variables: V) => Promise<T>;\r\n\r\nexport { useResource };\r\n","import { useMemo } from '@dark-engine/core';\r\n\r\nimport { useActiveRouteContext, useCurrentPathContext, checkContextValue } from '../context';\r\nimport { createPathname } from '../create-routes';\r\n\r\nexport type Match = {\r\n  path: string;\r\n  url: string;\r\n};\r\n\r\nfunction useMatch(): Match {\r\n  const activeRoute = useActiveRouteContext();\r\n  checkContextValue(activeRoute);\r\n  const path = useCurrentPathContext();\r\n  const {\r\n    location: { pathname },\r\n  } = activeRoute;\r\n  const url = useMemo(() => (path ? createPathname(pathname, path) : ''), [path, pathname]);\r\n  const value: Match = { path, url };\r\n\r\n  return value;\r\n}\r\n\r\nexport { useMatch };\r\n","import { useActiveRouteContext, checkContextValue } from '../context';\r\nimport { type Params } from '../create-routes';\r\n\r\nfunction useParams(): Params {\r\n  const value = useActiveRouteContext();\r\n\r\n  checkContextValue(value);\r\n\r\n  return value.params;\r\n}\r\n\r\nexport { Params, useParams };\r\n"],"names":["slot","params","url","id","Number","get","data","loading","error","variables","key","extractId","x","editUrl","removeUrl","value","name","description","as","to","useResource","query","options","cacheKey","$scope","cache","cacheId","getNextResourceId","state","isFetching","isLoaded","record","read","createState","register","unregister","mounted","firstTime","scope","isMounted","isFirstTime","useMounted","update","$update","isServer","isHydrateZone","getIsHydrateZone","make","async","isRefetch","$variables","$$variables","$cacheId","setResource","write","err","String","valid","off","onChange","type","res","getResource","mutate","defer","Error","result","refetch","useMatch","activeRoute","path","location","pathname","useParams"],"sourceRoot":""}