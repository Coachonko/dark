{"version":3,"file":"build.js","mappings":"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","sources":["webpack:///webpack/runtime/load script","webpack:///../../../packages/core/src/component/component.ts","webpack:///../../../packages/core/src/constants.ts","webpack:///../../../packages/core/src/context/context.ts","webpack:///../../../packages/core/src/element/element.ts","webpack:///../../../packages/core/src/emitter/emitter.ts","webpack:///../../../packages/core/src/fiber/fiber.ts","webpack:///../../../packages/core/src/fiber/types.ts","webpack:///../../../packages/core/src/fragment/fragment.ts","webpack:///../../../packages/core/src/helpers/index.ts","webpack:///../../../packages/core/src/lazy/utils.ts","webpack:///../../../packages/core/src/memo/utils.ts","webpack:///../../../packages/core/src/platform/platform.ts","webpack:///../../../packages/core/src/scope/scope.ts","webpack:///../../../packages/core/src/unmount/unmount.ts","webpack:///../../../packages/core/src/use-callback/use-callback.ts","webpack:///../../../packages/core/src/use-effect/use-effect.ts","webpack:///../../../packages/core/src/use-insertion-effect/use-insertion-effect.ts","webpack:///../../../packages/core/src/use-layout-effect/use-layout-effect.ts","webpack:///../../../packages/core/src/use-memo/use-memo.ts","webpack:///../../../packages/core/src/use-state/use-state.ts","webpack:///../../../packages/core/src/use-update/use-update.ts","webpack:///../../../packages/core/src/batch/batch.ts","webpack:///../../../packages/core/src/view/types.ts","webpack:///../../../packages/core/src/view/view.ts","webpack:///../../../packages/core/src/walk/walk.ts","webpack:///../../../packages/core/src/workloop/workloop.ts","webpack:///../../../packages/web-router/src/constants.ts","webpack:///../../../packages/web-router/src/context/context.tsx","webpack:///../../../packages/web-router/src/create-routes/create-routes.ts","webpack:///../../../packages/web-router/src/router-link/router-link.tsx","webpack:///../../../packages/core/src/use-event/use-event.ts","webpack:///../../../packages/web-router/src/use-history/use-history.ts","webpack:///../../../packages/web-router/src/use-location/use-location.ts","webpack:///../../../packages/web-router/src/utils/utils.ts","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/ensure chunk","webpack:///webpack/runtime/get javascript chunk filename","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/publicPath","webpack:///webpack/runtime/jsonp chunk loading","webpack:///../../../packages/core/src/ref/ref.ts","webpack:///../../../packages/platform-browser/src/portal/utils.ts","webpack:///../../../packages/platform-browser/src/events/events.ts","webpack:///../../../packages/platform-browser/src/dom/dom.ts","webpack:///../../../packages/platform-browser/src/constants.ts","webpack:///../../../packages/platform-browser/src/scheduler/scheduler.ts","webpack:///../../../packages/platform-browser/src/render/render.ts","webpack:///../../../packages/core/src/shadow/utils.ts","webpack:///../../../packages/core/src/shadow/shadow.ts","webpack:///../../../packages/core/src/suspense/suspense.ts","webpack:///../../../packages/core/src/lazy/lazy.ts","webpack:///../../../packages/web-router/src/history/history.ts","webpack:///../../../packages/web-router/src/location/location.ts","webpack:///../../../packages/web-router/src/router/router.tsx","webpack:///../../../packages/core/src/use-imperative-handle/use-imperative-handle.ts","webpack:///./components/spinner.tsx","webpack:///./components/app.tsx","webpack:///./bootstrap/app.client.tsx","webpack:///../../../packages/platform-browser/src/hydrate-root/hydrate-root.tsx","webpack:///../../../packages/platform-browser/src/create-root/create-root.tsx","webpack:///./index.tsx"],"sourcesContent":["var inProgress = {};\n// data-webpack is not used as build has no uniqueName\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t};\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","import type { DarkElementKey, DarkElementInstance } from '../shared';\r\nimport { ATTR_KEY, ATTR_FLAG, Flag } from '../constants';\r\nimport { error, detectIsEmpty } from '../helpers';\r\nimport type { Ref } from '../ref';\r\nimport type { CreateElement, ComponentFactory, ComponentOptions, ShouldUpdate, StandardComponentProps } from './types';\r\n\r\nconst $$component = Symbol('component');\r\nclass Component<P extends StandardComponentProps = any, R = any> {\r\n  public type: CreateElement<P>;\r\n  public token: Symbol;\r\n  public props: P;\r\n  public ref: Ref<R>;\r\n  public dn: string;\r\n  public su?: ShouldUpdate<P>;\r\n  public children: Array<DarkElementInstance> = [];\r\n\r\n  constructor(\r\n    type: CreateElement<P>,\r\n    token: Symbol,\r\n    props: P,\r\n    ref: Ref<R>,\r\n    shouldUpdate: ShouldUpdate<P>,\r\n    displayName: string,\r\n  ) {\r\n    this.type = type;\r\n    this.token = token || $$component;\r\n    this.props = props;\r\n    ref && (this.ref = ref);\r\n    shouldUpdate && (this.su = shouldUpdate);\r\n    displayName && (this.dn = displayName);\r\n  }\r\n}\r\n\r\nfunction component<P, R = unknown>(type: CreateElement<P, R>, options: ComponentOptions<P> = {}) {\r\n  const { token, displayName, shouldUpdate, keepRef = false } = options;\r\n  const factory = (props = {} as P & StandardComponentProps, ref?: Ref<R>): Component<P & StandardComponentProps> => {\r\n    if (!keepRef && props.ref) {\r\n      delete props.ref;\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        process.env.NODE_ENV === 'development' &&\r\n          error(`[Dark]: To use ref you need to wrap the component with forwardRef!`);\r\n      }\r\n    }\r\n\r\n    return new Component(type, token, props, ref, shouldUpdate, displayName);\r\n  };\r\n\r\n  return factory as ComponentFactory<P & StandardComponentProps, R>;\r\n}\r\n\r\nconst detectIsComponent = (instance: unknown): instance is Component => instance instanceof Component;\r\n\r\nconst getComponentKey = (instance: Component): DarkElementKey =>\r\n  !detectIsEmpty(instance.props[ATTR_KEY]) ? instance.props[ATTR_KEY] : null;\r\n\r\nconst getComponentFlag = (instance: Component): Record<Flag, boolean> | null => instance.props[ATTR_FLAG] || null;\r\n\r\nexport { Component, component, detectIsComponent, getComponentKey, getComponentFlag };\r\n","export const VERSION = '0.23.0';\r\nexport const ROOT = 'dark:root';\r\nexport const REPLACER = 'dark:matter';\r\nexport const INDEX_KEY = 'dark:idx';\r\nexport const TYPE = 'type';\r\nexport const ATTR_KEY = 'key';\r\nexport const ATTR_REF = 'ref';\r\nexport const ATTR_FLAG = 'flag';\r\nexport const RESTART_TIMEOUT = 10;\r\n\r\nexport enum TaskPriority {\r\n  ANIMATION = 3,\r\n  HIGH = 2,\r\n  NORMAL = 1,\r\n  LOW = 0,\r\n}\r\n\r\nexport enum Flag {\r\n  NM = 'NM', // no moves\r\n}\r\n","import type { DarkElement } from '../shared';\r\nimport type { Fiber } from '../fiber';\r\nimport { detectIsFunction } from '../helpers';\r\nimport { currentFiberStore } from '../scope';\r\nimport { component } from '../component';\r\nimport { useEffect } from '../use-effect';\r\nimport { useMemo } from '../use-memo';\r\nimport { useUpdate } from '../use-update';\r\nimport type { Context, ContexProviderProps, ContextProviderValue } from './types';\r\n\r\ntype CreateContextOptions = {\r\n  displayName?: string;\r\n};\r\n\r\nfunction createContext<T>(defaultValue: T, options?: CreateContextOptions): Context<T> {\r\n  const { displayName = 'Context' } = options || {};\r\n  const context: Context<T> = {\r\n    displayName,\r\n    defaultValue,\r\n    Provider: null,\r\n    Consumer: null,\r\n  };\r\n\r\n  context.Provider = createProvider(context, defaultValue, displayName);\r\n  context.Consumer = createConsumer(context, displayName);\r\n\r\n  return context;\r\n}\r\n\r\nfunction createProvider<T>(context: Context<T>, defaultValue: T, displayName: string) {\r\n  return component<ContexProviderProps<T>>(\r\n    ({ value = defaultValue, slot }) => {\r\n      const fiber = currentFiberStore.get();\r\n\r\n      if (!fiber.provider) {\r\n        const providerValue: ContextProviderValue<T> = {\r\n          value,\r\n          subscribers: new Set(),\r\n          subscribe: (subscriber: (value: T) => void) => {\r\n            providerValue.subscribers.add(subscriber);\r\n\r\n            return () => providerValue.subscribers.delete(subscriber);\r\n          },\r\n        };\r\n\r\n        fiber.provider = new Map();\r\n        fiber.provider.set(context, providerValue);\r\n      }\r\n\r\n      const provider = fiber.provider.get(context);\r\n\r\n      useEffect(() => {\r\n        provider.subscribers.forEach(fn => fn(value));\r\n      }, [value]);\r\n\r\n      provider.value = value;\r\n\r\n      return slot;\r\n    },\r\n    { displayName: `${displayName}.Provider` },\r\n  );\r\n}\r\n\r\ntype ConsumerProps<T> = {\r\n  slot: (value: T) => DarkElement;\r\n};\r\n\r\nfunction createConsumer<T>(context: Context<T>, displayName: string) {\r\n  return component<ConsumerProps<T>>(\r\n    ({ slot }) => {\r\n      const value = useContext(context);\r\n\r\n      return detectIsFunction(slot) ? slot(value) : null;\r\n    },\r\n    { displayName: `${displayName}.Consumer` },\r\n  );\r\n}\r\n\r\nfunction useContext<T>(context: Context<T>): T {\r\n  const { defaultValue } = context;\r\n  const fiber = currentFiberStore.get();\r\n  const provider = useMemo(() => getProvider<T>(context, fiber), []);\r\n  const value = provider ? provider.value : defaultValue;\r\n  const update = useUpdate();\r\n  const scope = useMemo(() => ({ value }), []);\r\n  const hasProvider = Boolean(provider);\r\n\r\n  useEffect(() => {\r\n    if (!hasProvider) return;\r\n    const unsubscribe = provider.subscribe((value: T) => {\r\n      if (!Object.is(scope.value, value)) {\r\n        update();\r\n      }\r\n    });\r\n\r\n    return unsubscribe;\r\n  }, [hasProvider]);\r\n\r\n  scope.value = value;\r\n\r\n  return value;\r\n}\r\n\r\nfunction getProvider<T>(context: Context<T>, fiber: Fiber): ContextProviderValue<T> {\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    if (nextFiber.provider && nextFiber.provider.get(context)) {\r\n      return nextFiber.provider.get(context) as ContextProviderValue<T>;\r\n    }\r\n\r\n    nextFiber = nextFiber.parent;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { createContext, useContext };\r\n","import { detectIsNumber, detectIsString, detectIsFunction } from '../helpers';\r\nimport { View, Text, type TagVirtualNodeFactory } from '../view';\r\nimport { type ComponentFactory } from '../component';\r\n\r\nfunction getChildren(children: Array<any>) {\r\n  children = children.map(x => (detectIsString(x) || detectIsNumber(x) ? Text(x.toString()) : x));\r\n\r\n  return children ? (Array.isArray(children) ? [...children] : [children]) : [];\r\n}\r\n\r\nfunction createElement(\r\n  tag: string | Function,\r\n  props: any,\r\n  ...children: Array<any>\r\n): ComponentFactory | TagVirtualNodeFactory | null {\r\n  if (detectIsString(tag)) {\r\n    return View({\r\n      ...props,\r\n      as: tag,\r\n      slot: getChildren(children),\r\n    });\r\n  }\r\n\r\n  if (detectIsFunction(tag)) {\r\n    let slot = getChildren(children);\r\n\r\n    slot = slot.length === 1 ? slot[0] : slot;\r\n\r\n    return tag({ ...props, slot });\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { createElement, createElement as h };\r\n","type Subscriber<T = unknown> = (data?: T) => void;\r\n\r\ntype EventName = 'finish' | 'chunk';\r\n\r\nclass EventEmitter {\r\n  private map: Partial<Record<EventName, Set<Subscriber>>> = {};\r\n\r\n  public on<T>(e: EventName, sub: Subscriber<T>) {\r\n    !this.map[e] && (this.map[e] = new Set()), this.map[e].add(sub);\r\n\r\n    return () => this.map[e].delete(sub);\r\n  }\r\n\r\n  public emit<T>(e: EventName, data?: T) {\r\n    this.map[e] && this.map[e].forEach(x => x(data));\r\n  }\r\n}\r\n\r\nconst emitter = new EventEmitter();\r\n\r\nexport { emitter };\r\n","import { detectIsFunction } from '../helpers';\r\nimport { wipRootStore, isUpdateHookZone } from '../scope';\r\nimport { detectIsTagVirtualNode, detectIsPlainVirtualNode } from '../view';\r\nimport type { Context, ContextProviderValue } from '../context';\r\nimport type { DarkElementInstance } from '../shared';\r\nimport { type NativeElement, type Hook, EffectTag } from './types';\r\n\r\nclass Fiber<N = NativeElement> {\r\n  public id = 0;\r\n  public cc = 0; // child fibers count\r\n  public cec = 0; // child native elements count\r\n  public idx = 0; // idx of fiber in the parent fiber\r\n  public eidx = 0; // native element idx\r\n  public element: N = null; // native element\r\n  public parent: Fiber<N> = null; // parent fiber\r\n  public child: Fiber<N>; // child fiber\r\n  public next: Fiber<N>; // next sibling fiber\r\n  public alt: Fiber<N>; // alternate fiber (previous)\r\n  public move: boolean; // flag of reordering in list\r\n  public tag: EffectTag = null; // effect tag (CREATE, UPDATE, DELETE, SKIP)\r\n  public inst: DarkElementInstance = null; // instance of component or virtual node\r\n  public hook: Hook | null; // hook\r\n  public provider: Map<Context, ContextProviderValue>; // provider of context\r\n  public efHost: boolean; // effect host\r\n  public lefHost: boolean; // layout effect host\r\n  public iefHost: boolean; // insertion effect host\r\n  public aHost: boolean; // atom host\r\n  public pHost: boolean; // portal host\r\n  public marker: string; // for dev\r\n  public used: boolean; // flag if fiber already been rendered\r\n  public shadow: boolean; // flag for shadow rendering\r\n  public batch: number | NodeJS.Timeout | null; // timer for batching\r\n  public flush: boolean; // flag for optimizing removing of all elements in parent fiber\r\n  public catch: (error: Error) => void;\r\n  public cleanup: () => void;\r\n  private static nextId = 0;\r\n\r\n  constructor(hook: Hook = null, provider: Fiber['provider'] = null, idx = 0) {\r\n    this.id = ++Fiber.nextId;\r\n    this.idx = idx;\r\n    hook && (this.hook = hook);\r\n    provider && (this.provider = provider);\r\n  }\r\n\r\n  public mutate(options: Partial<Fiber<N>>) {\r\n    const keys = Object.keys(options);\r\n\r\n    for (const key of keys) {\r\n      this[key] = options[key];\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  public markEFHost() {\r\n    this.efHost = true;\r\n    this.parent && !this.parent.efHost && this.parent.markEFHost();\r\n  }\r\n\r\n  public markLEFHost() {\r\n    this.lefHost = true;\r\n    this.parent && !this.parent.lefHost && this.parent.markLEFHost();\r\n  }\r\n\r\n  public markIEFHost() {\r\n    this.iefHost = true;\r\n    this.parent && !this.parent.iefHost && this.parent.markIEFHost();\r\n  }\r\n\r\n  public markAHost() {\r\n    this.aHost = true;\r\n    this.parent && !this.parent.aHost && this.parent.markAHost();\r\n  }\r\n\r\n  public markPHost() {\r\n    this.pHost = true;\r\n    this.parent && !this.parent.pHost && this.parent.markPHost();\r\n  }\r\n\r\n  public incCEC(count = 1, force = false) {\r\n    if (!this.parent) return;\r\n    const isUpdate = isUpdateHookZone.get();\r\n    const wipFiber = wipRootStore.get();\r\n    const stop = isUpdate && wipFiber.parent === this.parent;\r\n\r\n    if (detectIsPlainVirtualNode(this.inst) || (detectIsTagVirtualNode(this.inst) && this.inst.children.length === 0)) {\r\n      this.cec = 1;\r\n    }\r\n\r\n    if (isUpdate && stop && !force) return;\r\n\r\n    this.parent.cec += count;\r\n\r\n    if (!this.parent.element) {\r\n      this.parent.incCEC(count);\r\n    }\r\n  }\r\n\r\n  public setError(error: Error) {\r\n    if (detectIsFunction(this.catch)) {\r\n      this.catch(error);\r\n    } else if (this.parent) {\r\n      this.parent.setError(error);\r\n    }\r\n  }\r\n\r\n  public static setNextId(id: number) {\r\n    Fiber.nextId = id;\r\n  }\r\n}\r\n\r\nexport { Fiber };\r\n","export enum EffectTag {\r\n  C = 'C',\r\n  U = 'U',\r\n  D = 'D',\r\n  S = 'S',\r\n}\r\n\r\nexport type NativeElement = unknown;\r\n\r\nexport type HookValue<T = any> = {\r\n  token?: Symbol;\r\n  deps: Array<any>;\r\n  value: T;\r\n};\r\n\r\nexport type Hook<T = any> = {\r\n  idx: number;\r\n  values: Array<T>;\r\n};\r\n","import { component, detectIsComponent } from '../component';\r\nimport type { KeyProps, SlotProps } from '../shared';\r\n\r\ntype FragmentProps = Required<SlotProps> & KeyProps;\r\n\r\nconst $$fragment = Symbol('fragment');\r\n\r\nconst Fragment = component<FragmentProps>(({ slot }) => slot || null, { token: $$fragment });\r\n\r\nconst detectIsFragment = (instance: unknown) => detectIsComponent(instance) && instance.token === $$fragment;\r\n\r\nexport { Fragment, detectIsFragment };\r\n","import type { NestedArray } from '../shared';\r\n\r\nconst detectIsFunction = (o: any): o is Function => typeof o === 'function';\r\n\r\nconst detectIsUndefined = (o: any): o is undefined => typeof o === 'undefined';\r\n\r\nconst detectIsNumber = (o: any): o is number => typeof o === 'number';\r\n\r\nconst detectIsString = (o: any): o is string => typeof o === 'string';\r\n\r\nconst detectIsObject = (o: any): o is object => typeof o === 'object';\r\n\r\nconst detectIsBoolean = (o: any): o is boolean => typeof o === 'boolean';\r\n\r\nconst detectIsArray = (o: any): o is Array<any> => Array.isArray(o);\r\n\r\nconst detectIsNull = (o: any): o is null => o === null;\r\n\r\nconst detectIsEmpty = (o: any) => detectIsNull(o) || detectIsUndefined(o);\r\n\r\nconst detectIsFalsy = (o: any) => detectIsNull(o) || detectIsUndefined(o) || o === false;\r\n\r\nconst getTime = () => Date.now();\r\n\r\nconst dummyFn = () => {};\r\n\r\nconst trueFn = () => true;\r\n\r\nfunction error(...args: Array<any>) {\r\n  !detectIsUndefined(console) && console.error(...args);\r\n}\r\n\r\nfunction flatten<T = any>(source: Array<NestedArray<T>>): Array<T> {\r\n  const list = [];\r\n  const levelMap = { 0: { idx: 0, source } };\r\n  let level = 0;\r\n\r\n  do {\r\n    const { source, idx } = levelMap[level];\r\n    const item = source[idx];\r\n\r\n    if (idx >= source.length) {\r\n      level--;\r\n      if (!levelMap[level]) {\r\n        levelMap[level] = {\r\n          idx: 0,\r\n          source: [],\r\n        };\r\n      }\r\n      levelMap[level].idx++;\r\n      continue;\r\n    }\r\n\r\n    if (detectIsArray(item)) {\r\n      level++;\r\n      levelMap[level] = {\r\n        idx: 0,\r\n        source: item,\r\n      };\r\n    } else {\r\n      list.push(item);\r\n      levelMap[level].idx++;\r\n    }\r\n  } while (level > 0 || levelMap[level].idx < levelMap[level].source.length);\r\n\r\n  return list;\r\n}\r\n\r\nfunction keyBy<T = any>(\r\n  list: Array<T>,\r\n  fn: (o: T) => string | number,\r\n  value = false,\r\n): Record<string | number, T | boolean> {\r\n  return list.reduce((acc, x) => ((acc[fn(x)] = value ? x : true), acc), {});\r\n}\r\n\r\nfunction detectIsDepsDifferent(deps: Array<unknown>, prevDeps: Array<unknown>): boolean {\r\n  if (deps && prevDeps && deps.length > 0 && prevDeps.length > 0) {\r\n    for (let i = 0; i < prevDeps.length; i++) {\r\n      if (prevDeps[i] !== deps[i]) return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport {\r\n  detectIsFunction,\r\n  detectIsUndefined,\r\n  detectIsNumber,\r\n  detectIsString,\r\n  detectIsObject,\r\n  detectIsBoolean,\r\n  detectIsArray,\r\n  detectIsNull,\r\n  detectIsEmpty,\r\n  detectIsFalsy,\r\n  getTime,\r\n  dummyFn,\r\n  trueFn,\r\n  error,\r\n  flatten,\r\n  keyBy,\r\n  detectIsDepsDifferent,\r\n};\r\n","import { detectIsComponent } from '../component';\r\n\r\nconst $$lazy = Symbol('lazy');\r\nconst $$loaded = Symbol('loaded');\r\n\r\nconst detectIsLazy = (instance: unknown) => detectIsComponent(instance) && instance.token === $$lazy;\r\n\r\nconst detectIsLoaded = (instance: unknown) => detectIsComponent(instance) && instance.type[$$loaded];\r\n\r\nexport { $$lazy, $$loaded, detectIsLazy, detectIsLoaded };\r\n","import { detectIsComponent } from '../component';\r\n\r\nconst $$memo = Symbol('memo');\r\n\r\nconst detectIsMemo = (instance: unknown) => detectIsComponent(instance) && instance.token === $$memo;\r\n\r\nexport { $$memo, detectIsMemo };\r\n","import { type Fiber } from '../fiber';\r\nimport { type TaskPriority } from '../constants';\r\nimport { type VirtualNode } from '../view';\r\n\r\nexport type Platform = {\r\n  createElement: <N>(vNode: VirtualNode) => N;\r\n  insertElement: <N>(node: N, idx: number, parent: N) => void; // browser only for Suspense\r\n  raf: typeof requestAnimationFrame;\r\n  caf: typeof cancelAnimationFrame;\r\n  schedule: (callback: () => void, options?: ScheduleCallbackOptions) => void;\r\n  shouldYield: () => boolean;\r\n  commit: (fiber: Fiber) => void;\r\n  finishCommit: () => void;\r\n  detectIsDynamic: () => boolean;\r\n  detectIsPortal: (instance: unknown) => boolean;\r\n  unmountPortal: (fiber: Fiber) => void;\r\n  chunk: (fiber: Fiber) => void;\r\n};\r\n\r\nexport type ScheduleCallbackOptions = {\r\n  priority?: TaskPriority;\r\n  timeoutMs?: number;\r\n  forceSync?: boolean;\r\n  onCompleted?: () => void;\r\n};\r\n\r\nconst platform: Platform = {\r\n  createElement: () => {\r\n    throw new Error(msg());\r\n  },\r\n  insertElement: () => {\r\n    throw new Error(msg());\r\n  },\r\n  raf: () => {\r\n    throw new Error(msg());\r\n  },\r\n  caf: () => {\r\n    throw new Error(msg());\r\n  },\r\n  schedule: () => {\r\n    throw new Error(msg());\r\n  },\r\n  shouldYield: () => {\r\n    throw new Error(msg());\r\n  },\r\n  commit: () => {\r\n    throw new Error(msg());\r\n  },\r\n  finishCommit: () => {\r\n    throw new Error(msg());\r\n  },\r\n  detectIsDynamic: () => {\r\n    throw new Error(msg());\r\n  },\r\n  detectIsPortal: () => {\r\n    throw new Error(msg());\r\n  },\r\n  unmountPortal: () => {\r\n    throw new Error(msg());\r\n  },\r\n  chunk: () => {\r\n    throw new Error(msg());\r\n  },\r\n};\r\n\r\nconst msg = () => `Function not installed by renderer!`;\r\n\r\nconst detectIsServer = () => !platform.detectIsDynamic();\r\n\r\nexport { platform, detectIsServer };\r\n","import type { Fiber } from '../fiber';\r\n\r\nlet rootId: number = null;\r\n\r\nconst stores = new Map<number, Store>();\r\n\r\nclass Store {\r\n  public root: Fiber = null; // root fiber for app\r\n  public wip: Fiber = null; // root work-in-progress fiber (component)\r\n  public unit: Fiber = null; // unit of work fiber (part of wip)\r\n  public cur: Fiber = null; // current mounting fiber\r\n  public events: Map<string, WeakMap<object, Function>> = new Map();\r\n  public off: Array<() => void> = [];\r\n  public candidates: Set<Fiber> = new Set();\r\n  public deletions: Set<Fiber> = new Set();\r\n  public mount: MountStore = {\r\n    level: 0,\r\n    nav: {},\r\n    deep: true,\r\n  };\r\n  public effects: Array<() => void> = [];\r\n  public lEffects: Array<() => void> = [];\r\n  public iEffects: Array<() => void> = [];\r\n  public isLEFZone = false;\r\n  public isIEFZone = false;\r\n  public uZone = false;\r\n  public bZone = false;\r\n  public hZone = false;\r\n  public sZone = false;\r\n  public isHot = false;\r\n}\r\n\r\ntype MountStore = {\r\n  level: number;\r\n  nav: Record<number, number>;\r\n  deep: boolean;\r\n};\r\n\r\nconst rootStore = {\r\n  set: (id: number) => {\r\n    rootId = id;\r\n    !stores.get(rootId) && stores.set(rootId, new Store());\r\n  },\r\n  remove: (id: number) => stores.delete(id),\r\n};\r\n\r\nconst getRootId = () => rootId;\r\n\r\nconst store = {\r\n  get: (id: number = rootId) => stores.get(id),\r\n};\r\n\r\nconst wipRootStore = {\r\n  get: () => store.get()?.wip || null,\r\n  set: (fiber: Fiber) => (store.get().wip = fiber),\r\n};\r\n\r\nconst currentRootStore = {\r\n  get: (id?: number) => store.get(id)?.root || null,\r\n  set: (fiber: Fiber) => (store.get().root = fiber),\r\n};\r\n\r\nconst nextUnitOfWorkStore = {\r\n  get: () => store.get()?.unit || null,\r\n  set: (fiber: Fiber) => (store.get().unit = fiber),\r\n};\r\n\r\nconst currentFiberStore = {\r\n  get: () => store.get()?.cur,\r\n  set: (fiber: Fiber) => (store.get().cur = fiber),\r\n};\r\n\r\nconst eventsStore = {\r\n  get: () => store.get().events,\r\n  addUnsubscriber: (fn: () => void) => store.get().off.push(fn),\r\n  unsubscribe: (id: number) => store.get(id).off.forEach(fn => fn()),\r\n};\r\n\r\nconst candidatesStore = {\r\n  get: () => store.get().candidates,\r\n  add: (fiber: Fiber) => store.get().candidates.add(fiber),\r\n  reset: () => (store.get().candidates = new Set()),\r\n};\r\n\r\nconst deletionsStore = {\r\n  get: () => store.get().deletions,\r\n  add: (fiber: Fiber) => store.get().deletions.add(fiber),\r\n  has: (fiber: Fiber) => store.get().deletions.has(fiber),\r\n  set: (deletions: Set<Fiber>) => (store.get().deletions = deletions),\r\n  reset: () => (store.get().deletions = new Set()),\r\n};\r\n\r\nconst mountStore = {\r\n  reset: () => {\r\n    store.get().mount = {\r\n      level: 0,\r\n      nav: {},\r\n      deep: true,\r\n    };\r\n  },\r\n  getIndex: () => {\r\n    const { mount } = store.get();\r\n\r\n    return mount.nav[mount.level];\r\n  },\r\n  toChild: () => {\r\n    const { mount } = store.get();\r\n\r\n    mount.level = mount.level + 1;\r\n    mount.nav[mount.level] = 0;\r\n  },\r\n  toParent: () => {\r\n    const { mount } = store.get();\r\n\r\n    mount.nav[mount.level] = 0;\r\n    mount.level = mount.level - 1;\r\n  },\r\n  toSibling: () => {\r\n    const { mount } = store.get();\r\n\r\n    mount.nav[mount.level] = mount.nav[mount.level] + 1;\r\n  },\r\n  deep: {\r\n    get: () => store.get().mount.deep,\r\n    set: (value: boolean) => (store.get().mount.deep = value),\r\n  },\r\n};\r\n\r\nconst effectsStore = {\r\n  get: () => store.get().effects,\r\n  reset: () => (store.get().effects = []),\r\n  add: (effect: () => void) => store.get().effects.push(effect),\r\n};\r\n\r\nconst layoutEffectsStore = {\r\n  get: () => store.get().lEffects,\r\n  reset: () => (store.get().lEffects = []),\r\n  add: (effect: () => void) => store.get().lEffects.push(effect),\r\n};\r\n\r\nconst insertionEffectsStore = {\r\n  get: () => store.get().iEffects,\r\n  reset: () => (store.get().iEffects = []),\r\n  add: (effect: () => void) => store.get().iEffects.push(effect),\r\n};\r\n\r\nconst isLayoutEffectsZone = {\r\n  get: () => store.get()?.isLEFZone || false,\r\n  set: (value: boolean) => (store.get().isLEFZone = value),\r\n};\r\n\r\nconst isInsertionEffectsZone = {\r\n  get: (id?: number) => store.get(id)?.isIEFZone || false,\r\n  set: (value: boolean) => (store.get().isIEFZone = value),\r\n};\r\n\r\nconst isUpdateHookZone = {\r\n  get: () => store.get()?.uZone || false,\r\n  set: (value: boolean) => (store.get().uZone = value),\r\n};\r\n\r\nconst isBatchZone = {\r\n  get: () => store.get()?.bZone || false,\r\n  set: (value: boolean) => (store.get().bZone = value),\r\n};\r\n\r\nconst isHydrateZone = {\r\n  get: () => store.get()?.hZone || false,\r\n  set: (value: boolean) => (store.get().hZone = value),\r\n};\r\n\r\nconst isStreamZone = {\r\n  get: () => store.get()?.sZone || false,\r\n  set: (value: boolean) => (store.get().sZone = value),\r\n};\r\n\r\nconst hot = {\r\n  get: () => store.get()?.isHot || false,\r\n  set: (value: boolean) => (store.get().isHot = value),\r\n};\r\n\r\nexport {\r\n  getRootId,\r\n  rootStore,\r\n  wipRootStore,\r\n  currentRootStore,\r\n  nextUnitOfWorkStore,\r\n  currentFiberStore,\r\n  eventsStore,\r\n  candidatesStore,\r\n  deletionsStore,\r\n  mountStore,\r\n  effectsStore,\r\n  layoutEffectsStore,\r\n  insertionEffectsStore,\r\n  isLayoutEffectsZone,\r\n  isInsertionEffectsZone,\r\n  isUpdateHookZone,\r\n  isBatchZone,\r\n  isHydrateZone,\r\n  isStreamZone,\r\n  hot,\r\n};\r\n","import { type Fiber } from '../fiber';\r\nimport { platform } from '../platform';\r\nimport { detectIsComponent } from '../component';\r\nimport { dropEffects } from '../use-effect';\r\nimport { dropLayoutEffects } from '../use-layout-effect';\r\nimport { dropInsertionEffects } from '../use-insertion-effect';\r\nimport { walkFiber } from '../walk';\r\nimport { detectIsUndefined } from '../helpers';\r\nimport { currentRootStore, eventsStore, rootStore } from '../scope';\r\n\r\nfunction unmountFiber(fiber: Fiber) {\r\n  if (!fiber.iefHost && !fiber.lefHost && !fiber.efHost && !fiber.aHost && !fiber.pHost) return;\r\n\r\n  walkFiber(fiber, (nextFiber, isReturn, resetIsDeepWalking, stop) => {\r\n    if (nextFiber === fiber.next) return stop();\r\n    if (!nextFiber.iefHost && !nextFiber.lefHost && !nextFiber.efHost && !nextFiber.aHost && !nextFiber.pHost)\r\n      return resetIsDeepWalking();\r\n\r\n    if (!isReturn && detectIsComponent(nextFiber.inst)) {\r\n      const hasValues = nextFiber.hook.values.length > 0;\r\n      // important order\r\n      nextFiber.iefHost && hasValues && dropInsertionEffects(nextFiber.hook);\r\n      nextFiber.lefHost && hasValues && dropLayoutEffects(nextFiber.hook);\r\n      nextFiber.efHost && hasValues && dropEffects(nextFiber.hook);\r\n      nextFiber.cleanup && nextFiber.cleanup();\r\n      nextFiber.pHost && platform.unmountPortal(nextFiber);\r\n    }\r\n  });\r\n}\r\n\r\nfunction unmountRoot(rootId: number, onCompleted: () => void) {\r\n  if (detectIsUndefined(rootId)) return;\r\n\r\n  unmountFiber(currentRootStore.get(rootId));\r\n  eventsStore.unsubscribe(rootId);\r\n  rootStore.remove(rootId);\r\n  onCompleted();\r\n}\r\n\r\nexport { unmountFiber, unmountRoot };\r\n","import { useMemo } from '../use-memo';\r\n\r\nfunction useCallback<T = Function>(callback: T, deps: Array<any>): T {\r\n  const value = useMemo(() => callback, deps);\r\n\r\n  return value;\r\n}\r\n\r\nexport { useCallback };\r\n","import { detectIsUndefined, detectIsFunction, detectIsDepsDifferent } from '../helpers';\r\nimport { currentFiberStore, effectsStore } from '../scope';\r\nimport type { Fiber, Hook, HookValue } from '../fiber';\r\nimport type { Effect, DropEffect } from './types';\r\n\r\nconst $$useEffect = Symbol('use-effect');\r\n\r\nconst { useEffect, hasEffects, dropEffects } = createEffect($$useEffect, effectsStore);\r\n\r\nfunction createEffect(token: Symbol, store: typeof effectsStore) {\r\n  function useEffect(effect: Effect, deps?: Array<any>) {\r\n    const fiber = currentFiberStore.get();\r\n    const hook = fiber.hook as Hook<HookValue<DropEffect>>;\r\n    const { idx, values } = hook;\r\n    const runEffect = () => {\r\n      values[idx] = {\r\n        deps,\r\n        token,\r\n        value: undefined,\r\n      };\r\n\r\n      store.add(() => {\r\n        values[idx].value = effect();\r\n      });\r\n    };\r\n\r\n    if (detectIsUndefined(values[idx])) {\r\n      runEffect();\r\n    } else {\r\n      const { deps: prevDeps, value: cleanup } = values[idx];\r\n      const isDepsDifferent = deps ? detectIsDepsDifferent(deps, prevDeps) : true;\r\n\r\n      if (isDepsDifferent) {\r\n        detectIsFunction(cleanup) && cleanup();\r\n        runEffect();\r\n      }\r\n    }\r\n\r\n    hook.idx++;\r\n  }\r\n\r\n  function hasEffects(fiber: Fiber) {\r\n    const { values } = fiber.hook as Hook<HookValue>;\r\n    const hasEffect = values.some(x => x.token === token);\r\n\r\n    return hasEffect;\r\n  }\r\n\r\n  function dropEffects(hook: Hook<HookValue<DropEffect>>) {\r\n    for (const value of hook.values) {\r\n      value.token === token && value.value && value.value();\r\n    }\r\n  }\r\n\r\n  return {\r\n    useEffect,\r\n    hasEffects,\r\n    dropEffects,\r\n  };\r\n}\r\n\r\nexport { useEffect, hasEffects, dropEffects, createEffect };\r\n","import { insertionEffectsStore } from '../scope';\r\nimport { createEffect } from '../use-effect';\r\n\r\nconst $$useInsertionEffect = Symbol('use-insertion-effect');\r\n\r\nconst {\r\n  useEffect: useInsertionEffect,\r\n  hasEffects: hasInsertionEffects,\r\n  dropEffects: dropInsertionEffects,\r\n} = createEffect($$useInsertionEffect, insertionEffectsStore);\r\n\r\nexport { useInsertionEffect, hasInsertionEffects, dropInsertionEffects };\r\n","import { layoutEffectsStore } from '../scope';\r\nimport { createEffect } from '../use-effect';\r\n\r\nconst $$useLayoutEffect = Symbol('use-layout-effect');\r\n\r\nconst {\r\n  useEffect: useLayoutEffect,\r\n  hasEffects: hasLayoutEffects,\r\n  dropEffects: dropLayoutEffects,\r\n} = createEffect($$useLayoutEffect, layoutEffectsStore);\r\n\r\nexport { useLayoutEffect, hasLayoutEffects, dropLayoutEffects };\r\n","import type { DarkElement, SlotProps } from '../shared';\r\nimport { detectIsUndefined, detectIsArray, detectIsDepsDifferent } from '../helpers';\r\nimport { detectIsComponent, component } from '../component';\r\nimport { detectIsVirtualNodeFactory } from '../view';\r\nimport { currentFiberStore } from '../scope';\r\nimport { Fragment } from '../fragment';\r\nimport { $$memo } from '../memo';\r\n\r\ntype MemoProps = Required<SlotProps>;\r\n\r\nconst Memo = component<MemoProps>(({ slot }) => slot, { token: $$memo });\r\n\r\nfunction check<T>(value: T) {\r\n  return detectIsVirtualNodeFactory(value) || detectIsComponent(value);\r\n}\r\n\r\nfunction wrap<T>(value: T, isDifferent: boolean) {\r\n  if (detectIsArray(value) ? check(value[0]) : check(value)) {\r\n    const component = Memo({\r\n      slot: Fragment({ slot: value as unknown as DarkElement }),\r\n    });\r\n\r\n    component.su = () => isDifferent;\r\n\r\n    return component;\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction processValue<T>(getValue: () => T, isDifferent = false) {\r\n  return wrap(getValue(), isDifferent);\r\n}\r\n\r\nfunction useMemo<T>(getValue: () => T, deps: Array<any>): T {\r\n  const fiber = currentFiberStore.get();\r\n  const { hook } = fiber;\r\n  const { idx, values } = hook;\r\n\r\n  if (detectIsUndefined(values[idx])) {\r\n    const value = processValue(getValue);\r\n\r\n    values[idx] = {\r\n      deps,\r\n      value,\r\n    };\r\n\r\n    hook.idx++;\r\n\r\n    return value as T;\r\n  }\r\n\r\n  const hookValue = values[idx];\r\n  const isDifferent = detectIsDepsDifferent(deps, hookValue.deps as Array<any>);\r\n  const getValue$ = isDifferent ? getValue : () => hookValue.value;\r\n\r\n  hookValue.deps = deps;\r\n  hookValue.value = processValue(getValue$, isDifferent);\r\n  hook.idx++;\r\n\r\n  return hookValue.value;\r\n}\r\n\r\nexport { useMemo };\r\n","import { type ScheduleCallbackOptions } from '../platform';\r\nimport { detectIsFunction } from '../helpers';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\nimport { TaskPriority } from '../constants';\r\n\r\ntype Value<T> = T | ((prevValue: T) => T);\r\n\r\nfunction useState<T = unknown>(\r\n  initialValue: T | (() => T),\r\n  options?: ScheduleCallbackOptions,\r\n): [T, (value: Value<T>) => void] {\r\n  const update = useUpdate(options);\r\n  const store = useMemo(\r\n    () => ({\r\n      value: detectIsFunction(initialValue) ? initialValue() : initialValue,\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const setState = useCallback((sourceValue: Value<T>) => {\r\n    const prevValue = store.value;\r\n    const newValue = detectIsFunction(sourceValue) ? sourceValue(prevValue) : sourceValue;\r\n\r\n    if (!Object.is(prevValue, newValue)) {\r\n      const setValue = () => (store.value = newValue);\r\n\r\n      if (options?.priority === TaskPriority.LOW) {\r\n        update(setValue);\r\n      } else {\r\n        setValue();\r\n        update();\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  return [store.value, setState];\r\n}\r\n\r\nexport { useState };\r\n","import { platform, type ScheduleCallbackOptions } from '../platform';\r\nimport { getRootId, currentFiberStore, isInsertionEffectsZone, isLayoutEffectsZone, isBatchZone } from '../scope';\r\nimport { createUpdateCallback } from '../workloop';\r\nimport { useMemo } from '../use-memo';\r\nimport { dummyFn } from '../helpers';\r\nimport { runBatch as batch } from '../batch';\r\n\r\nfunction useUpdate(options?: ScheduleCallbackOptions) {\r\n  const rootId = getRootId();\r\n  const scope = useMemo(() => ({ fiber: null }), []);\r\n\r\n  scope.fiber = currentFiberStore.get();\r\n\r\n  const update = (onStart?: () => void) => {\r\n    if (isInsertionEffectsZone.get()) return;\r\n    const callback = createUpdateCallback({\r\n      rootId,\r\n      fiber: scope.fiber,\r\n      forceStart: Boolean(options?.timeoutMs),\r\n      onStart: onStart || dummyFn,\r\n    });\r\n\r\n    if (isLayoutEffectsZone.get()) {\r\n      options = {\r\n        ...(options || {}),\r\n        forceSync: true,\r\n      };\r\n    }\r\n\r\n    if (isBatchZone.get()) {\r\n      batch(scope.fiber, () => platform.schedule(callback, options));\r\n    } else {\r\n      platform.schedule(callback, options);\r\n    }\r\n  };\r\n\r\n  return update;\r\n}\r\n\r\nexport { useUpdate };\r\n","import { type Fiber } from '../fiber';\r\nimport { isBatchZone } from '../scope';\r\n\r\nfunction batch(callback: () => void) {\r\n  isBatchZone.set(true);\r\n  callback();\r\n}\r\n\r\nfunction runBatch(fiber: Fiber, callback: () => void) {\r\n  fiber.batch && clearTimeout(fiber.batch as number);\r\n  fiber.batch = setTimeout(() => {\r\n    isBatchZone.set(false);\r\n    fiber.batch = null;\r\n    callback();\r\n  });\r\n}\r\n\r\nexport { batch, runBatch };\r\n","import { SlotProps, RefProps, KeyProps, FlagProps } from '../shared';\r\n\r\nexport type ViewDef = {\r\n  as: string;\r\n  _void?: boolean;\r\n  [prop: string]: any;\r\n} & Partial<SlotProps> &\r\n  RefProps &\r\n  KeyProps &\r\n  FlagProps;\r\n\r\nexport enum NodeType {\r\n  TAG = 'TAG',\r\n  TEXT = 'TEXT',\r\n  COMMENT = 'COMMENT',\r\n}\r\n","import { REPLACER, ATTR_KEY, ATTR_FLAG, TYPE, Flag } from '../constants';\r\nimport { detectIsArray, detectIsEmpty, detectIsFunction } from '../helpers';\r\nimport type { DarkElementKey, DarkElement } from '../shared';\r\nimport type { ComponentFactory } from '../component';\r\nimport { NodeType, type ViewDef } from './types';\r\n\r\nexport type VirtualNodeFactory = () => VirtualNode;\r\nexport type TagVirtualNodeFactory = () => TagVirtualNode;\r\nexport type PlainVirtualNode = TextVirtualNode | CommentVirtualNode;\r\n\r\nconst $$vNode = Symbol('vNode');\r\n\r\nclass VirtualNode {\r\n  public type: NodeType = null;\r\n\r\n  constructor(type: NodeType) {\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nclass TagVirtualNode extends VirtualNode {\r\n  public name: string;\r\n  public attrs: Record<string, any>;\r\n  public children: Array<TextVirtualNode | CommentVirtualNode | VirtualNodeFactory | ComponentFactory> = [];\r\n\r\n  constructor(name: string, attrs: TagVirtualNode['attrs'], children: TagVirtualNode['children']) {\r\n    super(NodeType.TAG);\r\n    this.name = name || this.name;\r\n    Object.keys(attrs).length > 0 && (this.attrs = attrs);\r\n    this.children = children || this.children;\r\n  }\r\n}\r\n\r\nclass TextVirtualNode extends VirtualNode {\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super(NodeType.TEXT);\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nclass CommentVirtualNode extends VirtualNode {\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super(NodeType.COMMENT);\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nconst detectIsVirtualNode = (vNode: unknown): vNode is VirtualNode => vNode instanceof VirtualNode;\r\n\r\nconst detectIsTagVirtualNode = (vNode: unknown): vNode is TagVirtualNode => vNode instanceof TagVirtualNode;\r\n\r\nconst detectIsCommentVirtualNode = (vNode: unknown): vNode is CommentVirtualNode => vNode instanceof CommentVirtualNode;\r\n\r\nconst detectIsTextVirtualNode = (vNode: unknown): vNode is TextVirtualNode => vNode instanceof TextVirtualNode;\r\n\r\nconst detectIsVirtualNodeFactory = (factory: unknown): factory is VirtualNodeFactory =>\r\n  detectIsFunction(factory) && factory[$$vNode] === true;\r\n\r\nconst getTagVirtualNodeKey = (vNode: TagVirtualNode): DarkElementKey | null =>\r\n  vNode.attrs && !detectIsEmpty(vNode.attrs[ATTR_KEY]) ? vNode.attrs[ATTR_KEY] : null;\r\n\r\nconst getTagVirtualNodeFlag = (vNode: TagVirtualNode): Record<Flag, boolean> | null =>\r\n  (vNode.attrs && vNode.attrs[ATTR_FLAG]) || null;\r\n\r\nconst getVirtualNodeFactoryKey = (factory: VirtualNodeFactory): DarkElementKey | null =>\r\n  !detectIsEmpty(factory[ATTR_KEY]) ? factory[ATTR_KEY] : null;\r\n\r\nconst getVirtualNodeFactoryFlag = (factory: VirtualNodeFactory): Record<Flag, boolean> | null =>\r\n  factory[ATTR_FLAG] || null;\r\n\r\nconst createReplacer = () => new CommentVirtualNode(REPLACER);\r\n\r\nconst detectIsPlainVirtualNode = (vNode: unknown): vNode is PlainVirtualNode =>\r\n  detectIsTextVirtualNode(vNode) || detectIsCommentVirtualNode(vNode);\r\n\r\nconst detectIsReplacer = (vNode: unknown) => detectIsCommentVirtualNode(vNode) && vNode.value === REPLACER;\r\n\r\nfunction View(def: ViewDef): TagVirtualNodeFactory {\r\n  const factory = () => {\r\n    const { as: name, slot, _void = false, ...attrs } = def;\r\n    const children = (_void ? [] : detectIsArray(slot) ? slot : slot ? [slot] : []) as TagVirtualNode['children'];\r\n\r\n    return new TagVirtualNode(name, attrs, children);\r\n  };\r\n\r\n  factory[$$vNode] = true;\r\n  factory[TYPE] = def.as;\r\n  def.key && (factory[ATTR_KEY] = def.key);\r\n  def.flag && (factory[ATTR_FLAG] = def.flag);\r\n\r\n  return factory;\r\n}\r\n\r\nfunction Text(source: string | number): TextVirtualNode {\r\n  return new TextVirtualNode(source + '');\r\n}\r\n\r\nText.from = (source: DarkElement) => (detectIsTextVirtualNode(source) ? source.value : source + '');\r\n\r\nfunction Comment(text: string): CommentVirtualNode {\r\n  return new CommentVirtualNode(text);\r\n}\r\n\r\nexport {\r\n  VirtualNode,\r\n  TagVirtualNode,\r\n  TextVirtualNode,\r\n  CommentVirtualNode,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsCommentVirtualNode,\r\n  detectIsTextVirtualNode,\r\n  detectIsPlainVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n  getTagVirtualNodeKey,\r\n  getTagVirtualNodeFlag,\r\n  getVirtualNodeFactoryKey,\r\n  getVirtualNodeFactoryFlag,\r\n  createReplacer,\r\n  detectIsReplacer,\r\n  View,\r\n  Text,\r\n  Comment,\r\n};\r\n","import { type Fiber, EffectTag } from '../fiber';\r\nimport { platform } from '../platform';\r\n\r\nfunction walkFiber<T = unknown>(\r\n  fiber: Fiber<T>,\r\n  onLoop: (nextFiber: Fiber<T>, isReturn: boolean, resetIsDeepWalking: () => void, stop: () => void) => void,\r\n) {\r\n  let nextFiber = fiber;\r\n  let isDeepWalking = true;\r\n  let isReturn = false;\r\n  let isStopped = false;\r\n  const visitedMap: Record<number, boolean> = {};\r\n  const detectCanVisit = (id: number) => !visitedMap[id];\r\n  const resetIsDeepWalking = () => (isDeepWalking = false);\r\n  const stop = () => (isStopped = true);\r\n\r\n  while (nextFiber) {\r\n    onLoop(nextFiber, isReturn, resetIsDeepWalking, stop);\r\n\r\n    if (isStopped) {\r\n      break;\r\n    }\r\n\r\n    if (nextFiber.child && isDeepWalking && detectCanVisit(nextFiber.child.id)) {\r\n      const newFiber = nextFiber.child;\r\n\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap[newFiber.id] = true;\r\n    } else if (nextFiber.next && detectCanVisit(nextFiber.next.id)) {\r\n      const newFiber = nextFiber.next;\r\n\r\n      isDeepWalking = true;\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap[newFiber.id] = true;\r\n    } else if (\r\n      nextFiber.parent &&\r\n      nextFiber.parent === fiber &&\r\n      nextFiber.parent.next &&\r\n      detectCanVisit(nextFiber.parent.next.id)\r\n    ) {\r\n      const newFiber = nextFiber.parent.next;\r\n\r\n      isDeepWalking = true;\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap[newFiber.id] = true;\r\n    } else if (nextFiber.parent && nextFiber.parent !== fiber) {\r\n      isDeepWalking = false;\r\n      isReturn = true;\r\n      nextFiber = nextFiber.parent;\r\n    } else {\r\n      nextFiber = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction collectElements<T, P = T>(fiber: Fiber<T>, transform: (fiber: Fiber<T>) => P): Array<P> {\r\n  const elements: Array<P> = [];\r\n\r\n  walkFiber<T>(fiber, (nextFiber, isReturn, resetIsDeepWalking, stop) => {\r\n    if (nextFiber === fiber.next || nextFiber === fiber.parent) return stop();\r\n    if (!isReturn && nextFiber.element) {\r\n      !platform.detectIsPortal(nextFiber.inst) && elements.push(transform(nextFiber));\r\n\r\n      return resetIsDeepWalking();\r\n    }\r\n  });\r\n\r\n  return elements;\r\n}\r\n\r\nfunction getFiberWithElement<T1, T2 = T1>(fiber: Fiber<T1>): Fiber<T2> {\r\n  let fiber$ = fiber as unknown as Fiber<T2>;\r\n\r\n  while (fiber$) {\r\n    if (fiber$.element) return fiber$;\r\n    fiber$ = fiber$.parent;\r\n  }\r\n\r\n  return fiber$;\r\n}\r\n\r\nfunction detectIsFiberAlive(fiber: Fiber) {\r\n  let fiber$ = fiber;\r\n\r\n  while (fiber$) {\r\n    if (fiber$.tag === EffectTag.D) return false;\r\n    fiber$ = fiber$.parent;\r\n  }\r\n\r\n  return Boolean(fiber);\r\n}\r\n\r\nexport { walkFiber, collectElements, getFiberWithElement, detectIsFiberAlive };\r\n","import { platform, detectIsServer } from '../platform';\r\nimport { INDEX_KEY, TYPE, RESTART_TIMEOUT, Flag } from '../constants';\r\nimport {\r\n  flatten,\r\n  error,\r\n  detectIsEmpty,\r\n  detectIsFalsy,\r\n  detectIsArray,\r\n  detectIsString,\r\n  detectIsNumber,\r\n} from '../helpers';\r\nimport {\r\n  wipRootStore,\r\n  currentRootStore,\r\n  nextUnitOfWorkStore,\r\n  candidatesStore,\r\n  deletionsStore,\r\n  mountStore,\r\n  currentFiberStore,\r\n  isUpdateHookZone,\r\n  isStreamZone,\r\n  rootStore,\r\n  effectsStore,\r\n  layoutEffectsStore,\r\n  insertionEffectsStore,\r\n  isLayoutEffectsZone,\r\n  isInsertionEffectsZone,\r\n  isHydrateZone,\r\n  hot,\r\n} from '../scope';\r\nimport { type Hook, Fiber, EffectTag } from '../fiber';\r\nimport type { DarkElementKey, DarkElement, DarkElementInstance } from '../shared';\r\nimport { type Component, detectIsComponent, getComponentKey, getComponentFlag } from '../component';\r\nimport {\r\n  type TagVirtualNode,\r\n  Text,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n  getTagVirtualNodeKey,\r\n  getVirtualNodeFactoryKey,\r\n  getTagVirtualNodeFlag,\r\n  getVirtualNodeFactoryFlag,\r\n  detectIsReplacer,\r\n  createReplacer,\r\n} from '../view';\r\nimport { detectIsMemo } from '../memo/utils';\r\nimport { detectIsLazy, detectIsLoaded } from '../lazy/utils';\r\nimport { hasEffects } from '../use-effect';\r\nimport { hasLayoutEffects } from '../use-layout-effect';\r\nimport { hasInsertionEffects } from '../use-insertion-effect';\r\nimport { walkFiber, getFiberWithElement, detectIsFiberAlive } from '../walk';\r\nimport { unmountFiber } from '../unmount';\r\nimport { Fragment, detectIsFragment } from '../fragment';\r\nimport { emitter } from '../emitter';\r\n\r\nlet hasError = false;\r\n\r\ntype Box = {\r\n  fiber$$: Fiber;\r\n  fiber$: Fiber;\r\n  inst$: DarkElementInstance;\r\n};\r\n\r\nexport type WorkLoop = (yield$: boolean) => boolean;\r\n\r\nfunction workLoop(yield$: boolean) {\r\n  if (hasError) return false;\r\n  const wipFiber = wipRootStore.get();\r\n  let nextUnitOfWork = nextUnitOfWorkStore.get();\r\n  let shouldYield = false;\r\n  let hasMoreWork = Boolean(nextUnitOfWork);\r\n  const box: Box = {\r\n    fiber$$: null,\r\n    fiber$: null,\r\n    inst$: null,\r\n  };\r\n\r\n  try {\r\n    while (nextUnitOfWork && !shouldYield) {\r\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork, box);\r\n      nextUnitOfWorkStore.set(nextUnitOfWork);\r\n      hasMoreWork = Boolean(nextUnitOfWork);\r\n      shouldYield = yield$ && platform.shouldYield();\r\n    }\r\n\r\n    if (!nextUnitOfWork && wipFiber) {\r\n      commit();\r\n    }\r\n  } catch (err) {\r\n    if (err instanceof StopWork) {\r\n      !yield$ && setTimeout(() => workLoop(false), RESTART_TIMEOUT);\r\n    } else {\r\n      hasError = true;\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  return hasMoreWork;\r\n}\r\n\r\nfunction performUnitOfWork(fiber: Fiber, box: Box) {\r\n  let isDeepWalking = true;\r\n  let nextFiber = fiber;\r\n  let instance = fiber.inst;\r\n  const isStream = isStreamZone.get();\r\n\r\n  while (true) {\r\n    isDeepWalking = mountStore.deep.get();\r\n    nextFiber.hook && (nextFiber.hook.idx = 0);\r\n\r\n    if (isDeepWalking) {\r\n      const hasChildren = hasChildrenProp(instance) && instance.children.length > 0;\r\n\r\n      if (hasChildren) {\r\n        mountChild(nextFiber, box);\r\n\r\n        nextFiber = box.fiber$;\r\n        instance = box.inst$;\r\n\r\n        box.fiber$$ = null;\r\n        box.fiber$ = null;\r\n        box.inst$ = null;\r\n\r\n        isStream && platform.chunk(nextFiber);\r\n\r\n        if (nextFiber) return nextFiber;\r\n      } else {\r\n        mountSibling(nextFiber, box);\r\n\r\n        const nextFiber$ = box.fiber$$;\r\n\r\n        nextFiber = box.fiber$;\r\n        instance = box.inst$;\r\n\r\n        box.fiber$$ = null;\r\n        box.fiber$ = null;\r\n        box.inst$ = null;\r\n\r\n        isStream && platform.chunk(nextFiber);\r\n\r\n        if (nextFiber$) return nextFiber$;\r\n      }\r\n    } else {\r\n      mountSibling(nextFiber, box);\r\n\r\n      const nextFiber$ = box.fiber$$;\r\n\r\n      nextFiber = box.fiber$;\r\n      instance = box.inst$;\r\n\r\n      box.fiber$$ = null;\r\n      box.fiber$ = null;\r\n      box.inst$ = null;\r\n\r\n      isStream && platform.chunk(nextFiber);\r\n\r\n      if (nextFiber$) return nextFiber$;\r\n    }\r\n\r\n    if (nextFiber.parent === null) return null;\r\n  }\r\n}\r\n\r\nfunction mountChild(nextFiber: Fiber, box: Box) {\r\n  mountStore.toChild();\r\n  let instance$ = nextFiber.inst;\r\n  const childrenIdx = 0;\r\n  const alternate = nextFiber.alt ? nextFiber.alt.child : null;\r\n  const fiber = new Fiber(\r\n    getHook(\r\n      alternate,\r\n      alternate ? alternate.inst : null,\r\n      hasChildrenProp(instance$) ? instance$.children[childrenIdx] : null,\r\n    ),\r\n    alternate ? alternate.provider : null,\r\n    childrenIdx,\r\n  );\r\n\r\n  currentFiberStore.set(fiber);\r\n  fiber.parent = nextFiber;\r\n  nextFiber.child = fiber;\r\n  fiber.eidx = nextFiber.element ? 0 : nextFiber.eidx;\r\n  instance$ = install(instance$, childrenIdx, fiber);\r\n  fiber.inst = instance$;\r\n  alternate && alt(fiber, alternate);\r\n  current(fiber, alternate, instance$);\r\n  alternate && detectIsMemo(fiber.inst) && memo(fiber);\r\n\r\n  candidatesStore.add(fiber);\r\n\r\n  box.fiber$$ = null;\r\n  box.fiber$ = fiber;\r\n  box.inst$ = instance$;\r\n}\r\n\r\nfunction mountSibling(nextFiber: Fiber, box: Box) {\r\n  mountStore.toSibling();\r\n  let instance$ = nextFiber.parent.inst;\r\n  const childrenIdx = mountStore.getIndex();\r\n  const hasSibling = hasChildrenProp(instance$) && instance$.children[childrenIdx];\r\n\r\n  if (hasSibling) {\r\n    mountStore.deep.set(true);\r\n    const alternate = nextFiber.alt ? nextFiber.alt.next : null;\r\n    const fiber = new Fiber(\r\n      getHook(\r\n        alternate,\r\n        alternate ? alternate.inst : null,\r\n        hasChildrenProp(instance$) ? instance$.children[childrenIdx] : null,\r\n      ),\r\n      alternate ? alternate.provider : null,\r\n      childrenIdx,\r\n    );\r\n\r\n    currentFiberStore.set(fiber);\r\n    fiber.parent = nextFiber.parent;\r\n    nextFiber.next = fiber;\r\n    fiber.eidx = nextFiber.eidx + (nextFiber.element ? 1 : nextFiber.cec);\r\n    instance$ = install(instance$, childrenIdx, fiber);\r\n    fiber.inst = instance$;\r\n    alternate && alt(fiber, alternate);\r\n    current(fiber, alternate, instance$);\r\n    alternate && detectIsMemo(fiber.inst) && memo(fiber);\r\n\r\n    candidatesStore.add(fiber);\r\n\r\n    box.fiber$$ = fiber;\r\n    box.fiber$ = fiber;\r\n    box.inst$ = instance$;\r\n\r\n    return;\r\n  } else {\r\n    mountStore.toParent();\r\n    mountStore.deep.set(false);\r\n    nextFiber = nextFiber.parent;\r\n    instance$ = nextFiber.inst;\r\n\r\n    if (hasChildrenProp(nextFiber.inst)) {\r\n      nextFiber.inst.children = [];\r\n    }\r\n  }\r\n\r\n  box.fiber$$ = null;\r\n  box.fiber$ = nextFiber;\r\n  box.inst$ = instance$;\r\n}\r\n\r\nfunction current(fiber: Fiber, alternate: Fiber, instance: DarkElementInstance) {\r\n  let isUpdate = false;\r\n\r\n  fiber.parent.tag === EffectTag.C && (fiber.tag = fiber.parent.tag);\r\n  fiber.parent.shadow && !fiber.parent.element && !detectIsReplacer(instance) && (fiber.shadow = true);\r\n\r\n  if (fiber.tag !== EffectTag.C) {\r\n    isUpdate =\r\n      alternate &&\r\n      detectAreSameInstanceTypes(alternate.inst, instance) &&\r\n      (alternate ? getElementKey(alternate.inst) : null) === getElementKey(instance);\r\n  }\r\n\r\n  fiber.inst = instance;\r\n  fiber.alt = alternate || null;\r\n  fiber.element = fiber.element || (isUpdate ? alternate.element : null);\r\n  fiber.tag = isUpdate ? EffectTag.U : EffectTag.C;\r\n  alternate?.cleanup && alternate.cleanup();\r\n\r\n  if (alternate && alternate.move) {\r\n    fiber.move = alternate.move;\r\n    alternate.move = false;\r\n  }\r\n\r\n  if (hasChildrenProp(fiber.inst)) {\r\n    fiber.cc = fiber.inst.children.length;\r\n  }\r\n\r\n  if (!fiber.element && detectIsVirtualNode(fiber.inst)) {\r\n    fiber.element = platform.createElement(fiber.inst);\r\n    fiber.tag = EffectTag.C;\r\n  }\r\n\r\n  fiber.element && fiber.incCEC();\r\n}\r\n\r\nfunction insertToFiber(idx: number, fiber: Fiber, child: Fiber) {\r\n  if (idx === 0 || (fiber.child && fiber.child.tag === EffectTag.D)) {\r\n    fiber.child = child;\r\n    child.parent = fiber;\r\n  } else {\r\n    fiber.next = child;\r\n    child.parent = fiber.parent;\r\n  }\r\n\r\n  return child;\r\n}\r\n\r\nfunction createConditionalFiber(alternate: Fiber, marker?: DarkElementKey) {\r\n  return new Fiber().mutate({\r\n    tag: EffectTag.C,\r\n    inst: createReplacer(),\r\n    parent: alternate,\r\n    marker: marker + '',\r\n  });\r\n}\r\n\r\nfunction canAddToDeletions(fiber: Fiber) {\r\n  let nextFiber = fiber.parent;\r\n\r\n  while (nextFiber) {\r\n    if (nextFiber.tag === EffectTag.D) return false;\r\n    nextFiber = nextFiber.parent;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction alt(fiber: Fiber, alternate: Fiber) {\r\n  const instance = fiber.inst;\r\n  const areSameTypes = detectAreSameInstanceTypes(alternate.inst, instance);\r\n  const flag = getElementFlag(instance);\r\n  const NM = flag?.[Flag.NM];\r\n\r\n  alternate.used = true;\r\n\r\n  if (!areSameTypes) {\r\n    if (canAddToDeletions(alternate)) {\r\n      alternate.tag = EffectTag.D;\r\n      deletionsStore.add(alternate);\r\n    }\r\n  } else if (hasChildrenProp(alternate.inst) && hasChildrenProp(instance) && alternate.cc !== 0) {\r\n    const hasSameCount = alternate.cc === instance.children.length;\r\n\r\n    if (NM ? !hasSameCount : true) {\r\n      const { prevKeys, nextKeys, prevKeysMap, nextKeysMap, keyedFibersMap } = extractKeys(\r\n        alternate.child,\r\n        instance.children,\r\n      );\r\n      const flush = nextKeys.length === 0;\r\n      let result: Array<[DarkElement | [DarkElementKey, DarkElementKey], string]> = [];\r\n      let size = Math.max(prevKeys.length, nextKeys.length);\r\n      let nextFiber = alternate;\r\n      let idx = 0;\r\n      let p = 0;\r\n      let n = 0;\r\n\r\n      for (let i = 0; i < size; i++) {\r\n        const nextKey = nextKeys[i - n] ?? null;\r\n        const prevKey = prevKeys[i - p] ?? null;\r\n        const prevKeyFiber = keyedFibersMap[prevKey] || null;\r\n        const nextKeyFiber = keyedFibersMap[nextKey] || createConditionalFiber(alternate, nextKey);\r\n\r\n        if (nextKey !== prevKey) {\r\n          if (nextKey !== null && !prevKeysMap[nextKey]) {\r\n            if (prevKey !== null && !nextKeysMap[prevKey]) {\r\n              process.env.NODE_ENV !== 'production' && result.push([[nextKey, prevKey], 'replace']);\r\n              nextKeyFiber.tag = EffectTag.C;\r\n              prevKeyFiber.tag = EffectTag.D;\r\n              deletionsStore.add(prevKeyFiber);\r\n            } else {\r\n              process.env.NODE_ENV !== 'production' && result.push([nextKey, 'insert']);\r\n              nextKeyFiber.tag = EffectTag.C;\r\n              p++;\r\n              size++;\r\n            }\r\n            nextFiber = insertToFiber(i, nextFiber, nextKeyFiber);\r\n          } else if (!nextKeysMap[prevKey]) {\r\n            process.env.NODE_ENV !== 'production' && result.push([prevKey, 'remove']);\r\n            prevKeyFiber.tag = EffectTag.D;\r\n            deletionsStore.add(prevKeyFiber);\r\n            flush && (prevKeyFiber.flush = true);\r\n            n++;\r\n            idx--;\r\n            size++;\r\n          } else if (nextKeysMap[prevKey] && nextKeysMap[nextKey]) {\r\n            process.env.NODE_ENV !== 'production' && result.push([[nextKey, prevKey], 'move']);\r\n            nextKeyFiber.tag = EffectTag.U;\r\n            prevKeyFiber.tag = EffectTag.U;\r\n            nextKeyFiber.move = true;\r\n            nextFiber = insertToFiber(i, nextFiber, nextKeyFiber);\r\n          }\r\n        } else if (nextKey !== null) {\r\n          process.env.NODE_ENV !== 'production' && result.push([nextKey, 'stable']);\r\n          nextKeyFiber.tag = EffectTag.U;\r\n          nextFiber = insertToFiber(i, nextFiber, nextKeyFiber);\r\n        }\r\n\r\n        nextKeyFiber.idx = idx;\r\n        idx++;\r\n      }\r\n\r\n      result = [];\r\n    }\r\n  }\r\n}\r\n\r\nfunction memo(fiber: Fiber) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (hot.get()) return;\r\n  }\r\n\r\n  const alternate = fiber.alt;\r\n  const pc = alternate.inst as Component;\r\n  const nc = fiber.inst as Component;\r\n\r\n  if (fiber.move || nc.type !== pc.type || nc.su(pc.props, nc.props)) return;\r\n\r\n  mountStore.deep.set(false);\r\n  fiber.tag = EffectTag.S;\r\n  fiber.alt = alternate;\r\n  fiber.element = alternate.element;\r\n  fiber.child = alternate.child;\r\n  fiber.hook = alternate.hook;\r\n  fiber.provider = alternate.provider;\r\n  fiber.cc = alternate.cc;\r\n  fiber.cec = alternate.cec;\r\n  fiber.catch = alternate.catch;\r\n  alternate?.cleanup && (fiber.cleanup = alternate.cleanup);\r\n  fiber.child && (fiber.child.parent = fiber);\r\n\r\n  const diff = fiber.eidx - alternate.eidx;\r\n  const deep = diff !== 0;\r\n\r\n  if (deep) {\r\n    walkFiber(fiber.child, (nextFiber, _, __, stop) => {\r\n      if (nextFiber === fiber.next || nextFiber === fiber.parent) return stop();\r\n      nextFiber.eidx += diff;\r\n      if (nextFiber.parent !== fiber && nextFiber.element) return stop();\r\n    });\r\n  }\r\n\r\n  fiber.incCEC(alternate.cec);\r\n  alternate.efHost && fiber.markEFHost();\r\n  alternate.lefHost && fiber.markLEFHost();\r\n  alternate.iefHost && fiber.markIEFHost();\r\n  alternate.aHost && fiber.markAHost();\r\n  alternate.pHost && fiber.markPHost();\r\n}\r\n\r\nfunction install(instance: DarkElementInstance, idx: number, fiber: Fiber) {\r\n  let instance$: DarkElementInstance = null;\r\n\r\n  if (hasChildrenProp(instance)) {\r\n    if (detectIsArray(instance.children[idx])) {\r\n      instance.children.splice(idx, 1, ...flatten(instance.children[idx] as unknown as Array<DarkElementInstance>));\r\n    }\r\n\r\n    instance$ = mount(fiber, instance.children[idx]);\r\n\r\n    if (detectIsComponent(instance$)) {\r\n      hasEffects(fiber) && fiber.markEFHost();\r\n      hasLayoutEffects(fiber) && fiber.markLEFHost();\r\n      hasInsertionEffects(fiber) && fiber.markIEFHost();\r\n      fiber.cleanup && fiber.markAHost();\r\n      platform.detectIsPortal(instance$) && fiber.markPHost();\r\n    }\r\n  }\r\n\r\n  return instance$;\r\n}\r\n\r\nfunction mount(fiber: Fiber, instance: DarkElementInstance) {\r\n  let instance$ = instance;\r\n  const isComponent = detectIsComponent(instance$);\r\n  const component = instance$ as Component;\r\n\r\n  if (isComponent) {\r\n    try {\r\n      let result = component.type(component.props, component.ref);\r\n\r\n      if (detectIsLazy(component) && !detectIsLoaded(component) && (isHydrateZone.get() || detectIsServer())) {\r\n        mountStore.toParent();\r\n        nextUnitOfWorkStore.set(fiber.parent);\r\n        Fiber.setNextId(fiber.parent.id);\r\n        throw new StopWork();\r\n      }\r\n\r\n      if (detectIsArray(result) && !detectIsFragment(component)) {\r\n        result = Fragment({ slot: result });\r\n      } else if (detectIsString(result) || detectIsNumber(result)) {\r\n        result = Text(result);\r\n      }\r\n\r\n      component.children = (detectIsArray(result) ? flatten(result) : [result]) as Array<DarkElementInstance>;\r\n    } catch (err) {\r\n      if (err instanceof StopWork) {\r\n        throw err;\r\n      }\r\n\r\n      component.children = [];\r\n      fiber.setError(err);\r\n      error(err);\r\n    }\r\n  } else if (detectIsVirtualNodeFactory(instance$)) {\r\n    instance$ = instance$();\r\n  }\r\n\r\n  if (hasChildrenProp(instance$)) {\r\n    instance$.children = isComponent\r\n      ? instance$.children\r\n      : detectIsArray(instance$.children)\r\n      ? flatten(instance$.children)\r\n      : [instance$.children];\r\n\r\n    for (let i = 0; i < instance$.children.length; i++) {\r\n      if (instance$.children[i]) continue;\r\n      instance$.children[i] = supportConditional(instance$.children[i]);\r\n    }\r\n\r\n    if (isComponent && component.children.length === 0) {\r\n      component.children.push(createReplacer());\r\n    }\r\n  }\r\n\r\n  return instance$;\r\n}\r\n\r\nfunction extractKeys(alternate: Fiber, children: Array<DarkElementInstance>) {\r\n  let nextFiber = alternate;\r\n  let idx = 0;\r\n  const prevKeys: Array<DarkElementKey> = [];\r\n  const nextKeys: Array<DarkElementKey> = [];\r\n  const prevKeysMap: Record<DarkElementKey, boolean> = {};\r\n  const nextKeysMap: Record<DarkElementKey, boolean> = {};\r\n  const keyedFibersMap: Record<DarkElementKey, Fiber> = {};\r\n  const usedKeysMap: Record<DarkElementKey, boolean> = {};\r\n\r\n  while (nextFiber || idx < children.length) {\r\n    if (nextFiber) {\r\n      const key = getElementKey(nextFiber.inst);\r\n      const prevKey = detectIsEmpty(key) ? createIndexKey(idx) : key;\r\n\r\n      prevKeys.push(prevKey);\r\n      prevKeysMap[prevKey] = true;\r\n      keyedFibersMap[prevKey] = nextFiber;\r\n    }\r\n\r\n    if (children[idx]) {\r\n      const instance = children[idx];\r\n      const key = getElementKey(instance);\r\n      const nextKey = detectIsEmpty(key) ? createIndexKey(idx) : key;\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (usedKeysMap[nextKey]) {\r\n          error(`[Dark]: The key of node [${nextKey}] already has been used!`, [instance]);\r\n        }\r\n\r\n        usedKeysMap[nextKey] = true;\r\n      }\r\n\r\n      nextKeys.push(nextKey);\r\n      nextKeysMap[nextKey] = true;\r\n    }\r\n\r\n    nextFiber = nextFiber ? nextFiber.next : null;\r\n    idx++;\r\n  }\r\n\r\n  return {\r\n    prevKeys,\r\n    nextKeys,\r\n    prevKeysMap,\r\n    nextKeysMap,\r\n    keyedFibersMap,\r\n  };\r\n}\r\n\r\nfunction createIndexKey(idx: number) {\r\n  return `${INDEX_KEY}:${idx}`;\r\n}\r\n\r\nfunction getElementKey(instance: DarkElementInstance): DarkElementKey | null {\r\n  const key = detectIsComponent(instance)\r\n    ? getComponentKey(instance)\r\n    : detectIsVirtualNodeFactory(instance)\r\n    ? getVirtualNodeFactoryKey(instance)\r\n    : detectIsTagVirtualNode(instance)\r\n    ? getTagVirtualNodeKey(instance)\r\n    : null;\r\n\r\n  return key;\r\n}\r\n\r\nfunction getElementFlag(instance: DarkElementInstance): Record<Flag, boolean> | null {\r\n  const flag = detectIsComponent(instance)\r\n    ? getComponentFlag(instance)\r\n    : detectIsVirtualNodeFactory(instance)\r\n    ? getVirtualNodeFactoryFlag(instance)\r\n    : detectIsTagVirtualNode(instance)\r\n    ? getTagVirtualNodeFlag(instance)\r\n    : null;\r\n\r\n  return flag;\r\n}\r\n\r\nfunction supportConditional(instance: DarkElementInstance) {\r\n  return detectIsFalsy(instance) ? createReplacer() : instance;\r\n}\r\n\r\nfunction getInstanceType(instance: DarkElementInstance): string | Function {\r\n  return detectIsVirtualNodeFactory(instance)\r\n    ? instance[TYPE]\r\n    : detectIsTagVirtualNode(instance)\r\n    ? instance.name\r\n    : detectIsVirtualNode(instance)\r\n    ? instance.type\r\n    : detectIsComponent(instance)\r\n    ? instance.type\r\n    : null;\r\n}\r\n\r\nfunction hasChildrenProp(element: DarkElementInstance): element is TagVirtualNode | Component {\r\n  return detectIsTagVirtualNode(element) || detectIsComponent(element);\r\n}\r\n\r\nfunction detectAreSameComponentTypesWithSameKeys(\r\n  prevInstance: DarkElementInstance | null,\r\n  nextInstance: DarkElementInstance | null,\r\n) {\r\n  if (\r\n    prevInstance &&\r\n    nextInstance &&\r\n    detectIsComponent(prevInstance) &&\r\n    detectIsComponent(nextInstance) &&\r\n    detectAreSameInstanceTypes(prevInstance, nextInstance, true)\r\n  ) {\r\n    return getElementKey(prevInstance) === getElementKey(nextInstance);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction detectAreSameInstanceTypes(\r\n  prevInstance: DarkElementInstance,\r\n  nextInstance: DarkElementInstance,\r\n  isComponentFactories = false,\r\n) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (process.env.NODE_ENV === 'development' && hot.get()) {\r\n      if (detectIsComponent(prevInstance) && detectIsComponent(nextInstance)) {\r\n        return prevInstance.dn === nextInstance.dn;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (isComponentFactories) {\r\n    const prevComponent = prevInstance as Component;\r\n    const nextComponent = nextInstance as Component;\r\n\r\n    return prevComponent.type === nextComponent.type;\r\n  }\r\n\r\n  return getInstanceType(prevInstance) === getInstanceType(nextInstance);\r\n}\r\n\r\nfunction getHook(alternate: Fiber, prevInstance: DarkElementInstance, nextInstance: DarkElementInstance): Hook | null {\r\n  if (alternate && detectAreSameComponentTypesWithSameKeys(prevInstance, nextInstance)) return alternate.hook;\r\n  if (detectIsComponent(nextInstance)) return createHook();\r\n\r\n  return null;\r\n}\r\n\r\nfunction createHook(): Hook {\r\n  return { idx: 0, values: [] };\r\n}\r\n\r\nfunction commit() {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    process.env.NODE_ENV === 'development' && hot.set(false);\r\n  }\r\n  const wipFiber = wipRootStore.get();\r\n  const isDynamic = platform.detectIsDynamic();\r\n  const deletions = deletionsStore.get();\r\n  const candidates = candidatesStore.get();\r\n  const isUpdate = isUpdateHookZone.get();\r\n\r\n  // important order\r\n  for (const fiber of deletions) {\r\n    unmountFiber(fiber);\r\n    platform.commit(fiber);\r\n  }\r\n\r\n  isDynamic && runInsertionEffects();\r\n  isUpdate && syncElementIndices(wipFiber);\r\n\r\n  for (const fiber of candidates) {\r\n    fiber.tag !== EffectTag.S && platform.commit(fiber);\r\n    fiber.alt = null;\r\n  }\r\n\r\n  wipFiber.alt = null;\r\n  platform.finishCommit();\r\n\r\n  isDynamic && runLayoutEffects();\r\n  isDynamic && runEffects();\r\n\r\n  flush(wipFiber);\r\n}\r\n\r\nfunction runInsertionEffects() {\r\n  isInsertionEffectsZone.set(true);\r\n  insertionEffectsStore.get().forEach(fn => fn());\r\n  isInsertionEffectsZone.set(false);\r\n}\r\n\r\nfunction runLayoutEffects() {\r\n  isLayoutEffectsZone.set(true);\r\n  layoutEffectsStore.get().forEach(fn => fn());\r\n  isLayoutEffectsZone.set(false);\r\n}\r\n\r\nfunction runEffects() {\r\n  const effects = effectsStore.get();\r\n\r\n  effects.length > 0 && setTimeout(() => effects.forEach(fn => fn()));\r\n}\r\n\r\nfunction flush(wipFiber: Fiber) {\r\n  wipRootStore.set(null); // important order\r\n  candidatesStore.reset();\r\n  deletionsStore.reset();\r\n  insertionEffectsStore.reset();\r\n  layoutEffectsStore.reset();\r\n  effectsStore.reset();\r\n  isHydrateZone.set(false);\r\n\r\n  if (isUpdateHookZone.get()) {\r\n    isUpdateHookZone.set(false);\r\n  } else {\r\n    currentRootStore.set(wipFiber);\r\n  }\r\n\r\n  emitter.emit('finish');\r\n}\r\n\r\nfunction syncElementIndices(fiber: Fiber) {\r\n  const diff = fiber.cec - fiber.alt.cec;\r\n  if (diff === 0) return;\r\n  const parentFiber = getFiberWithElement(fiber.parent);\r\n  let isRight = false;\r\n\r\n  fiber.incCEC(diff, true);\r\n\r\n  walkFiber(parentFiber.child, (nextFiber, isReturn, resetIsDeepWalking, stop) => {\r\n    if (nextFiber === parentFiber) return stop();\r\n    if (nextFiber === fiber) {\r\n      isRight = true;\r\n      return resetIsDeepWalking();\r\n    }\r\n\r\n    if (nextFiber.element) {\r\n      resetIsDeepWalking();\r\n    }\r\n\r\n    if (isRight && !isReturn) {\r\n      nextFiber.eidx += diff;\r\n    }\r\n  });\r\n}\r\n\r\ntype CreateUpdateCallbackOptions = {\r\n  rootId: number;\r\n  fiber: Fiber;\r\n  forceStart?: boolean;\r\n  onStart?: () => void;\r\n};\r\n\r\nfunction createUpdateCallback(options: CreateUpdateCallbackOptions) {\r\n  const { rootId, fiber, forceStart = false, onStart } = options;\r\n  const callback = () => {\r\n    if (!detectIsFiberAlive(fiber)) return;\r\n    forceStart && onStart && onStart();\r\n    if (fiber.used) return;\r\n    !forceStart && onStart && onStart();\r\n    rootStore.set(rootId); // !\r\n    isUpdateHookZone.set(true);\r\n    mountStore.reset();\r\n\r\n    fiber.alt = new Fiber().mutate(fiber);\r\n    fiber.marker = '🔥';\r\n    fiber.tag = EffectTag.U;\r\n    fiber.cc = 0;\r\n    fiber.cec = 0;\r\n    fiber.child = null;\r\n\r\n    wipRootStore.set(fiber);\r\n    currentFiberStore.set(fiber);\r\n    fiber.inst = mount(fiber, fiber.inst);\r\n    nextUnitOfWorkStore.set(fiber);\r\n  };\r\n\r\n  return callback;\r\n}\r\n\r\nconst detectIsBusy = () => Boolean(wipRootStore.get());\r\n\r\nclass StopWork extends Error {}\r\n\r\nexport { Fiber, workLoop, createUpdateCallback, detectIsBusy };\r\n","export const VERSION = '0.23.0';\r\nexport const SLASH = '/';\r\nexport const PARAMETER = ':';\r\nexport const WILDCARD = '**';\r\nexport const PROTOCOL_MARK = '://';\r\nexport const SEARCH_MARK = '?';\r\nexport const HASH_MARK = '#';\r\nexport const ROOT = '_ROOT_';\r\n","import { createContext, useContext } from '@dark-engine/core';\r\n\r\nimport { type RouterLocation } from '../location';\r\nimport { type RouterHistory } from '../history';\r\nimport { type Route } from '../create-routes';\r\n\r\nexport type ActiveRouteContextValue = {\r\n  location: RouterLocation;\r\n  params: Map<string, string>;\r\n  activeRoute: Route;\r\n};\r\n\r\nconst ActiveRouteContext = createContext<ActiveRouteContextValue>(null, { displayName: 'ActiveRoute' });\r\n\r\nfunction useActiveRouteContext() {\r\n  const value = useContext(ActiveRouteContext);\r\n\r\n  return value;\r\n}\r\n\r\nexport type RouterHistoryContextValue = {\r\n  history: RouterHistory;\r\n};\r\n\r\nconst RouterHistoryContext = createContext<RouterHistoryContextValue>(null, { displayName: 'RouterHistory' });\r\n\r\nfunction useRouterHistoryContext() {\r\n  const value = useContext(RouterHistoryContext);\r\n\r\n  return value;\r\n}\r\n\r\nconst CurrentPathContext = createContext<string>(null, { displayName: 'CurrentPath' });\r\n\r\nfunction useCurrentPathContext() {\r\n  const value = useContext(CurrentPathContext);\r\n\r\n  return value;\r\n}\r\n\r\nfunction checkContextValue(value: ActiveRouteContextValue | RouterHistoryContextValue) {\r\n  if (!value) {\r\n    throw new Error('[web-router]:  Illegal invoke hook outside router!');\r\n  }\r\n}\r\n\r\nexport {\r\n  ActiveRouteContext,\r\n  useActiveRouteContext,\r\n  RouterHistoryContext,\r\n  useRouterHistoryContext,\r\n  CurrentPathContext,\r\n  useCurrentPathContext,\r\n  checkContextValue,\r\n};\r\n","import { type DarkElement, type ComponentFactory, type SlotProps, keyBy, detectIsString } from '@dark-engine/core';\r\n\r\nimport { SLASH, WILDCARD, ROOT } from '../constants';\r\nimport { pipe, splitPath, normalaizePathname, detectIsParam, getParamName, sort } from '../utils';\r\nimport { CurrentPathContext } from '../context';\r\nimport type { Routes, RouteDescriptor, PathMatchStrategy, Params } from './types';\r\n\r\ntype RouteConstructorOptions = {\r\n  prefix: string;\r\n  parent: Route;\r\n} & RouteDescriptor;\r\n\r\nclass Route {\r\n  public path = '';\r\n  public pathMatch?: PathMatchStrategy;\r\n  public parent: Route = null;\r\n  public children: Array<Route> = [];\r\n  public level: number = null;\r\n  public marker = '';\r\n  public redirectTo: {\r\n    path: string;\r\n    route: Route;\r\n  };\r\n  public component: RouteConstructorOptions['component'] | null;\r\n\r\n  constructor(options: RouteConstructorOptions) {\r\n    const { prefix, path, redirectTo, pathMatch = 'prefix', children = [], parent, component } = options;\r\n    const rootPath = createRootPath(path);\r\n    const path$ = createPath(pathMatch, prefix, rootPath);\r\n\r\n    this.path = path$;\r\n    this.pathMatch = pathMatch;\r\n    this.parent = parent;\r\n    this.children = createRoutes(children, path$, this);\r\n    this.level = parent ? parent.level + 1 : 0;\r\n    this.marker = rootPath;\r\n    this.redirectTo = detectIsString(redirectTo)\r\n      ? {\r\n          path: createPath(pathMatch, prefix, createRootPath(redirectTo)),\r\n          route: null,\r\n        }\r\n      : null;\r\n    this.component = component || null;\r\n  }\r\n\r\n  private getRoute(): Route {\r\n    return this;\r\n  }\r\n\r\n  public getPath() {\r\n    return this.path.replaceAll(ROOT + SLASH, '');\r\n  }\r\n\r\n  public render(): DarkElement {\r\n    let slot = null;\r\n    let nextRoute = this.getRoute();\r\n\r\n    while (nextRoute) {\r\n      const value = nextRoute.getPath();\r\n      const component = nextRoute.component as ComponentFactory<SlotProps>;\r\n\r\n      slot = CurrentPathContext.Provider({ value, slot: [component({ slot })] });\r\n      nextRoute = nextRoute.parent;\r\n    }\r\n\r\n    return slot;\r\n  }\r\n}\r\n\r\nfunction createRoutes(routes: Routes, prefix = SLASH, parent: Route = null): Array<Route> {\r\n  const routes$: Array<Route> = [];\r\n\r\n  for (const route of routes) {\r\n    const route$ = new Route({ ...route, prefix, parent });\r\n\r\n    routes$.push(route$, ...route$.children);\r\n  }\r\n\r\n  if (!parent) {\r\n    const map = keyBy(routes$, x => x.path, true) as Record<string, Route>;\r\n\r\n    for (const route$ of routes$) {\r\n      if (route$.redirectTo) {\r\n        route$.redirectTo.route = map[route$.redirectTo.path] || null;\r\n      }\r\n    }\r\n  }\r\n\r\n  return routes$;\r\n}\r\n\r\nfunction resolve(pathname: string, routes: Array<Route>): Route {\r\n  const route = pipe<Route>(\r\n    match(pathname, routes),\r\n    redirect(),\r\n    wildcard(pathname, routes),\r\n    redirect(),\r\n    root(),\r\n    redirect(),\r\n    canRender(),\r\n  )();\r\n\r\n  return route;\r\n}\r\n\r\nfunction match(pathname: string, routes: Array<Route>) {\r\n  return (): Route => {\r\n    const [route] = pipe<Array<Route>>(\r\n      (routes: Array<Route>) => routes.filter(x => detectIsMatchByFirstStrategy(pathname, x.path)),\r\n      (routes: Array<Route>) => routes.filter(x => detectIsMatchBySecondStrategy(pathname, x.path)),\r\n    )(routes);\r\n\r\n    return pick(route);\r\n  };\r\n}\r\n\r\nfunction redirect() {\r\n  return (route: Route): Route => {\r\n    if (route?.redirectTo) return redirect()(route.redirectTo.route);\r\n    if (route?.parent?.redirectTo) return redirect()(route.parent.redirectTo.route);\r\n\r\n    return pick(route);\r\n  };\r\n}\r\n\r\nfunction wildcard(pathname: string, routes: Array<Route>) {\r\n  return (route$: Route): Route => {\r\n    if (route$) return route$;\r\n    const [route] = pipe<Array<Route>>(\r\n      (routes: Array<Route>) => routes.filter(x => x.marker === WILDCARD),\r\n      (routes: Array<Route>) => routes.filter(x => detectIsMatchAsWildcard(pathname, x.path)) || null,\r\n      (routes: Array<Route>) => sort('desc', routes, x => x.level),\r\n    )(routes);\r\n\r\n    return pick(route);\r\n  };\r\n}\r\n\r\nfunction root() {\r\n  return (route: Route): Route => {\r\n    const root = route?.children.find(x => x.marker === ROOT) || route;\r\n\r\n    return pick(root);\r\n  };\r\n}\r\n\r\nfunction canRender() {\r\n  return (route: Route): Route => {\r\n    if (route?.component) return route;\r\n\r\n    if (process.env.NODE_ENV !== 'test') {\r\n      throw new Error('[web-router]: Route not found or it has no component!');\r\n    }\r\n\r\n    return null;\r\n  };\r\n}\r\n\r\nconst pick = (route: Route): Route | null => route || null;\r\n\r\nfunction detectIsMatchByFirstStrategy(urlPath: string, routePath: string): boolean {\r\n  const matcher = createMatcher({\r\n    space: (_, b) => b,\r\n    skip: ({ isRoot, isParam }) => isRoot || isParam,\r\n  });\r\n\r\n  return matcher(urlPath, routePath);\r\n}\r\n\r\nfunction detectIsMatchBySecondStrategy(urlPath: string, routePath: string): boolean {\r\n  const matcher = createMatcher({\r\n    space: a => a,\r\n    skip: ({ isParam }) => isParam,\r\n  });\r\n\r\n  return matcher(urlPath, routePath);\r\n}\r\n\r\nfunction detectIsMatchAsWildcard(urlPath: string, routePath: string): boolean {\r\n  const matcher = createMatcher({\r\n    space: (_, b) => b,\r\n    skip: ({ isRoot, isParam, isWildcard }) => isRoot || isParam || isWildcard,\r\n  });\r\n\r\n  return matcher(urlPath, routePath);\r\n}\r\n\r\ntype CreateMatcherOptions = {\r\n  space: (a: Array<string>, b: Array<string>) => Array<string>;\r\n  skip: (options: SkipOptions) => boolean;\r\n};\r\n\r\ntype SkipOptions = {\r\n  isRoot: boolean;\r\n  isWildcard: boolean;\r\n  isParam: boolean;\r\n};\r\n\r\nfunction createMatcher(options: CreateMatcherOptions) {\r\n  const { space, skip } = options;\r\n  return (urlPath: string, routePath: string) => {\r\n    const sUrlPath = splitPath(urlPath);\r\n    const sRoutePath = splitPath(routePath);\r\n\r\n    for (let i = 0; i < space(sUrlPath, sRoutePath).length; i++) {\r\n      const segment = sRoutePath[i];\r\n      const isRoot = segment === ROOT;\r\n      const isWildcard = segment === WILDCARD;\r\n      const isParam = detectIsParam(segment);\r\n\r\n      if (segment !== sUrlPath[i] && !skip({ isRoot, isWildcard, isParam })) return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n}\r\n\r\nfunction createPathname(urlPath: string, routePath: string): string {\r\n  const sUrlPath = splitPath(urlPath);\r\n  const sRoutePath = splitPath(routePath);\r\n  const parts: Array<string> = [];\r\n\r\n  for (let i = 0; i < sRoutePath.length; i++) {\r\n    const isParam = detectIsParam(sRoutePath[i]);\r\n\r\n    if (isParam) {\r\n      const param = sUrlPath[i] || 'null';\r\n\r\n      parts.push(param);\r\n    } else {\r\n      parts.push(sRoutePath[i]);\r\n    }\r\n  }\r\n\r\n  let newPathname = normalaizePathname(parts.join(SLASH));\r\n\r\n  if (newPathname[0] !== SLASH) {\r\n    newPathname = SLASH + newPathname;\r\n  }\r\n\r\n  return newPathname;\r\n}\r\n\r\nfunction createPath(pathMatch: PathMatchStrategy, prefix: string, path: string): string {\r\n  const prefix$ = pathMatch === 'prefix' ? normalaizePathname(prefix) : '';\r\n\r\n  return normalaizePathname(prefix$ ? `${prefix$}${path}` : path);\r\n}\r\n\r\nfunction createRootPath(path: string): string {\r\n  return path === SLASH || path === '' ? ROOT : path;\r\n}\r\n\r\nconst getParamsMap = (pathname: string, route: Route): Params => {\r\n  const sPathname = splitPath(pathname);\r\n  const sPath = splitPath(route.path);\r\n  const map = new Map();\r\n\r\n  for (let i = 0; i < sPath.length; i++) {\r\n    if (detectIsParam(sPath[i])) {\r\n      map.set(getParamName(sPath[i]), sPathname[i]);\r\n    }\r\n  }\r\n\r\n  return map;\r\n};\r\n\r\nfunction resolveRoute(pathname: string, routes: Array<Route>) {\r\n  const activeRoute = resolve(pathname, routes);\r\n  const slot = activeRoute ? activeRoute.render() : null;\r\n  const params = activeRoute ? getParamsMap(pathname, activeRoute) : null;\r\n  const value = { activeRoute, slot, params };\r\n\r\n  return value;\r\n}\r\n\r\nexport { type Route, createRoutes, resolve, resolveRoute, createPathname };\r\n","import { h, component, useMemo, useEvent, detectIsFunction, type DarkElement } from '@dark-engine/core';\r\nimport { type SyntheticEvent } from '@dark-engine/platform-browser';\r\n\r\nimport { useHistory } from '../use-history';\r\nimport { useLocation } from '../use-location';\r\nimport { normalaizePathname, cm, parseURL } from '../utils';\r\n\r\nexport type RoutreLinkProps = {\r\n  to: string;\r\n  activeClassName?: string;\r\n  className?: string;\r\n  title?: string;\r\n  slot: DarkElement;\r\n  onClick?: (e: SyntheticEvent<MouseEvent, HTMLLinkElement>) => void;\r\n};\r\n\r\nconst RouterLink = component<RoutreLinkProps>(\r\n  ({ to, activeClassName = 'router-link-active', className: sourceClassName, slot, onClick, ...rest }) => {\r\n    const history = useHistory();\r\n    const { pathname, hash } = useLocation();\r\n    const isActive = useMemo(() => detectIsActiveLink(pathname, hash, to), [pathname, hash]);\r\n    const className = useMemo(\r\n      () => cm(sourceClassName, isActive ? activeClassName : ''),\r\n      [sourceClassName, activeClassName, isActive],\r\n    );\r\n\r\n    const handleClick = useEvent((e: SyntheticEvent<MouseEvent, HTMLLinkElement>) => {\r\n      e.preventDefault();\r\n      history.push(to);\r\n      detectIsFunction(onClick) && onClick(e);\r\n    });\r\n\r\n    return (\r\n      <a {...rest} href={to} class={className} onClick={handleClick}>\r\n        {slot}\r\n      </a>\r\n    );\r\n  },\r\n  {\r\n    displayName: 'RouterLink',\r\n  },\r\n);\r\n\r\nfunction detectIsActiveLink(pathname: string, hash: string, to: string): boolean {\r\n  const { pathname: to$, hash: hash$ } = parseURL(to);\r\n\r\n  return normalaizePathname(pathname).indexOf(to$) !== -1 && hash === hash$;\r\n}\r\n\r\nexport { RouterLink };\r\n","import { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\n\r\nfunction useEvent<T extends (...args: Array<any>) => any>(fn: T) {\r\n  const scope = useMemo(() => ({ fn }), []);\r\n\r\n  scope.fn = fn;\r\n\r\n  const callback = useCallback((...args: Array<any>) => {\r\n    return scope.fn(...args);\r\n  }, []);\r\n\r\n  return callback as unknown as T;\r\n}\r\n\r\nexport { useEvent };\r\n","import { useRouterHistoryContext, checkContextValue } from '../context';\r\n\r\nfunction useHistory() {\r\n  const value = useRouterHistoryContext();\r\n\r\n  checkContextValue(value);\r\n\r\n  return value.history;\r\n}\r\n\r\nexport { useHistory };\r\n","import { useActiveRouteContext, checkContextValue } from '../context';\r\n\r\nfunction useLocation() {\r\n  const activeRoute = useActiveRouteContext();\r\n\r\n  checkContextValue(activeRoute);\r\n\r\n  return activeRoute.location;\r\n}\r\n\r\nexport { useLocation };\r\n","import { SLASH, PARAMETER, PROTOCOL_MARK, HASH_MARK, SEARCH_MARK } from '../constants';\r\n\r\nfunction pipe<T>(...fns: Array<Function>): (...args: Array<any>) => T {\r\n  const [fn, ...rest] = fns;\r\n\r\n  return (...args: Array<any>) => {\r\n    return rest.reduce(\r\n      (fn1, fn2) => () => fn2(fn1()),\r\n      () => fn(...args),\r\n    )();\r\n  };\r\n}\r\n\r\nfunction parseURL(url: string) {\r\n  let body = url;\r\n  let protocol = '';\r\n  let host = '';\r\n  let pathname = '';\r\n  let hash = '';\r\n  let search = '';\r\n\r\n  if (body.indexOf(PROTOCOL_MARK) !== -1) {\r\n    [protocol, body] = body.split(PROTOCOL_MARK).filter(Boolean);\r\n  }\r\n\r\n  const splitted = body.split('');\r\n  const idx = splitted.findIndex(x => x === SLASH);\r\n\r\n  if (idx !== -1) {\r\n    host = splitted.filter((_, idx1) => idx1 < idx).join('');\r\n    pathname = splitted.filter((_, idx1) => idx1 >= idx).join('');\r\n  } else {\r\n    host = body;\r\n    pathname = pathname || SLASH;\r\n  }\r\n\r\n  if (pathname.indexOf(SEARCH_MARK) !== -1) {\r\n    [pathname, search] = split(pathname, SEARCH_MARK);\r\n  }\r\n\r\n  if (body.indexOf(HASH_MARK) !== -1) {\r\n    if (search) {\r\n      [search, hash] = split(search, HASH_MARK);\r\n    } else {\r\n      [pathname, hash] = split(pathname, HASH_MARK);\r\n    }\r\n  }\r\n\r\n  return {\r\n    protocol,\r\n    host,\r\n    pathname: addSlashToEnd(pathname),\r\n    search: createSearch(search),\r\n    hash: createHash(hash),\r\n  };\r\n}\r\n\r\nconst createSearch = (value: string) => (value ? `${SEARCH_MARK}${value}` : '');\r\n\r\nconst createHash = (value: string) => (value ? `${HASH_MARK}${value}` : '');\r\n\r\nconst detectIsParam = (value: string) => value && value.startsWith(PARAMETER);\r\n\r\nconst getParamName = (value: string) => (detectIsParam(value) ? value.slice(1, value.length) : null);\r\n\r\nconst split = (value: string, token: string) => value.split(token).filter(Boolean);\r\n\r\nconst splitPath = (path: string) => split(path, SLASH);\r\n\r\nconst addSlashToStart = (path: string) => (path.startsWith(SLASH) ? path : SLASH + path);\r\n\r\nconst addSlashToEnd = (path: string) => (path.endsWith(SLASH) ? path : path + SLASH);\r\n\r\nfunction normalaizePathname(spath: string) {\r\n  const { pathname, search, hash } = parseURL(addSlashToStart(spath));\r\n  const newSpath = pathname + search + hash;\r\n\r\n  return newSpath;\r\n}\r\n\r\nfunction sort<T>(type: 'asc' | 'desc', list: Array<T>, selector: (x: T) => number) {\r\n  const asc = (a: T, b: T) => selector(a) - selector(b);\r\n  const desc = (a: T, b: T) => selector(b) - selector(a);\r\n  const compare = type === 'asc' ? asc : desc;\r\n\r\n  return list.sort(compare);\r\n}\r\n\r\nconst cm = (...args: Array<string>) => [...args].filter(Boolean).join(' ').trim() || undefined;\r\n\r\nexport { pipe, parseURL, detectIsParam, getParamName, splitPath, normalaizePathname, sort, cm };\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".build.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunk\"] = self[\"webpackChunk\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","import { detectIsObject, detectIsNull, detectIsFunction } from '../helpers';\r\nimport type { Component, ComponentFactory } from '../component';\r\nimport type { RefProps } from '../shared';\r\nimport type { MutableRef, Ref } from './types';\r\n\r\nfunction forwardRef<P, R>(component: ComponentFactory<P, R>): ComponentFactory<P & RefProps<R>, R> {\r\n  type Props = P & RefProps<R>;\r\n\r\n  return (props: Props) => {\r\n    const { ref, ...rest } = (props || {}) as Props;\r\n\r\n    return component(rest as P, ref) as Component<P, R>;\r\n  };\r\n}\r\n\r\nfunction detectIsMutableRef(ref: unknown): ref is MutableRef {\r\n  if (!detectIsObject(ref) || detectIsNull(ref)) return false;\r\n  const mutableRef = ref as MutableRef;\r\n\r\n  for (const key in mutableRef) {\r\n    if (key === 'current' && mutableRef.hasOwnProperty(key)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction applyRef<T>(ref: Ref<T>, current: T) {\r\n  if (detectIsFunction(ref)) {\r\n    ref(current);\r\n  } else if (detectIsMutableRef(ref)) {\r\n    ref.current = current;\r\n  }\r\n}\r\n\r\nexport { forwardRef, detectIsMutableRef, applyRef };\r\n","import { type Fiber, detectIsComponent } from '@dark-engine/core';\r\n\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\nconst $$portal = Symbol('portal');\r\n\r\nconst detectIsPortal = (instance: unknown) => detectIsComponent(instance) && instance.token === $$portal;\r\n\r\nconst getPortalContainer = (fiber: Fiber<TagNativeElement>): TagNativeElement | null =>\r\n  detectIsPortal(fiber.inst) ? fiber.element : null;\r\n\r\nfunction unmountPortal(fiber: Fiber<TagNativeElement>) {\r\n  const element = getPortalContainer(fiber);\r\n\r\n  element && (element.textContent = '');\r\n}\r\n\r\nexport { $$portal, detectIsPortal, unmountPortal };\r\n","import { detectIsFunction, eventsStore, detectIsArray } from '@dark-engine/core';\r\n\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\ntype BrowserEventConstructor = (type: string, event: Event) => void;\r\n\r\nclass SyntheticEvent<E extends Event, T = TagNativeElement> {\r\n  public type = '';\r\n  public sourceEvent: E = null;\r\n  public target: T = null;\r\n  private propagation = true;\r\n\r\n  constructor(options: Pick<SyntheticEvent<E, T>, 'sourceEvent' | 'target'>) {\r\n    this.type = options.sourceEvent.type;\r\n    this.sourceEvent = options.sourceEvent;\r\n    this.target = options.target;\r\n  }\r\n\r\n  public stopPropagation() {\r\n    this.propagation = false;\r\n    this.sourceEvent.stopPropagation();\r\n  }\r\n\r\n  public preventDefault() {\r\n    this.sourceEvent.preventDefault();\r\n  }\r\n\r\n  public getPropagation() {\r\n    return this.propagation;\r\n  }\r\n}\r\n\r\nfunction delegateEvent(\r\n  target: Element,\r\n  eventName: string,\r\n  handler: (e: Event) => void | [fn: () => void, ...args: Array<any>],\r\n) {\r\n  const eventsMap = eventsStore.get();\r\n  const handlerMap = eventsMap.get(eventName);\r\n  const handler$ = detectIsArray(handler) ? (e: Event) => handler[0](...handler.slice(1), e) : handler;\r\n\r\n  if (!handlerMap) {\r\n    const rootHandler = (event: Event) => {\r\n      const fireEvent = eventsMap.get(eventName).get(event.target);\r\n      const target = event.target as TagNativeElement;\r\n      let synthetic: SyntheticEvent<Event> = null;\r\n\r\n      if (detectIsFunction(fireEvent)) {\r\n        synthetic = new SyntheticEvent({ sourceEvent: event, target });\r\n        fireEvent(synthetic);\r\n      }\r\n\r\n      if (synthetic ? synthetic.getPropagation() : target.parentElement) {\r\n        target.parentElement.dispatchEvent(new (event.constructor as BrowserEventConstructor)(event.type, event));\r\n      }\r\n    };\r\n\r\n    eventsMap.set(eventName, new WeakMap([[target, handler$]]));\r\n    document.addEventListener(eventName, rootHandler, true);\r\n    eventsStore.addUnsubscriber(() => document.removeEventListener(eventName, rootHandler, true));\r\n  } else {\r\n    handlerMap.set(target, handler$);\r\n  }\r\n}\r\n\r\nconst detectIsEvent = (attrName: string) => attrName.startsWith('on');\r\n\r\nconst getEventName = (attrName: string) => attrName.slice(2, attrName.length).toLowerCase();\r\n\r\nexport { SyntheticEvent, delegateEvent, detectIsEvent, getEventName };\r\n","import {\r\n  type Fiber,\r\n  type VirtualNode,\r\n  type TagVirtualNode,\r\n  type TextVirtualNode,\r\n  type CommentVirtualNode,\r\n  type PlainVirtualNode,\r\n  type Ref,\r\n  ATTR_KEY,\r\n  ATTR_REF,\r\n  ATTR_FLAG,\r\n  EffectTag,\r\n  detectIsUndefined,\r\n  detectIsBoolean,\r\n  keyBy,\r\n  NodeType,\r\n  detectIsTagVirtualNode,\r\n  detectIsTextVirtualNode,\r\n  detectIsPlainVirtualNode,\r\n  getFiberWithElement,\r\n  collectElements,\r\n  walkFiber,\r\n  isHydrateZone,\r\n  applyRef as applyRef$,\r\n} from '@dark-engine/core';\r\n\r\nimport { detectIsPortal } from '../portal';\r\nimport { delegateEvent, detectIsEvent, getEventName } from '../events';\r\nimport { SVG_TAG_NAMES, VOID_TAG_NAMES } from '../constants';\r\nimport type {\r\n  NativeElement,\r\n  TagNativeElement,\r\n  TextNativeElement,\r\n  CommentNativeElement,\r\n  NativeNode,\r\n  AttributeValue,\r\n} from '../native-element';\r\n\r\nconst attrBlackListMap = {\r\n  [ATTR_KEY]: true,\r\n  [ATTR_REF]: true,\r\n  [ATTR_FLAG]: true,\r\n};\r\nconst patchPropsBlackListMap = {\r\n  transform: true,\r\n  fill: true,\r\n};\r\n\r\nlet moves: Array<() => void> = [];\r\nlet trackUpdate: (nativeElement: NativeElement) => void = null;\r\nconst svgTagNamesMap = keyBy(SVG_TAG_NAMES.split(','), x => x);\r\nconst voidTagNamesMap = keyBy(VOID_TAG_NAMES.split(','), x => x);\r\n\r\nconst createNativeElementMap = {\r\n  [NodeType.TAG]: (vNode: VirtualNode): TagNativeElement => {\r\n    const tagNode = vNode as TagVirtualNode;\r\n\r\n    return detectIsSvgElement(tagNode.name)\r\n      ? document.createElementNS('http://www.w3.org/2000/svg', tagNode.name)\r\n      : document.createElement(tagNode.name);\r\n  },\r\n  [NodeType.TEXT]: (vNode: VirtualNode): TextNativeElement => {\r\n    return document.createTextNode((vNode as TextVirtualNode).value);\r\n  },\r\n  [NodeType.COMMENT]: (vNode: VirtualNode): CommentNativeElement => {\r\n    return document.createComment((vNode as CommentVirtualNode).value);\r\n  },\r\n};\r\n\r\nfunction createNativeElement(vNode: VirtualNode): NativeElement {\r\n  return createNativeElementMap[vNode.type](vNode);\r\n}\r\n\r\nfunction detectIsSvgElement(tagName: string) {\r\n  return Boolean(svgTagNamesMap[tagName]);\r\n}\r\n\r\nfunction detectIsVoidElement(tagName: string) {\r\n  return Boolean(voidTagNamesMap[tagName]);\r\n}\r\n\r\nfunction applyRef(ref: Ref<NativeElement>, element: NativeElement) {\r\n  applyRef$(ref, element);\r\n}\r\n\r\nfunction addAttributes(element: NativeElement, vNode: TagVirtualNode) {\r\n  if (!vNode.attrs) return;\r\n  const attrNames = Object.keys(vNode.attrs);\r\n  const tagElement = element as TagNativeElement;\r\n\r\n  for (const attrName of attrNames) {\r\n    const attrValue = vNode.attrs[attrName];\r\n\r\n    if (attrName === ATTR_REF) {\r\n      applyRef(attrValue, element);\r\n      continue;\r\n    }\r\n\r\n    if (detectIsEvent(attrName)) {\r\n      delegateEvent(tagElement, getEventName(attrName), attrValue);\r\n    } else if (!detectIsUndefined(attrValue) && !attrBlackListMap[attrName]) {\r\n      const stop = patchProperties({\r\n        tagName: vNode.name,\r\n        element: tagElement,\r\n        attrValue,\r\n        attrName,\r\n      });\r\n\r\n      !stop && tagElement.setAttribute(attrName, attrValue);\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateAttributes(element: NativeElement, vNode: TagVirtualNode, nextVNode: TagVirtualNode) {\r\n  if (!nextVNode.attrs) return;\r\n  const attrNames = Object.keys(nextVNode.attrs);\r\n  const tagElement = element as TagNativeElement;\r\n\r\n  for (const attrName of attrNames) {\r\n    const prevAttrValue = vNode.attrs[attrName];\r\n    const nextAttrValue = nextVNode.attrs[attrName];\r\n\r\n    if (attrName === ATTR_REF) {\r\n      applyRef(prevAttrValue, element);\r\n      continue;\r\n    }\r\n\r\n    if (!detectIsUndefined(nextAttrValue)) {\r\n      if (detectIsEvent(attrName)) {\r\n        prevAttrValue !== nextAttrValue && delegateEvent(tagElement, getEventName(attrName), nextAttrValue);\r\n      } else if (!attrBlackListMap[attrName] && prevAttrValue !== nextAttrValue) {\r\n        const stop = !patchPropsBlackListMap[attrName]\r\n          ? patchProperties({\r\n              tagName: nextVNode.name,\r\n              element: tagElement,\r\n              attrValue: nextAttrValue,\r\n              attrName,\r\n            })\r\n          : false;\r\n\r\n        !stop && tagElement.setAttribute(attrName, nextAttrValue);\r\n      }\r\n    } else {\r\n      tagElement.removeAttribute(attrName);\r\n    }\r\n  }\r\n}\r\n\r\ntype PatchPropertiesOptions = {\r\n  tagName: string;\r\n  element: TagNativeElement;\r\n  attrName: string;\r\n  attrValue: AttributeValue;\r\n};\r\n\r\nfunction patchProperties(options: PatchPropertiesOptions): boolean {\r\n  const { tagName, element, attrName, attrValue } = options;\r\n  const fn = patchPropertiesSpecialCasesMap[tagName];\r\n  let stop = fn ? fn(element, attrName, attrValue) : false;\r\n\r\n  if (canSetProperty(Object.getPrototypeOf(element), attrName)) {\r\n    element[attrName] = attrValue;\r\n  }\r\n\r\n  if (!stop && detectIsBoolean(attrValue)) {\r\n    stop = !attrName.includes('-');\r\n  }\r\n\r\n  return stop;\r\n}\r\n\r\nfunction canSetProperty(prototype: TagNativeElement, key: string) {\r\n  return prototype.hasOwnProperty(key) && Boolean(Object.getOwnPropertyDescriptor(prototype, key)?.set);\r\n}\r\n\r\nconst patchPropertiesSpecialCasesMap: Record<\r\n  string,\r\n  (element: NativeElement, attrName: string, attrValue: AttributeValue) => boolean\r\n> = {\r\n  input: (element: HTMLInputElement, attrName: string, attrValue: AttributeValue) => {\r\n    if (attrName === 'value' && detectIsBoolean(attrValue)) {\r\n      element.checked = attrValue;\r\n    } else if (attrName === 'autoFocus') {\r\n      element.autofocus = Boolean(attrValue);\r\n    }\r\n\r\n    return false;\r\n  },\r\n  textarea: (element: HTMLTextAreaElement, attrName: string, attrValue: AttributeValue) => {\r\n    if (attrName === 'value') {\r\n      element.innerHTML = String(attrValue);\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  },\r\n};\r\n\r\nfunction commitCreation(fiber: Fiber<NativeElement>) {\r\n  const parentFiber = getFiberWithElement<NativeElement, TagNativeElement>(fiber.parent);\r\n  const parentElement = parentFiber.element;\r\n  const childNodes = parentElement.childNodes;\r\n\r\n  if (isHydrateZone.get()) {\r\n    const nativeElement = childNodes[fiber.eidx] as NativeElement;\r\n\r\n    if (\r\n      detectIsTextVirtualNode(fiber.inst) &&\r\n      nativeElement instanceof Text &&\r\n      fiber.inst.value.length !== nativeElement.length\r\n    ) {\r\n      nativeElement.splitText(fiber.inst.value.length);\r\n    }\r\n\r\n    fiber.element = nativeElement;\r\n  } else {\r\n    if (!fiber.shadow) {\r\n      if (childNodes.length === 0 || fiber.eidx > childNodes.length - 1) {\r\n        !detectIsVoidElement((parentFiber.inst as TagVirtualNode).name) &&\r\n          appendNativeElement(fiber.element, parentElement);\r\n      } else {\r\n        insertNativeElement(fiber.element, parentElement.childNodes[fiber.eidx], parentElement);\r\n      }\r\n    }\r\n  }\r\n\r\n  detectIsTagVirtualNode(fiber.inst) && addAttributes(fiber.element, fiber.inst);\r\n}\r\n\r\nfunction commitUpdate(fiber: Fiber<NativeElement>) {\r\n  const element = fiber.element;\r\n  const prevInstance = fiber.alt.inst as VirtualNode;\r\n  const nextInstance = fiber.inst as VirtualNode;\r\n\r\n  detectIsPlainVirtualNode(nextInstance)\r\n    ? (prevInstance as PlainVirtualNode).value !== nextInstance.value && (element.textContent = nextInstance.value)\r\n    : updateAttributes(element, prevInstance as TagVirtualNode, nextInstance as TagVirtualNode);\r\n}\r\n\r\nfunction commitDeletion(fiber: Fiber<NativeElement>) {\r\n  const parentFiber = getFiberWithElement<NativeElement, TagNativeElement>(fiber.parent);\r\n\r\n  if (fiber.flush) {\r\n    parentFiber.element.textContent && (parentFiber.element.textContent = '');\r\n    return;\r\n  }\r\n\r\n  walkFiber<NativeElement>(fiber, (nextFiber, isReturn, resetIsDeepWalking, stop) => {\r\n    if (nextFiber === fiber.next || nextFiber === fiber.parent) return stop();\r\n    if (!isReturn && nextFiber.element) {\r\n      !nextFiber.shadow &&\r\n        !detectIsPortal(nextFiber.inst) &&\r\n        removeNativeElement(nextFiber.element, parentFiber.element);\r\n\r\n      return resetIsDeepWalking();\r\n    }\r\n  });\r\n}\r\n\r\nfunction move(fiber: Fiber<NativeElement>) {\r\n  const sourceNodes = collectElements(fiber, x => x.element);\r\n  const sourceNode = sourceNodes[0];\r\n  const parentElement = sourceNode.parentElement;\r\n  const sourceFragment = new DocumentFragment();\r\n  const elementIdx = fiber.eidx;\r\n  let idx = 0;\r\n  const move = () => {\r\n    for (let i = 1; i < sourceNodes.length; i++) {\r\n      removeNativeElement(parentElement.childNodes[elementIdx + 1], parentElement);\r\n    }\r\n\r\n    replaceNativeElement(sourceFragment, parentElement.childNodes[elementIdx], parentElement);\r\n  };\r\n\r\n  for (const node of sourceNodes) {\r\n    insertNativeElement(document.createComment(`${elementIdx}:${idx}`), node, parentElement);\r\n    appendNativeElement(node, sourceFragment);\r\n    idx++;\r\n  }\r\n\r\n  moves.push(move);\r\n}\r\n\r\nconst commitMap: Record<EffectTag, (fiber: Fiber<NativeElement>) => void> = {\r\n  [EffectTag.C]: (fiber: Fiber<NativeElement>) => {\r\n    if (fiber.element === null || detectIsPortal(fiber.inst)) return;\r\n    trackUpdate && trackUpdate(fiber.element);\r\n    commitCreation(fiber);\r\n  },\r\n  [EffectTag.U]: (fiber: Fiber<NativeElement>) => {\r\n    fiber.move && (move(fiber), (fiber.move = false));\r\n    if (fiber.element === null || detectIsPortal(fiber.inst)) return;\r\n    trackUpdate && trackUpdate(fiber.element);\r\n    commitUpdate(fiber);\r\n  },\r\n  [EffectTag.D]: commitDeletion,\r\n  [EffectTag.S]: () => {},\r\n};\r\n\r\nfunction commit(fiber: Fiber<NativeElement>) {\r\n  commitMap[fiber.tag](fiber);\r\n}\r\n\r\nfunction finishCommit() {\r\n  moves.forEach(x => x());\r\n  moves = [];\r\n}\r\n\r\nfunction setTrackUpdate(fn: typeof trackUpdate) {\r\n  trackUpdate = fn;\r\n}\r\n\r\nconst appendNativeElement = (element: NativeNode, parent: NativeNode) => parent.appendChild(element);\r\n\r\nconst insertNativeElement = (element: NativeNode, sibling: NativeNode, parent: TagNativeElement) => {\r\n  parent.insertBefore(element, sibling);\r\n};\r\n\r\nconst insertNativeElementByIndex = (element: NativeNode, idx: number, parent: TagNativeElement) => {\r\n  parent.insertBefore(element, parent.childNodes[idx]);\r\n};\r\n\r\nconst replaceNativeElement = (element: NativeNode, candidate: NativeNode, parent: TagNativeElement) => {\r\n  parent.replaceChild(element, candidate);\r\n};\r\n\r\nconst removeNativeElement = (element: NativeNode, parent: TagNativeElement) => parent.removeChild(element);\r\n\r\nexport { createNativeElement, commit, finishCommit, setTrackUpdate, insertNativeElementByIndex };\r\n","export const VERSION = '0.23.0';\r\nexport const SVG_TAG_NAMES =\r\n  'svg,animate,animateMotion,animateTransform,circle,clipPath,defs,desc,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,image,line,linearGradient,marker,mask,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,stop,switch,symbol,text,textPath,tspan,use,view';\r\nexport const VOID_TAG_NAMES = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\n","import {\r\n  type ScheduleCallbackOptions,\r\n  type WorkLoop,\r\n  getTime,\r\n  workLoop,\r\n  TaskPriority,\r\n  detectIsBusy,\r\n} from '@dark-engine/core';\r\n\r\ntype QueueByPriority = {\r\n  animations: Array<Task>;\r\n  hight: Array<Task>;\r\n  normal: Array<Task>;\r\n  low1: Array<Task>;\r\n  low2: Array<Task>;\r\n};\r\n\r\nconst queueByPriority: QueueByPriority = {\r\n  animations: [],\r\n  hight: [],\r\n  normal: [],\r\n  low1: [],\r\n  low2: [],\r\n};\r\nconst YIELD_INTERVAL = 4;\r\nconst MAX_LOW_PRIORITY_TASKS_LIMIT = 100000;\r\nlet scheduledCallback: WorkLoop = null;\r\nlet deadline = 0;\r\nlet isMessageLoopRunning = false;\r\n\r\nclass Task {\r\n  public static nextTaskId = 0;\r\n  public id: number;\r\n  public time: number;\r\n  public timeoutMs: number;\r\n  public priority: TaskPriority;\r\n  public forceSync: boolean;\r\n  public callback: () => void;\r\n\r\n  constructor(options: Omit<Task, 'id'>) {\r\n    this.id = ++Task.nextTaskId;\r\n    this.time = options.time;\r\n    this.timeoutMs = options.timeoutMs;\r\n    this.priority = options.priority;\r\n    this.forceSync = options.forceSync;\r\n    this.callback = options.callback;\r\n  }\r\n}\r\n\r\nconst shouldYield = () => getTime() >= deadline;\r\n\r\nfunction scheduleCallback(callback: () => void, options?: ScheduleCallbackOptions) {\r\n  const { priority = TaskPriority.NORMAL, timeoutMs = 0, forceSync = false } = options || {};\r\n  const task = new Task({ time: getTime(), timeoutMs, priority, forceSync, callback });\r\n  const map: Record<TaskPriority, () => void> = {\r\n    [TaskPriority.ANIMATION]: () => queueByPriority.animations.push(task),\r\n    [TaskPriority.HIGH]: () => queueByPriority.hight.push(task),\r\n    [TaskPriority.NORMAL]: () => queueByPriority.normal.push(task),\r\n    [TaskPriority.LOW]: () => (task.timeoutMs > 0 ? queueByPriority.low2.push(task) : queueByPriority.low1.push(task)),\r\n  };\r\n\r\n  map[task.priority]();\r\n  executeTasks();\r\n}\r\n\r\nfunction pick(queue: Array<Task>) {\r\n  if (!queue.length) return false;\r\n  const task = queue.shift();\r\n  const isAnimation = task.priority === TaskPriority.ANIMATION;\r\n\r\n  task.callback();\r\n\r\n  if (task.forceSync || isAnimation) {\r\n    requestCallbackSync(workLoop);\r\n  } else {\r\n    requestCallback(workLoop);\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction executeTasks() {\r\n  const isBusy = detectIsBusy();\r\n\r\n  if (!isBusy && !isMessageLoopRunning) {\r\n    checkOverdueTasks() ||\r\n      gc() ||\r\n      (queueByPriority.animations.length > 0 && pick(queueByPriority.animations)) ||\r\n      (queueByPriority.hight.length > 0 && pick(queueByPriority.hight)) ||\r\n      (queueByPriority.normal.length > 0 && pick(queueByPriority.normal)) ||\r\n      (queueByPriority.low1.length > 0 && requestIdleCallback(() => pick(queueByPriority.low1))) ||\r\n      (queueByPriority.low2.length > 0 && requestIdleCallback(() => pick(queueByPriority.low2)));\r\n  }\r\n}\r\n\r\nfunction gc() {\r\n  if (queueByPriority.low1.length > MAX_LOW_PRIORITY_TASKS_LIMIT) {\r\n    queueByPriority.low1 = [];\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction checkOverdueTasks() {\r\n  const [task] = queueByPriority.low2;\r\n\r\n  if (task && getTime() - task.time > task.timeoutMs) {\r\n    pick(queueByPriority.low2);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction performWorkUntilDeadline() {\r\n  if (scheduledCallback) {\r\n    deadline = getTime() + YIELD_INTERVAL;\r\n\r\n    try {\r\n      const hasMoreWork = scheduledCallback(true);\r\n\r\n      if (!hasMoreWork) {\r\n        isMessageLoopRunning = false;\r\n        scheduledCallback = null;\r\n        executeTasks();\r\n      } else {\r\n        port.postMessage(null);\r\n      }\r\n    } catch (error) {\r\n      port.postMessage(null);\r\n      throw error;\r\n    }\r\n  } else {\r\n    isMessageLoopRunning = false;\r\n  }\r\n}\r\n\r\nfunction requestCallback(callback: WorkLoop) {\r\n  if (process.env.NODE_ENV === 'test') {\r\n    return requestCallbackSync(callback);\r\n  }\r\n\r\n  scheduledCallback = callback;\r\n\r\n  if (!isMessageLoopRunning) {\r\n    isMessageLoopRunning = true;\r\n    port.postMessage(null);\r\n  }\r\n}\r\n\r\nfunction requestCallbackSync(callback: WorkLoop) {\r\n  callback(false);\r\n  executeTasks();\r\n}\r\n\r\nlet channel: MessageChannel = null;\r\nlet port: MessagePort = null;\r\n\r\nfunction setup() {\r\n  if (process.env.NODE_ENV === 'test') {\r\n    return;\r\n  }\r\n\r\n  channel = new MessageChannel();\r\n  port = channel.port2;\r\n\r\n  channel.port1.onmessage = performWorkUntilDeadline;\r\n}\r\n\r\nsetup();\r\n\r\nexport { shouldYield, scheduleCallback };\r\n","import {\r\n  type DarkElement,\r\n  ROOT,\r\n  Fiber,\r\n  EffectTag,\r\n  platform,\r\n  flatten,\r\n  detectIsUndefined,\r\n  TagVirtualNode,\r\n  rootStore,\r\n  wipRootStore,\r\n  currentRootStore,\r\n  nextUnitOfWorkStore,\r\n  mountStore,\r\n  TaskPriority,\r\n  createReplacer,\r\n  isInsertionEffectsZone,\r\n  isLayoutEffectsZone,\r\n  isHydrateZone,\r\n} from '@dark-engine/core';\r\n\r\nimport type { TagNativeElement } from '../native-element';\r\nimport { createNativeElement, insertNativeElementByIndex, commit, finishCommit } from '../dom';\r\nimport { detectIsPortal, unmountPortal } from '../portal/utils';\r\nimport { scheduleCallback, shouldYield } from '../scheduler';\r\n\r\nlet isInjected = false;\r\nconst roots = new Map<Element, number>();\r\n\r\nfunction inject() {\r\n  platform.createElement = createNativeElement as typeof platform.createElement;\r\n  platform.insertElement = insertNativeElementByIndex as typeof platform.insertElement;\r\n  platform.raf = requestAnimationFrame.bind(this);\r\n  platform.caf = cancelAnimationFrame.bind(this);\r\n  platform.schedule = scheduleCallback;\r\n  platform.shouldYield = shouldYield;\r\n  platform.commit = commit;\r\n  platform.finishCommit = finishCommit;\r\n  platform.detectIsDynamic = () => true;\r\n  platform.detectIsPortal = detectIsPortal;\r\n  platform.unmountPortal = unmountPortal;\r\n  platform.chunk = () => {};\r\n  isInjected = true;\r\n}\r\n\r\nfunction render(element: DarkElement, container: TagNativeElement, hydrate = false) {\r\n  !isInjected && inject();\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (!(container instanceof Element)) {\r\n      throw new Error(`[Dark]: render receives only Element as container!`);\r\n    }\r\n  }\r\n\r\n  const isMounted = !detectIsUndefined(roots.get(container));\r\n  let rootId: number = null;\r\n\r\n  if (!isMounted) {\r\n    rootId = roots.size;\r\n\r\n    roots.set(container, rootId);\r\n\r\n    if (!hydrate) {\r\n      container.innerHTML = '';\r\n    }\r\n  } else {\r\n    rootId = roots.get(container);\r\n  }\r\n\r\n  // insertion effect can't schedule renders\r\n  if (isInsertionEffectsZone.get(rootId)) return;\r\n\r\n  const callback = () => {\r\n    rootStore.set(rootId); // important order!\r\n    const currentRoot = currentRootStore.get();\r\n    const isUpdate = Boolean(currentRoot);\r\n    const fiber = new Fiber().mutate({\r\n      element: container,\r\n      inst: new TagVirtualNode(ROOT, {}, flatten([element || createReplacer()]) as TagVirtualNode['children']),\r\n      alt: currentRoot,\r\n      tag: isUpdate ? EffectTag.U : EffectTag.C,\r\n    });\r\n\r\n    mountStore.reset();\r\n    wipRootStore.set(fiber);\r\n    isHydrateZone.set(hydrate);\r\n    nextUnitOfWorkStore.set(fiber);\r\n  };\r\n\r\n  platform.schedule(callback, {\r\n    priority: TaskPriority.NORMAL,\r\n    forceSync: isLayoutEffectsZone.get(),\r\n  });\r\n}\r\n\r\nexport { render, roots };\r\n","import { detectIsComponent } from '../component';\r\n\r\nconst $$shadow = Symbol('shadow');\r\n\r\nconst detectIsShadow = (instance: unknown) => detectIsComponent(instance) && instance.token === $$shadow;\r\n\r\nexport { $$shadow, detectIsShadow };\r\n","import type { DarkElement } from '../shared';\r\nimport { component } from '../component';\r\nimport { useLayoutEffect } from '../use-layout-effect';\r\nimport { currentFiberStore, isHydrateZone } from '../scope';\r\nimport { collectElements, getFiberWithElement } from '../walk';\r\nimport { platform, detectIsServer } from '../platform';\r\nimport { $$shadow } from './utils';\r\n\r\ntype ShadowProps = {\r\n  isVisible: boolean;\r\n  slot: DarkElement;\r\n};\r\n\r\nconst Shadow = component<ShadowProps>(\r\n  ({ isVisible, slot }) => {\r\n    const isEnabled = !detectIsServer() && !isHydrateZone.get();\r\n    const fiber = currentFiberStore.get();\r\n\r\n    if (isEnabled) {\r\n      if (isVisible) {\r\n        delete fiber.shadow;\r\n      } else {\r\n        fiber.shadow = true;\r\n      }\r\n    }\r\n\r\n    useLayoutEffect(() => {\r\n      if (!isEnabled || !isVisible) return;\r\n      const fiber$ = getFiberWithElement(fiber);\r\n      const fibers = collectElements(fiber, x => x);\r\n\r\n      for (const fiber of fibers) {\r\n        platform.insertElement(fiber.element, fiber.eidx, fiber$.element);\r\n      }\r\n    }, [isVisible]);\r\n\r\n    return slot || null;\r\n  },\r\n  { token: $$shadow },\r\n);\r\n\r\nexport { Shadow };\r\n","import type { DarkElement, SlotProps } from '../shared';\r\nimport { component } from '../component';\r\nimport { createContext } from '../context';\r\nimport { useMemo } from '../use-memo';\r\nimport { useState } from '../use-state';\r\nimport { useLayoutEffect } from '../use-layout-effect';\r\nimport { emitter } from '../emitter';\r\nimport { Fragment } from '../fragment';\r\nimport { isHydrateZone } from '../scope';\r\nimport { detectIsServer } from '../platform';\r\nimport { Shadow } from '../shadow';\r\n\r\ntype SuspenseProps = {\r\n  fallback: DarkElement;\r\n} & Required<SlotProps>;\r\n\r\ntype SuspenseContextValue = {\r\n  isLoaded: boolean;\r\n  fallback: DarkElement;\r\n  reg: () => void;\r\n  unreg: () => void;\r\n};\r\n\r\nconst SuspenseContext = createContext<SuspenseContextValue>({\r\n  isLoaded: false,\r\n  fallback: null,\r\n  reg: () => {},\r\n  unreg: () => {},\r\n});\r\n\r\nconst Suspense = component<SuspenseProps>(({ fallback, slot }) => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (!fallback) {\r\n      throw new Error(`[Dark]: Suspense fallback not found!`);\r\n    }\r\n  }\r\n\r\n  const [isLoaded, setIsLoaded] = useState(() => detectIsServer() || isHydrateZone.get(), { forceSync: true });\r\n  const scope = useMemo(() => ({ size: 0 }), []);\r\n  const value = useMemo<SuspenseContextValue>(\r\n    () => ({ isLoaded, fallback, reg: () => scope.size++, unreg: () => scope.size-- }),\r\n    [],\r\n  );\r\n  value.isLoaded = isLoaded;\r\n  value.fallback = fallback;\r\n\r\n  useLayoutEffect(() => {\r\n    const off = emitter.on('finish', () => !isLoaded && scope.size === 0 && setIsLoaded(true));\r\n\r\n    return off;\r\n  }, []);\r\n\r\n  const content = isLoaded\r\n    ? [Shadow({ key: CONTENT, isVisible: true, slot })]\r\n    : [Shadow({ key: CONTENT, isVisible: false, slot }), Fragment({ key: FALLBACK, slot: fallback })];\r\n\r\n  return SuspenseContext.Provider({ value, slot: content });\r\n});\r\n\r\nconst CONTENT = 1;\r\nconst FALLBACK = 2;\r\n\r\nexport { SuspenseContext, Suspense };\r\n","import { type ComponentFactory, component } from '../component';\r\nimport { detectIsFunction, detectIsUndefined } from '../helpers';\r\nimport { useContext } from '../context';\r\nimport { forwardRef } from '../ref';\r\nimport { SuspenseContext } from '../suspense';\r\nimport { useUpdate } from '../use-update';\r\nimport { isHydrateZone } from '../scope';\r\nimport { $$lazy, $$loaded } from './utils';\r\n\r\nconst factoriesMap: Map<Function, ComponentFactory> = new Map();\r\n\r\nfunction lazy<P, R = unknown>(module: () => Promise<LazyModule<P>>, done?: () => void) {\r\n  return forwardRef(\r\n    component<P, R>(\r\n      function type(props, ref) {\r\n        const { isLoaded, fallback, reg, unreg } = useContext(SuspenseContext);\r\n        const update = useUpdate({ forceSync: true });\r\n        const factory = factoriesMap.get(module);\r\n\r\n        if (detectIsUndefined(factory)) {\r\n          reg();\r\n          factoriesMap.set(module, null);\r\n          fetchModule(module).then(component => {\r\n            unreg();\r\n            type[$$loaded] = true;\r\n            factoriesMap.set(module, component);\r\n            !isHydrateZone.get() && update();\r\n            detectIsFunction(done) && done();\r\n          });\r\n        }\r\n\r\n        return factory ? factory(props, ref) : isLoaded ? fallback : null;\r\n      },\r\n      { token: $$lazy },\r\n    ),\r\n  );\r\n}\r\n\r\nfunction fetchModule(module: () => Promise<LazyModule>) {\r\n  return new Promise<ComponentFactory>(resolve => {\r\n    module().then(module => {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (!module.default) {\r\n          throw new Error('[Dark]: Lazy loaded component should be exported as default!');\r\n        }\r\n      }\r\n\r\n      resolve(module.default);\r\n    });\r\n  });\r\n}\r\n\r\nexport type LazyModule<P = unknown> = {\r\n  default: ComponentFactory<P>;\r\n};\r\n\r\nexport { lazy, fetchModule };\r\n","import { detectIsFalsy, type SubscriberWithValue } from '@dark-engine/core';\r\n\r\nimport { normalaizePathname, parseURL } from '../utils';\r\n\r\nconst browserHistory = globalThis.history;\r\nclass RouterHistory {\r\n  private stack: Array<string> = [];\r\n  private cursor = -1;\r\n  private subscribers: Set<SubscriberWithValue<string>> = new Set();\r\n  private fromHistory = false;\r\n  public dispose: () => void = null;\r\n\r\n  constructor(url: string) {\r\n    if (detectIsFalsy(url)) {\r\n      throw new Error('[web-router]: RouterHistory must have initial url!');\r\n    }\r\n\r\n    const { pathname, search } = parseURL(url);\r\n    const spathname = pathname + search;\r\n\r\n    this.stack.push(spathname);\r\n    this.cursor = this.stack.length - 1;\r\n\r\n    if (browserHistory) {\r\n      const state = this.getState();\r\n\r\n      if (!state) {\r\n        browserHistory.replaceState(this.createStateBox(), '');\r\n      } else {\r\n        this.stack = state.stack;\r\n        this.cursor = state.cursor;\r\n      }\r\n\r\n      const handleEvent = () => {\r\n        const state = this.getState();\r\n\r\n        if (state) {\r\n          this.stack = state.stack;\r\n          this.cursor = state.cursor;\r\n        }\r\n\r\n        if (!this.fromHistory) {\r\n          this.mapSubscribers();\r\n        }\r\n\r\n        this.fromHistory = false;\r\n      };\r\n\r\n      window.addEventListener('popstate', handleEvent);\r\n\r\n      this.dispose = () => {\r\n        window.removeEventListener('popstate', handleEvent);\r\n        this.subscribers.clear();\r\n        this.stack = [];\r\n        this.cursor = -1;\r\n      };\r\n    }\r\n  }\r\n\r\n  private mapSubscribers() {\r\n    for (const subscriber of this.subscribers) {\r\n      subscriber(this.getValue());\r\n    }\r\n  }\r\n\r\n  private getValue = () => {\r\n    return normalaizePathname(this.stack[this.cursor]);\r\n  };\r\n\r\n  private getState(): State {\r\n    return (browserHistory.state && browserHistory.state[STATE_KEY]) || null;\r\n  }\r\n\r\n  private createStateBox(): StateBox {\r\n    const state = browserHistory.state || {};\r\n\r\n    return { ...state, [STATE_KEY]: { cursor: this.cursor, stack: this.stack } };\r\n  }\r\n\r\n  private syncHistory(action: HistoryAction, spathname: string) {\r\n    if (!browserHistory) return;\r\n    const stateBox = this.createStateBox();\r\n    const spathname$ = normalaizePathname(spathname);\r\n\r\n    switch (action) {\r\n      case HistoryAction.PUSH:\r\n        return browserHistory.pushState(stateBox, '', spathname$);\r\n      case HistoryAction.REPLACE:\r\n        return browserHistory.replaceState(stateBox, '', spathname$);\r\n    }\r\n  }\r\n\r\n  public subscribe = (subscriber: SubscriberWithValue<string>) => {\r\n    this.subscribers.add(subscriber);\r\n\r\n    return () => this.subscribers.delete(subscriber);\r\n  };\r\n\r\n  public push(spathname: string) {\r\n    this.stack.splice(this.cursor + 1, this.stack.length, spathname);\r\n    this.cursor = this.stack.length - 1;\r\n    this.syncHistory(HistoryAction.PUSH, spathname);\r\n    this.mapSubscribers();\r\n  }\r\n\r\n  public replace(spathname: string) {\r\n    this.stack[this.stack.length - 1] = spathname;\r\n    this.syncHistory(HistoryAction.REPLACE, spathname);\r\n    this.mapSubscribers();\r\n  }\r\n\r\n  public forward() {\r\n    this.go(1);\r\n  }\r\n\r\n  public back() {\r\n    this.go(-1);\r\n  }\r\n\r\n  public go(delta: number) {\r\n    this.fromHistory = true;\r\n    this.cursor += delta;\r\n\r\n    if (this.cursor > this.stack.length - 1) {\r\n      this.cursor = this.stack.length - 1;\r\n    } else if (this.cursor < 0) {\r\n      this.cursor = 0;\r\n    }\r\n\r\n    browserHistory?.go(delta);\r\n    this.mapSubscribers();\r\n  }\r\n}\r\n\r\nenum HistoryAction {\r\n  PUSH = 'PUSH',\r\n  REPLACE = 'REPLACE',\r\n}\r\n\r\ntype StateBox = {\r\n  [STATE_KEY]: State;\r\n};\r\n\r\ntype State = {\r\n  cursor: number;\r\n  stack: Array<string>;\r\n};\r\n\r\nconst STATE_KEY = 'web-router';\r\n\r\nconst createRouterHistory = (url: string) => new RouterHistory(url);\r\n\r\nexport { RouterHistory, createRouterHistory };\r\n","import { detectIsFalsy } from '@dark-engine/core';\r\n\r\nimport { parseURL } from '../utils';\r\n\r\nclass RouterLocation {\r\n  public url: string;\r\n  public protocol: string;\r\n  public host: string;\r\n  public pathname: string;\r\n  public hash: string;\r\n  public search: string;\r\n  public key: string;\r\n\r\n  constructor(url: string) {\r\n    if (detectIsFalsy(url)) {\r\n      throw new Error('[web-router]: RouterLocation must have initial url!');\r\n    }\r\n\r\n    const { protocol, host, pathname, hash, search } = parseURL(url);\r\n\r\n    this.url = url;\r\n    this.protocol = protocol;\r\n    this.host = host;\r\n    this.pathname = pathname;\r\n    this.hash = hash;\r\n    this.search = search;\r\n    this.key = createKey(pathname);\r\n    Object.freeze(this);\r\n  }\r\n}\r\n\r\nfunction createKey(pathname: string): string {\r\n  return pathname\r\n    .split('')\r\n    .map(x => x.charCodeAt(0))\r\n    .reduce((acc, x) => ((acc += x), acc), 200000)\r\n    .toString(32);\r\n}\r\n\r\nconst createRouterLocation = (url: string) => new RouterLocation(url);\r\n\r\nexport { RouterLocation, createRouterLocation };\r\n","import {\r\n  type DarkElement,\r\n  type MutableRef,\r\n  h,\r\n  component,\r\n  useMemo,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useState,\r\n  forwardRef,\r\n  useImperativeHandle,\r\n} from '@dark-engine/core';\r\n\r\nimport { SLASH, PROTOCOL_MARK } from '../constants';\r\nimport { normalaizePathname } from '../utils';\r\nimport { createRouterHistory } from '../history';\r\nimport { type RouterLocation, createRouterLocation } from '../location';\r\nimport { type Routes, createRoutes, resolveRoute, createPathname } from '../create-routes';\r\nimport {\r\n  type RouterHistoryContextValue,\r\n  type ActiveRouteContextValue,\r\n  RouterHistoryContext,\r\n  ActiveRouteContext,\r\n  useActiveRouteContext,\r\n} from '../context';\r\n\r\nexport type RouterProps = {\r\n  url?: string; // for server-side rendering\r\n  baseURL?: string;\r\n  routes: Routes;\r\n  slot: (slot: DarkElement) => DarkElement;\r\n};\r\n\r\nexport type RouterRef = {\r\n  navigateTo: (pathname: string) => void;\r\n  location: RouterLocation;\r\n};\r\n\r\nconst Router = forwardRef<RouterProps, RouterRef>(\r\n  component(\r\n    ({ url, baseURL = SLASH, routes: sourceRoutes, slot }, ref) => {\r\n      if (useActiveRouteContext()) {\r\n        throw new Error('[web-router]: Parent active route context detected!');\r\n      }\r\n      const sourceURL = url || window.location.href;\r\n      const [location, setLocation] = useState(() => createRouterLocation(sourceURL));\r\n      const history = useMemo(() => createRouterHistory(sourceURL), []);\r\n      const routes = useMemo(() => createRoutes(sourceRoutes, normalaizePathname(baseURL)), []);\r\n      const { protocol, host, pathname, search, hash } = location;\r\n      const { activeRoute, slot: slot$, params } = resolveRoute(pathname, routes);\r\n      const scope = useMemo(() => ({ location }), []);\r\n      const historyContext = useMemo<RouterHistoryContextValue>(() => ({ history }), []);\r\n      const routerContext = useMemo<ActiveRouteContextValue>(\r\n        () => ({ location, activeRoute, params }),\r\n        [pathname, search, hash],\r\n      );\r\n\r\n      scope.location = location;\r\n\r\n      useLayoutEffect(() => {\r\n        if (sourceURL !== scope.location.url) {\r\n          setLocation(createRouterLocation(sourceURL));\r\n        }\r\n      }, [sourceURL]);\r\n\r\n      useLayoutEffect(() => {\r\n        const unsubscribe = history.subscribe(spathname => {\r\n          const url = `${protocol}${PROTOCOL_MARK}${host}${spathname}`;\r\n\r\n          setLocation(createRouterLocation(url));\r\n        });\r\n\r\n        return () => {\r\n          unsubscribe();\r\n          history.dispose();\r\n        };\r\n      }, []);\r\n\r\n      useEffect(() => {\r\n        if (!activeRoute) return;\r\n        const spathname = pathname + search + hash;\r\n        const newSpathname = createPathname(pathname, activeRoute.getPath()) + search + hash;\r\n\r\n        if (spathname !== newSpathname) {\r\n          history.replace(newSpathname);\r\n        }\r\n      }, [pathname, search, hash]);\r\n\r\n      useImperativeHandle(ref as MutableRef<RouterRef>, () => ({\r\n        navigateTo: (pathname: string) => history.push(pathname),\r\n        location,\r\n      }));\r\n\r\n      return (\r\n        <RouterHistoryContext.Provider value={historyContext}>\r\n          <ActiveRouteContext.Provider value={routerContext}>{slot(slot$)}</ActiveRouteContext.Provider>\r\n        </RouterHistoryContext.Provider>\r\n      );\r\n    },\r\n    { displayName: 'Router' },\r\n  ),\r\n);\r\n\r\nexport { Router };\r\n","import { useMemo } from '../use-memo';\r\nimport { type Ref, applyRef } from '../ref';\r\n\r\nfunction useImperativeHandle<T>(ref: Ref<T>, createHandle: () => T, deps?: Array<any>) {\r\n  const current = useMemo(() => createHandle(), deps || [{}]);\r\n\r\n  ref && applyRef(ref, current);\r\n}\r\n\r\nexport { useImperativeHandle };\r\n","import { h, component } from '@dark-engine/core';\r\n\r\nconst Spinner = component(() => (\r\n  <div class='sp-layout'>\r\n    <div class='sp sp-hydrogen'></div>\r\n  </div>\r\n));\r\n\r\nexport { Spinner };\r\n","import { type DarkElement, h, component, Suspense, lazy } from '@dark-engine/core';\r\nimport { type Routes, Router, RouterLink } from '@dark-engine/web-router';\r\n\r\nimport { Spinner } from './spinner';\r\n\r\nconst Home = lazy(() => import('./home'));\r\nconst HomeChildA = lazy(() => import('./child-a'));\r\nconst HomeChildB = lazy(() => import('./child-b'));\r\nconst HomeChildC = lazy(() => import('./child-c'));\r\nconst About = lazy(() => import('./about'));\r\nconst Contacts = lazy(() => import('./contacts'));\r\n\r\nconst routes: Routes = [\r\n  {\r\n    path: 'home/:id',\r\n    component: Home,\r\n    children: [\r\n      {\r\n        path: 'a',\r\n        component: HomeChildA,\r\n      },\r\n      {\r\n        path: 'b',\r\n        component: HomeChildB,\r\n      },\r\n      {\r\n        path: 'c',\r\n        component: HomeChildC,\r\n      },\r\n      {\r\n        path: '',\r\n        redirectTo: 'a',\r\n      },\r\n      {\r\n        path: '**',\r\n        redirectTo: 'a',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    path: 'about',\r\n    component: About,\r\n  },\r\n  {\r\n    path: 'contacts',\r\n    component: Contacts,\r\n  },\r\n  {\r\n    path: '**',\r\n    redirectTo: 'home/:id',\r\n  },\r\n];\r\n\r\ntype ShellProps = {\r\n  slot: DarkElement;\r\n};\r\n\r\nconst Shell = component<ShellProps>(({ slot }) => {\r\n  return (\r\n    <Suspense fallback={<Spinner />}>\r\n      <header>\r\n        <RouterLink to='/home'>home</RouterLink>\r\n        <RouterLink to='/about'>about</RouterLink>\r\n        <RouterLink to='/contacts'>contacts</RouterLink>\r\n      </header>\r\n      <main>{slot}</main>\r\n    </Suspense>\r\n  );\r\n});\r\n\r\nexport type AppProps = {\r\n  url?: string;\r\n};\r\n\r\nconst App = component<AppProps>(({ url }) => {\r\n  return (\r\n    <Router routes={routes} url={url}>\r\n      {slot => <Shell>{slot}</Shell>}\r\n    </Router>\r\n  );\r\n});\r\n\r\nexport { App };\r\n","import { hydrateRoot, createRoot } from '@dark-engine/platform-browser';\r\n\r\nimport { App, type AppProps } from '../components/app';\r\n\r\nfunction bootstrap(hydrate = false, props: AppProps = {}) {\r\n  hydrate\r\n    ? hydrateRoot(document.getElementById('root'), App(props))\r\n    : createRoot(document.getElementById('root')).render(App(props));\r\n}\r\n\r\nexport { bootstrap };\r\n","import { type DarkElement } from '@dark-engine/core';\r\n\r\nimport { render } from '../render';\r\nimport { unmount } from '../create-root';\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\nfunction hydrateRoot(container: TagNativeElement, element: DarkElement) {\r\n  render(element, container, true);\r\n\r\n  return {\r\n    unmount: () => unmount(container),\r\n  };\r\n}\r\n\r\nexport { hydrateRoot };\r\n","import { type DarkElement, unmountRoot } from '@dark-engine/core';\r\n\r\nimport { render, roots } from '../render';\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\nfunction createRoot(container: TagNativeElement) {\r\n  return {\r\n    render: (element: DarkElement) => render(element, container),\r\n    unmount: () => unmount(container),\r\n  };\r\n}\r\n\r\nfunction unmount(container: TagNativeElement) {\r\n  const rootId = roots.get(container);\r\n\r\n  unmountRoot(rootId, () => {\r\n    roots.delete(container);\r\n    container.innerHTML = '';\r\n  });\r\n}\r\n\r\nexport { createRoot, unmount };\r\n","import { bootstrap } from './bootstrap/app.client';\r\n\r\nbootstrap(true);\r\n"],"names":["inProgress","$$component","Symbol","Component","constructor","type","token","props","ref","shouldUpdate","displayName","children","this","su","dn","component","options","keepRef","detectIsComponent","instance","getComponentKey","getComponentFlag","ROOT","REPLACER","INDEX_KEY","TYPE","ATTR_KEY","ATTR_REF","ATTR_FLAG","RESTART_TIMEOUT","TaskPriority","Flag","createContext","defaultValue","context","Provider","Consumer","value","slot","fiber","provider","providerValue","subscribers","Set","subscribe","subscriber","add","delete","Map","set","get","forEach","fn","createProvider","useContext","createConsumer","nextFiber","parent","getProvider","update","scope","hasProvider","Boolean","unsubscribe","Object","is","getChildren","map","x","toString","Array","isArray","createElement","tag","as","length","emitter","on","e","sub","emit","data","Fiber","hook","idx","id","cc","cec","eidx","element","inst","nextId","mutate","keys","key","markEFHost","efHost","markLEFHost","lefHost","markIEFHost","iefHost","markAHost","aHost","markPHost","pHost","incCEC","count","force","isUpdate","wipFiber","stop","setError","error","catch","static","EffectTag","$$fragment","Fragment","detectIsFragment","detectIsFunction","o","detectIsUndefined","detectIsNumber","detectIsString","detectIsObject","detectIsBoolean","detectIsArray","detectIsNull","detectIsEmpty","detectIsFalsy","getTime","Date","now","dummyFn","args","console","flatten","source","list","levelMap","level","item","push","keyBy","reduce","acc","detectIsDepsDifferent","deps","prevDeps","i","$$lazy","$$loaded","detectIsLazy","detectIsLoaded","$$memo","detectIsMemo","platform","Error","msg","insertElement","raf","caf","schedule","shouldYield","commit","finishCommit","detectIsDynamic","detectIsPortal","unmountPortal","chunk","detectIsServer","rootId","stores","Store","root","wip","unit","cur","events","off","candidates","deletions","mount","nav","deep","effects","lEffects","iEffects","isLEFZone","isIEFZone","uZone","bZone","hZone","sZone","isHot","rootStore","remove","getRootId","store","wipRootStore","currentRootStore","nextUnitOfWorkStore","currentFiberStore","eventsStore","addUnsubscriber","candidatesStore","reset","deletionsStore","has","mountStore","getIndex","toChild","toParent","toSibling","effectsStore","effect","layoutEffectsStore","insertionEffectsStore","isLayoutEffectsZone","isInsertionEffectsZone","isUpdateHookZone","isBatchZone","isHydrateZone","isStreamZone","unmountFiber","isReturn","resetIsDeepWalking","next","hasValues","values","cleanup","unmountRoot","onCompleted","useCallback","callback","$$useEffect","useEffect","hasEffects","dropEffects","createEffect","runEffect","undefined","some","$$useInsertionEffect","useInsertionEffect","hasInsertionEffects","dropInsertionEffects","$$useLayoutEffect","useLayoutEffect","hasLayoutEffects","dropLayoutEffects","Memo","check","processValue","getValue","isDifferent","wrap","useMemo","hookValue","getValue$","useState","initialValue","setState","sourceValue","prevValue","newValue","setValue","priority","useUpdate","onStart","forceStart","timeoutMs","forceSync","batch","clearTimeout","setTimeout","NodeType","$$vNode","VirtualNode","TagVirtualNode","name","attrs","super","TextVirtualNode","text","CommentVirtualNode","detectIsVirtualNode","vNode","detectIsTagVirtualNode","detectIsCommentVirtualNode","detectIsTextVirtualNode","detectIsVirtualNodeFactory","factory","getTagVirtualNodeKey","getTagVirtualNodeFlag","getVirtualNodeFactoryKey","getVirtualNodeFactoryFlag","createReplacer","detectIsPlainVirtualNode","detectIsReplacer","View","def","_void","flag","Text","from","walkFiber","onLoop","isDeepWalking","isStopped","visitedMap","detectCanVisit","child","newFiber","collectElements","transform","elements","getFiberWithElement","fiber$","detectIsFiberAlive","hasError","workLoop","yield$","nextUnitOfWork","hasMoreWork","box","fiber$$","inst$","performUnitOfWork","isDynamic","diff","alt","parentFiber","isRight","syncElementIndices","runEffects","flush","err","StopWork","isStream","hasChildrenProp","mountChild","mountSibling","nextFiber$","instance$","alternate","getHook","install","current","memo","childrenIdx","shadow","detectAreSameInstanceTypes","getElementKey","move","insertToFiber","createConditionalFiber","marker","areSameTypes","getElementFlag","NM","used","hasSameCount","prevKeys","nextKeys","prevKeysMap","nextKeysMap","keyedFibersMap","prevKey","createIndexKey","nextKey","extractKeys","result","size","Math","max","p","n","prevKeyFiber","nextKeyFiber","canAddToDeletions","pc","nc","_","__","splice","isComponent","supportConditional","getInstanceType","prevInstance","nextInstance","isComponentFactories","nextComponent","detectAreSameComponentTypesWithSameKeys","createUpdateCallback","detectIsBusy","SLASH","PARAMETER","WILDCARD","PROTOCOL_MARK","SEARCH_MARK","HASH_MARK","ActiveRouteContext","useActiveRouteContext","RouterHistoryContext","useRouterHistoryContext","CurrentPathContext","useCurrentPathContext","checkContextValue","Route","path","prefix","redirectTo","pathMatch","rootPath","createRootPath","path$","createPath","createRoutes","route","getRoute","getPath","replaceAll","render","nextRoute","routes","routes$","route$","redirect","pick","createMatcher","space","skip","urlPath","routePath","sUrlPath","sRoutePath","segment","isRoot","isWildcard","isParam","createPathname","parts","param","newPathname","join","prefix$","resolveRoute","pathname","activeRoute","filter","detectIsMatchByFirstStrategy","b","matcher","detectIsMatchBySecondStrategy","a","match","detectIsMatchAsWildcard","wildcard","find","resolve","params","sPathname","sPath","getParamsMap","RouterLink","to","activeClassName","className","sourceClassName","onClick","rest","history","hash","isActive","to$","hash$","indexOf","detectIsActiveLink","cm","handleClick","useEvent","preventDefault","href","class","useHistory","useLocation","location","pipe","fns","fn1","fn2","parseURL","url","body","protocol","host","search","split","splitted","findIndex","idx1","addSlashToEnd","createSearch","createHash","detectIsParam","startsWith","getParamName","slice","splitPath","endsWith","normalaizePathname","spath","sort","selector","compare","trim","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","d","definition","defineProperty","enumerable","f","chunkId","Promise","all","promises","u","g","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","call","l","done","script","needAttach","scripts","document","getElementsByTagName","s","getAttribute","charset","timeout","setAttribute","src","onScriptComplete","prev","event","onerror","onload","doneFns","parentNode","removeChild","bind","target","head","appendChild","r","toStringTag","scriptUrl","importScripts","currentScript","replace","installedChunks","j","installedChunkData","promise","reject","errorType","realSrc","message","request","webpackJsonpCallback","parentChunkLoadingFunction","chunkIds","moreModules","runtime","chunkLoadingGlobal","self","forwardRef","applyRef","mutableRef","detectIsMutableRef","$$portal","getPortalContainer","textContent","SyntheticEvent","sourceEvent","propagation","stopPropagation","getPropagation","delegateEvent","eventName","handler","eventsMap","handlerMap","handler$","rootHandler","fireEvent","synthetic","parentElement","dispatchEvent","WeakMap","addEventListener","removeEventListener","detectIsEvent","attrName","getEventName","toLowerCase","attrBlackListMap","patchPropsBlackListMap","fill","moves","svgTagNamesMap","voidTagNamesMap","createNativeElementMap","tagNode","tagName","createElementNS","createTextNode","createComment","createNativeElement","patchProperties","attrValue","patchPropertiesSpecialCasesMap","getPrototypeOf","getOwnPropertyDescriptor","includes","input","checked","autofocus","textarea","innerHTML","String","commitMap","childNodes","nativeElement","splitText","appendNativeElement","insertNativeElement","attrNames","tagElement","addAttributes","commitCreation","sourceNodes","sourceFragment","DocumentFragment","elementIdx","node","removeNativeElement","replaceNativeElement","nextVNode","prevAttrValue","nextAttrValue","removeAttribute","updateAttributes","commitUpdate","walk","sibling","insertBefore","insertNativeElementByIndex","candidate","replaceChild","queueByPriority","animations","hight","normal","low1","low2","scheduledCallback","deadline","isMessageLoopRunning","Task","nextTaskId","time","scheduleCallback","task","executeTasks","queue","shift","isAnimation","requestCallbackSync","port","postMessage","checkOverdueTasks","requestIdleCallback","channel","MessageChannel","port2","port1","onmessage","isInjected","roots","container","hydrate","requestAnimationFrame","cancelAnimationFrame","inject","isMounted","currentRoot","$$shadow","Shadow","isVisible","isEnabled","fibers","SuspenseContext","isLoaded","fallback","reg","unreg","Suspense","setIsLoaded","content","CONTENT","FALLBACK","factoriesMap","lazy","then","default","fetchModule","browserHistory","RouterHistory","stack","cursor","fromHistory","dispose","spathname","state","getState","replaceState","createStateBox","handleEvent","mapSubscribers","clear","STATE_KEY","syncHistory","action","stateBox","spathname$","HistoryAction","PUSH","pushState","REPLACE","forward","go","back","delta","RouterLocation","charCodeAt","createKey","freeze","createRouterLocation","Router","baseURL","sourceRoutes","sourceURL","setLocation","createRouterHistory","slot$","historyContext","routerContext","newSpathname","createHandle","navigateTo","useImperativeHandle","Spinner","Shell","App","getElementById","unmount","createRoot","bootstrap"],"sourceRoot":""}