{"version":3,"file":"dark-core.production.min.js","mappings":"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","sources":["webpack://DarkCore/webpack/universalModuleDefinition","webpack://DarkCore/webpack/bootstrap","webpack://DarkCore/webpack/runtime/define property getters","webpack://DarkCore/webpack/runtime/hasOwnProperty shorthand","webpack://DarkCore/webpack/runtime/make namespace object","webpack://DarkCore/./src/constants.ts","webpack://DarkCore/./src/helpers/index.ts","webpack://DarkCore/./src/component/component.ts","webpack://DarkCore/./src/scope/scope.ts","webpack://DarkCore/./src/use-effect/use-effect.ts","webpack://DarkCore/./src/view/types.ts","webpack://DarkCore/./src/view/view.ts","webpack://DarkCore/./src/fragment/fragment.ts","webpack://DarkCore/./src/ref/ref.ts","webpack://DarkCore/./src/memo/memo.ts","webpack://DarkCore/./src/use-memo/use-memo.ts","webpack://DarkCore/./src/platform/platform.ts","webpack://DarkCore/./src/fiber/types.ts","webpack://DarkCore/./src/use-layout-effect/use-layout-effect.ts","webpack://DarkCore/./src/walk/walk.ts","webpack://DarkCore/./src/unmount/unmount.ts","webpack://DarkCore/./src/fiber/fiber.ts","webpack://DarkCore/./src/batch/batch.ts","webpack://DarkCore/./src/use-update/use-update.ts","webpack://DarkCore/./src/use-context/use-context.ts","webpack://DarkCore/./src/context/context.ts","webpack://DarkCore/./src/element/element.ts","webpack://DarkCore/./src/use-callback/use-callback.ts","webpack://DarkCore/./src/use-state/use-state.ts","webpack://DarkCore/./src/suspense/suspense.ts","webpack://DarkCore/./src/lazy/lazy.ts","webpack://DarkCore/./src/use-deferred-value/use-deferred-value.ts","webpack://DarkCore/./src/use-error/use-error.ts","webpack://DarkCore/./src/use-event/use-event.ts","webpack://DarkCore/./src/use-imperative-handle/use-imperative-handle.ts","webpack://DarkCore/./src/use-reducer/use-reducer.ts","webpack://DarkCore/./src/use-ref/use-ref.ts","webpack://DarkCore/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"DarkCore\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"DarkCore\"] = factory();\n\telse\n\t\troot[\"DarkCore\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const ROOT = 'root';\r\nexport const EMPTY_NODE = 'dark:matter';\r\nexport const ATTR_KEY = 'key';\r\nexport const ATTR_REF = 'ref';\r\nexport const PARTIAL_UPDATE = 'partial-update';\r\n\r\nexport enum TaskPriority {\r\n  HIGH = 2,\r\n  NORMAL = 1,\r\n  LOW = 0,\r\n}\r\n","import type { NestedArray } from '../shared';\r\n\r\nconst detectIsFunction = (o: any): o is Function => typeof o === 'function';\r\n\r\nconst detectIsUndefined = (o: any): o is undefined => typeof o === 'undefined';\r\n\r\nconst detectIsNumber = (o: any): o is number => typeof o === 'number';\r\n\r\nconst detectIsString = (o: any): o is string => typeof o === 'string';\r\n\r\nconst detectIsObject = (o: any): o is object => typeof o === 'object';\r\n\r\nconst detectIsBoolean = (o: any): o is boolean => typeof o === 'boolean';\r\n\r\nconst detectIsArray = (o: any): o is Array<any> => Array.isArray(o);\r\n\r\nconst detectIsNull = (o: any): o is null => o === null;\r\n\r\nconst detectIsEmpty = (o: any) => detectIsNull(o) || detectIsUndefined(o);\r\n\r\nfunction error(str: string) {\r\n  !detectIsUndefined(console) && console.error(str);\r\n}\r\n\r\nfunction flatten<T = any>(source: Array<NestedArray<T>>): Array<T> {\r\n  const list = [];\r\n  const levelMap = { 0: { idx: 0, source } };\r\n  let level = 0;\r\n\r\n  do {\r\n    const { source, idx } = levelMap[level];\r\n    const item = source[idx];\r\n\r\n    if (idx >= source.length) {\r\n      level--;\r\n      levelMap[level].idx++;\r\n      continue;\r\n    }\r\n\r\n    if (detectIsArray(item)) {\r\n      level++;\r\n      levelMap[level] = {\r\n        idx: 0,\r\n        source: item,\r\n      };\r\n    } else {\r\n      list.push(item);\r\n      levelMap[level].idx++;\r\n    }\r\n  } while (level > 0 || levelMap[level].idx < levelMap[level].source.length);\r\n\r\n  return list;\r\n}\r\n\r\nfunction getTime() {\r\n  return Date.now();\r\n}\r\n\r\nfunction keyBy<T = any>(\r\n  list: Array<T>,\r\n  fn: (o: T) => string | number,\r\n  value = false,\r\n): Record<string | number, T | boolean> {\r\n  return list.reduce((acc, x) => ((acc[fn(x)] = value ? x : true), acc), {});\r\n}\r\n\r\nfunction fromEnd<T>(source: Array<T>, count: number) {\r\n  return source.slice(source.length - count, source.length);\r\n}\r\n\r\nconst dummyFn = () => {};\r\n\r\nfunction detectIsDepsDifferent(deps: Array<unknown>, prevDeps: Array<unknown>): boolean {\r\n  if (!detectIsUndefined(deps) && !detectIsUndefined(prevDeps) && deps.length > 0 && prevDeps.length > 0) {\r\n    for (let i = 0; i < prevDeps.length; i++) {\r\n      if (prevDeps[i] !== deps[i]) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport {\r\n  detectIsFunction,\r\n  detectIsUndefined,\r\n  detectIsNumber,\r\n  detectIsString,\r\n  detectIsObject,\r\n  detectIsBoolean,\r\n  detectIsArray,\r\n  detectIsNull,\r\n  detectIsEmpty,\r\n  error,\r\n  flatten,\r\n  getTime,\r\n  keyBy,\r\n  fromEnd,\r\n  dummyFn,\r\n  detectIsDepsDifferent,\r\n};\r\n","import { ATTR_KEY } from '../constants';\r\nimport { error, detectIsEmpty } from '../helpers';\r\nimport type { DarkElementKey, DarkElementInstance } from '../shared';\r\nimport type { Ref } from '../ref';\r\nimport type { CreateElement, ComponentOptions, StandardComponentProps, SlotProps } from './types';\r\n\r\nconst $$component = Symbol('component');\r\nconst defaultOptions: ComponentOptions<any> = {\r\n  displayName: '',\r\n  defaultProps: {},\r\n  token: $$component,\r\n};\r\nclass ComponentFactory<P extends StandardComponentProps = any, R = any> {\r\n  public type: CreateElement<P>;\r\n  public token: Symbol;\r\n  public props: P;\r\n  public ref: Ref<R>;\r\n  public displayName: string;\r\n  public children: Array<DarkElementInstance> = [];\r\n  public shouldUpdate?: (props: P, nextProps: P) => boolean;\r\n\r\n  constructor(options: ComponentFactory<P>) {\r\n    this.type = options.type || null;\r\n    this.token = options.token || null;\r\n    this.props = options.props || null;\r\n    this.ref = options.ref || null;\r\n    this.displayName = options.displayName || '';\r\n    this.shouldUpdate = options.shouldUpdate || null;\r\n  }\r\n}\r\n\r\nfunction createComponent<P, R = any>(\r\n  createElement: CreateElement<P & SlotProps, R>,\r\n  options: ComponentOptions<P> = {},\r\n) {\r\n  type Props = P & StandardComponentProps;\r\n  const computedOptions = { ...defaultOptions, ...options };\r\n  const { token, defaultProps, displayName, shouldUpdate } = computedOptions;\r\n\r\n  return (props = {} as Props, ref?: Ref<R>): ComponentFactory<Props> => {\r\n    const computedProps = { ...defaultProps, ...props };\r\n    const factory = new ComponentFactory({\r\n      token,\r\n      ref,\r\n      displayName,\r\n      shouldUpdate,\r\n      props: computedProps,\r\n      type: createElement,\r\n      children: [],\r\n    });\r\n\r\n    if (computedProps.ref) {\r\n      delete computedProps.ref;\r\n\r\n      if (process.env.NODE_ENV === 'development') {\r\n        error(`[Dark]: To use ref you need to wrap the createComponent with forwardRef!`);\r\n      }\r\n    }\r\n\r\n    return factory;\r\n  };\r\n}\r\n\r\nconst detectIsComponentFactory = (factory: unknown): factory is ComponentFactory => factory instanceof ComponentFactory;\r\n\r\nconst getComponentFactoryKey = (factory: ComponentFactory): DarkElementKey =>\r\n  !detectIsEmpty(factory.props[ATTR_KEY]) ? factory.props[ATTR_KEY] : null;\r\n\r\nexport { ComponentFactory, createComponent, detectIsComponentFactory, getComponentFactoryKey };\r\n","import type { Fiber } from '../fiber';\r\nimport { dummyFn } from '../helpers';\r\n\r\nlet rootId: number = null;\r\n\r\nconst stores = new Map<number, Store>();\r\n\r\nclass Store<N = unknown> {\r\n  public wipRoot: Fiber = null;\r\n  public currentRoot: Fiber = null;\r\n  public nextUnitOfWork: Fiber = null;\r\n  public events: Map<string, WeakMap<object, Function>> = new Map();\r\n  public unsubscribers: Array<() => void> = [];\r\n  public deletions: Array<Fiber> = [];\r\n  public fiberMount: FiberMountStore = {\r\n    level: 0,\r\n    navigation: {},\r\n    isDeepWalking: true,\r\n  };\r\n  public componentFiber: Fiber = null;\r\n  public effects: Array<() => void> = [];\r\n  public layoutEffects: Array<() => void> = [];\r\n  public isLayoutEffectsZone = false;\r\n  public isUpdateHookZone = false;\r\n  public isBatchZone = false;\r\n  public trackUpdate: (nativeElement: N) => void | undefined;\r\n}\r\n\r\ntype FiberMountStore = {\r\n  level: number;\r\n  navigation: Record<number, number>;\r\n  isDeepWalking: boolean;\r\n};\r\n\r\nconst rootStore = {\r\n  set: (id: number) => {\r\n    rootId = id;\r\n    !stores.get(rootId) && stores.set(rootId, new Store());\r\n  },\r\n  remove: (id: number) => stores.delete(id),\r\n};\r\n\r\nconst getRootId = () => rootId;\r\n\r\nconst store = {\r\n  get: (id: number = rootId) => stores.get(id),\r\n};\r\n\r\nconst wipRootStore = {\r\n  get: () => store.get()?.wipRoot || null,\r\n  set: (fiber: Fiber) => (store.get().wipRoot = fiber),\r\n};\r\n\r\nconst currentRootStore = {\r\n  get: (id?: number) => store.get(id)?.currentRoot || null,\r\n  set: (fiber: Fiber) => (store.get().currentRoot = fiber),\r\n};\r\n\r\nconst nextUnitOfWorkStore = {\r\n  get: () => store.get()?.nextUnitOfWork || null,\r\n  set: (fiber: Fiber) => (store.get().nextUnitOfWork = fiber),\r\n};\r\n\r\nconst currentFiberStore = {\r\n  get: () => store.get()?.componentFiber,\r\n  set: (fiber: Fiber) => (store.get().componentFiber = fiber),\r\n};\r\n\r\nconst eventsStore = {\r\n  get: () => store.get().events,\r\n  addUnsubscriber: (fn: () => void) => store.get().unsubscribers.push(fn),\r\n  unsubscribe: (id: number) => store.get(id).unsubscribers.forEach(fn => fn()),\r\n};\r\n\r\nconst deletionsStore = {\r\n  get: () => store.get().deletions,\r\n  set: (deletions: Array<Fiber>) => (store.get().deletions = deletions),\r\n};\r\n\r\nconst fiberMountStore = {\r\n  reset: () => {\r\n    store.get().fiberMount = {\r\n      level: 0,\r\n      navigation: {},\r\n      isDeepWalking: true,\r\n    };\r\n  },\r\n  getIndex: () => store.get().fiberMount.navigation[store.get().fiberMount.level],\r\n  jumpToChild: () => {\r\n    const { fiberMount } = store.get();\r\n    const level = fiberMount.level;\r\n    const nextLevel = level + 1;\r\n\r\n    fiberMount.level = nextLevel;\r\n    fiberMount.navigation[nextLevel] = 0;\r\n  },\r\n  jumpToParent: () => {\r\n    const { fiberMount } = store.get();\r\n    const level = fiberMount.level;\r\n    const nextLevel = level - 1;\r\n\r\n    fiberMount.navigation[level] = 0;\r\n    fiberMount.level = nextLevel;\r\n  },\r\n  jumpToSibling: () => {\r\n    const { fiberMount } = store.get();\r\n    const level = fiberMount.level;\r\n    const idx = fiberMount.navigation[level] + 1;\r\n\r\n    fiberMount.navigation[level] = idx;\r\n  },\r\n  deepWalking: {\r\n    get: () => store.get().fiberMount.isDeepWalking,\r\n    set: (value: boolean) => (store.get().fiberMount.isDeepWalking = value),\r\n  },\r\n};\r\n\r\nconst effectsStore = {\r\n  get: () => store.get().effects,\r\n  reset: () => (store.get().effects = []),\r\n  add: (effect: () => void) => store.get().effects.push(effect),\r\n};\r\n\r\nconst layoutEffectsStore = {\r\n  get: () => store.get().layoutEffects,\r\n  reset: () => (store.get().layoutEffects = []),\r\n  add: (effect: () => void) => store.get().layoutEffects.push(effect),\r\n};\r\n\r\nconst isLayoutEffectsZone = {\r\n  get: () => store.get()?.isLayoutEffectsZone || false,\r\n  set: (value: boolean) => (store.get().isLayoutEffectsZone = value),\r\n};\r\n\r\nconst isUpdateHookZone = {\r\n  get: () => store.get()?.isUpdateHookZone || false,\r\n  set: (value: boolean) => (store.get().isUpdateHookZone = value),\r\n};\r\n\r\nconst isBatchZone = {\r\n  get: () => store.get()?.isBatchZone || false,\r\n  set: (value: boolean) => (store.get().isBatchZone = value),\r\n};\r\n\r\nexport {\r\n  getRootId,\r\n  rootStore,\r\n  wipRootStore,\r\n  currentRootStore,\r\n  nextUnitOfWorkStore,\r\n  currentFiberStore,\r\n  eventsStore,\r\n  deletionsStore,\r\n  fiberMountStore,\r\n  effectsStore,\r\n  layoutEffectsStore,\r\n  isLayoutEffectsZone,\r\n  isUpdateHookZone,\r\n  isBatchZone,\r\n};\r\n","import { detectIsUndefined, detectIsFunction, detectIsDepsDifferent } from '../helpers';\r\nimport { currentFiberStore, effectsStore } from '../scope';\r\nimport type { Fiber, Hook, HookValue } from '../fiber';\r\nimport type { Effect, DropEffect } from './types';\r\n\r\nconst $$useEffect = Symbol('use-effect');\r\n\r\nconst { useEffect, hasEffects, dropEffects } = createEffect($$useEffect, effectsStore);\r\n\r\nfunction createEffect(token: Symbol, store: typeof effectsStore) {\r\n  function useEffect(effect: Effect, deps?: Array<any>) {\r\n    const fiber = currentFiberStore.get();\r\n    const hook = fiber.hook as Hook<HookValue<DropEffect>>;\r\n    const { idx, values } = hook;\r\n    const runEffect = () => {\r\n      values[idx] = {\r\n        deps,\r\n        token,\r\n        value: undefined,\r\n      };\r\n\r\n      store.add(() => {\r\n        values[idx].value = effect();\r\n      });\r\n    };\r\n\r\n    if (detectIsUndefined(values[idx])) {\r\n      runEffect();\r\n    } else {\r\n      const { deps: prevDeps, value: cleanup } = values[idx];\r\n      const isDepsDifferent = deps ? detectIsDepsDifferent(deps, prevDeps) : true;\r\n\r\n      if (isDepsDifferent) {\r\n        detectIsFunction(cleanup) && cleanup();\r\n        runEffect();\r\n      }\r\n    }\r\n\r\n    hook.idx++;\r\n  }\r\n\r\n  function hasEffects(fiber: Fiber) {\r\n    const { values } = fiber.hook as Hook<HookValue>;\r\n    const hasEffect = values.some(x => x?.token === token);\r\n\r\n    return hasEffect;\r\n  }\r\n\r\n  function dropEffects(hook: Hook<HookValue<DropEffect>>) {\r\n    const { values } = hook;\r\n\r\n    for (const value of values) {\r\n      if (value.token === token) {\r\n        const cleanup = value.value;\r\n\r\n        detectIsFunction(cleanup) && cleanup();\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    useEffect,\r\n    hasEffects,\r\n    dropEffects,\r\n  };\r\n}\r\n\r\nexport { useEffect, hasEffects, dropEffects, createEffect };\r\n","export type ViewDef = {\r\n  as: string;\r\n  slot?: any;\r\n  isVoid?: boolean;\r\n  [prop: string]: any;\r\n};\r\n\r\nexport enum NodeType {\r\n  TAG = 'TAG',\r\n  TEXT = 'TEXT',\r\n  COMMENT = 'COMMENT',\r\n}\r\n","import { EMPTY_NODE, ATTR_KEY } from '../constants';\r\nimport { detectIsArray, detectIsEmpty, detectIsFunction, detectIsString } from '../helpers';\r\nimport type { DarkElementKey } from '../shared';\r\nimport type { ComponentFactory, StandardComponentProps } from '../component';\r\nimport { NodeType, type ViewDef } from './types';\r\n\r\nexport type VirtualNodeFactory = () => VirtualNode;\r\nexport type TagVirtualNodeFactory = () => TagVirtualNode;\r\nexport type TextVirtualNodeFactory = () => TextVirtualNode;\r\nexport type CommentVirtualNodeFactory = () => CommentVirtualNode;\r\n\r\nconst $$virtualNode = Symbol('virtual-node');\r\n\r\nclass VirtualNode {\r\n  public type: NodeType = null;\r\n\r\n  constructor(options: Partial<VirtualNode>) {\r\n    this.type = options.type;\r\n  }\r\n}\r\n\r\nclass TagVirtualNode extends VirtualNode {\r\n  public type = NodeType.TAG;\r\n  public name: string = null;\r\n  public isVoid = false;\r\n  public attrs: Record<string, any> = {};\r\n  public children: Array<VirtualNodeFactory | ComponentFactory> = [];\r\n\r\n  constructor(options: Partial<TagVirtualNode>) {\r\n    super(options);\r\n    this.name = options.name || this.name;\r\n    this.isVoid = options.isVoid || this.isVoid;\r\n    this.attrs = options.attrs || this.attrs;\r\n    this.children = options.children || this.children;\r\n  }\r\n}\r\n\r\nclass TextVirtualNode extends VirtualNode {\r\n  public type = NodeType.TEXT;\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super({});\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nclass CommentVirtualNode extends VirtualNode {\r\n  public type = NodeType.COMMENT;\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super({});\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nconst detectIsVirtualNode = (vNode: unknown): vNode is VirtualNode => vNode instanceof VirtualNode;\r\n\r\nconst detectIsTagVirtualNode = (vNode: unknown): vNode is TagVirtualNode => vNode instanceof TagVirtualNode;\r\n\r\nconst detectIsCommentVirtualNode = (vNode: unknown): vNode is CommentVirtualNode => vNode instanceof CommentVirtualNode;\r\n\r\nconst detectIsTextVirtualNode = (vNode: unknown): vNode is TextVirtualNode => vNode instanceof TextVirtualNode;\r\n\r\nconst detectIsEmptyVirtualNode = (vNode: unknown): boolean =>\r\n  detectIsCommentVirtualNode(vNode) && vNode.value === EMPTY_NODE;\r\n\r\nfunction getVirtualNodeKey(vNode: TagVirtualNode): DarkElementKey | null {\r\n  const key = vNode && vNode.attrs[ATTR_KEY];\r\n\r\n  return !detectIsEmpty(key) ? key : null;\r\n}\r\n\r\nconst createEmptyVirtualNode = () => new CommentVirtualNode(EMPTY_NODE);\r\n\r\nconst detectIsVirtualNodeFactory = (factory: unknown): factory is VirtualNodeFactory =>\r\n  detectIsFunction(factory) && factory[$$virtualNode] === true;\r\n\r\nfunction View(def: ViewDef): TagVirtualNodeFactory {\r\n  const factory = () => {\r\n    const { as, slot, isVoid = false, ...rest } = def;\r\n    const children = isVoid ? [] : detectIsArray(slot) ? slot : slot ? [slot] : [];\r\n\r\n    return new TagVirtualNode({\r\n      name: as,\r\n      isVoid,\r\n      attrs: { ...rest },\r\n      children: children as Array<VirtualNodeFactory>,\r\n    });\r\n  };\r\n\r\n  factory[$$virtualNode] = true;\r\n\r\n  return factory;\r\n}\r\n\r\nfunction Text(source: string | StandardComponentProps['slot']): string | TextVirtualNode {\r\n  const text = detectIsString(source)\r\n    ? new TextVirtualNode(source)\r\n    : detectIsTextVirtualNode(source)\r\n    ? source.value\r\n    : '';\r\n\r\n  return text;\r\n}\r\n\r\nfunction Comment(text: string): CommentVirtualNodeFactory {\r\n  const factory = () => new CommentVirtualNode(text);\r\n\r\n  factory[$$virtualNode] = true;\r\n\r\n  return factory;\r\n}\r\n\r\nexport {\r\n  VirtualNode,\r\n  TagVirtualNode,\r\n  TextVirtualNode,\r\n  CommentVirtualNode,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsCommentVirtualNode,\r\n  detectIsTextVirtualNode,\r\n  detectIsEmptyVirtualNode,\r\n  getVirtualNodeKey,\r\n  createEmptyVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n  View,\r\n  Text,\r\n  Comment,\r\n};\r\n","import { type KeyProps, createComponent, detectIsComponentFactory } from '../component';\r\n\r\nconst $$fragment = Symbol('fragment');\r\n\r\nconst Fragment = createComponent<KeyProps>(({ slot }) => slot || null, {\r\n  token: $$fragment,\r\n});\r\n\r\nconst detectIsFragment = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$fragment;\r\n\r\nexport { Fragment, detectIsFragment };\r\n","import { detectIsObject, detectIsNull } from '../helpers';\r\nimport type { Component, RefProps, ComponentFactory } from '../component';\r\nimport type { MutableRef } from './types';\r\n\r\nfunction forwardRef<P, R>(component: Component<P, R>) {\r\n  type Props = P & RefProps<R>;\r\n\r\n  return ({ ref, ...rest }: Props) => {\r\n    return component(rest as P, ref) as ComponentFactory<P, R>;\r\n  };\r\n}\r\n\r\nconst detectIsMutableRef = (ref: unknown): ref is MutableRef => {\r\n  if (!detectIsObject(ref) || detectIsNull(ref)) return false;\r\n  const mutableRef = ref as MutableRef;\r\n\r\n  for (const key in mutableRef) {\r\n    if (key === 'current' && mutableRef.hasOwnProperty(key)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport { forwardRef, detectIsMutableRef };\r\n","import {\r\n  type Component,\r\n  type ComponentFactory,\r\n  type StandardComponentProps,\r\n  type RefProps,\r\n  type SlotProps,\r\n  createComponent,\r\n  detectIsComponentFactory,\r\n} from '../component';\r\nimport { type Ref, forwardRef } from '../ref';\r\n\r\ntype ShouldUpdate<T> = (props: T, nextProps: T) => boolean;\r\n\r\nconst $$memo = Symbol('memo');\r\n\r\nconst defaultShouldUpdate = (props: {}, nextProps: {}): boolean => {\r\n  const keys = Object.keys(nextProps);\r\n\r\n  for (const key of keys) {\r\n    if (key !== 'slot' && nextProps[key] !== props[key]) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst detectIsMemo = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$memo;\r\n\r\nfunction memo<T>(\r\n  component: (props: T, ref?: Ref) => ComponentFactory<T>,\r\n  shouldUpdate: ShouldUpdate<T & SlotProps> = defaultShouldUpdate,\r\n): Component<T & StandardComponentProps> {\r\n  return forwardRef(\r\n    createComponent(\r\n      (props: T & RefProps, ref) => {\r\n        ref && (props.ref = ref);\r\n\r\n        return component(props);\r\n      },\r\n      { token: $$memo, shouldUpdate },\r\n    ),\r\n  );\r\n}\r\n\r\nexport { $$memo, memo, detectIsMemo };\r\n","import { type DarkElement } from '../shared';\r\nimport { detectIsUndefined, detectIsArray, detectIsDepsDifferent } from '../helpers';\r\nimport { detectIsComponentFactory, createComponent } from '../component';\r\nimport { detectIsVirtualNodeFactory } from '../view';\r\nimport { currentFiberStore } from '../scope';\r\nimport { Fragment } from '../fragment';\r\nimport { $$memo } from '../memo';\r\n\r\nconst Memo = createComponent(({ slot }) => slot, { token: $$memo });\r\n\r\nfunction wrap<T>(value: T, isDepsDifferent: boolean) {\r\n  const check = (value: T) => detectIsVirtualNodeFactory(value) || detectIsComponentFactory(value);\r\n\r\n  if (detectIsArray(value) ? check(value[0]) : check(value)) {\r\n    const slot = value as unknown as DarkElement;\r\n    const factory = Memo({\r\n      slot: Fragment({ slot }),\r\n    });\r\n\r\n    factory.shouldUpdate = () => isDepsDifferent;\r\n\r\n    return factory;\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction processValue<T>(getValue: () => T, isDepsDifferent = false) {\r\n  return wrap(getValue(), isDepsDifferent);\r\n}\r\n\r\nfunction useMemo<T>(getValue: () => T, deps: Array<any>): T {\r\n  const fiber = currentFiberStore.get();\r\n  const { hook } = fiber;\r\n  const { idx, values } = hook;\r\n\r\n  if (detectIsUndefined(values[idx])) {\r\n    const value = processValue(getValue);\r\n\r\n    values[idx] = {\r\n      deps,\r\n      value,\r\n    };\r\n\r\n    hook.idx++;\r\n\r\n    return value as T;\r\n  }\r\n\r\n  const hookValue = values[idx];\r\n  const prevDeps = hookValue.deps as Array<any>;\r\n  const isDepsDifferent = detectIsDepsDifferent(deps, prevDeps);\r\n  const computedGetValue = isDepsDifferent ? getValue : () => hookValue.value;\r\n\r\n  hookValue.deps = deps;\r\n  hookValue.value = processValue(computedGetValue, isDepsDifferent);\r\n\r\n  hook.idx++;\r\n\r\n  return hookValue.value;\r\n}\r\n\r\nexport { useMemo };\r\n","import type { Platform } from './types';\r\n\r\nexport const platform: Platform = {\r\n  createNativeElement: () => {\r\n    throw new Error('createNativeElement not installed by renderer');\r\n  },\r\n  requestAnimationFrame: () => {\r\n    throw new Error('requestAnimationFrame not installed by renderer');\r\n  },\r\n  scheduleCallback: () => {\r\n    throw new Error('scheduleCallback not installed by renderer');\r\n  },\r\n  shouldYeildToHost: () => {\r\n    throw new Error('shouldYeildToHost not installed by renderer');\r\n  },\r\n  applyCommit: () => {\r\n    throw new Error('applyCommit not installed by renderer');\r\n  },\r\n  finishCommitWork: () => {\r\n    throw new Error('finishCommitWork not installed by renderer');\r\n  },\r\n  detectIsPortal: () => {\r\n    throw new Error('detectIsPortal not installed by renderer');\r\n  },\r\n  unmountPortal: () => {\r\n    throw new Error('unmountPortal not installed by renderer');\r\n  },\r\n};\r\n","export enum EffectTag {\r\n  CREATE = 'CREATE',\r\n  UPDATE = 'UPDATE',\r\n  DELETE = 'DELETE',\r\n  SKIP = 'SKIP',\r\n}\r\n\r\nexport type NativeElement = unknown;\r\n\r\nexport type HookValue<T = any> = {\r\n  token?: Symbol;\r\n  deps: Array<any>;\r\n  value: T;\r\n};\r\n\r\nexport type Hook<T = any> = {\r\n  idx: number;\r\n  values: Array<T>;\r\n};\r\n\r\nexport const cloneTagMap = {\r\n  [EffectTag.CREATE]: true,\r\n  [EffectTag.SKIP]: true,\r\n};\r\n","import { layoutEffectsStore } from '../scope';\r\nimport { createEffect } from '../use-effect';\r\n\r\nconst $$useLayoutEffect = Symbol('use-layout-effect');\r\n\r\nconst {\r\n  useEffect: useLayoutEffect,\r\n  hasEffects: hasLayoutEffects,\r\n  dropEffects: dropLayoutEffects,\r\n} = createEffect($$useLayoutEffect, layoutEffectsStore);\r\n\r\nexport { useLayoutEffect, hasLayoutEffects, dropLayoutEffects };\r\n","import { type Fiber } from '../fiber';\r\n\r\ntype WalkFiberOptions<T> = {\r\n  fiber: Fiber;\r\n  onLoop: (options: OnLoopOptions<T>) => void;\r\n};\r\n\r\ntype OnLoopOptions<T> = {\r\n  nextFiber: Fiber<T>;\r\n  isReturn: boolean;\r\n  resetIsDeepWalking: () => void;\r\n  stop: () => void;\r\n};\r\n\r\nfunction walkFiber<T = unknown>(options: WalkFiberOptions<T>) {\r\n  const { fiber, onLoop } = options;\r\n  let nextFiber = fiber;\r\n  let isDeepWalking = true;\r\n  let isReturn = false;\r\n  let isStopped = false;\r\n  const visitedMap = new Map<Fiber, true>();\r\n  const detectCanVisit = (fiber: Fiber) => !visitedMap.get(fiber);\r\n\r\n  while (nextFiber) {\r\n    onLoop({\r\n      nextFiber: nextFiber as Fiber<T>,\r\n      isReturn,\r\n      resetIsDeepWalking: () => (isDeepWalking = false),\r\n      stop: () => (isStopped = true),\r\n    });\r\n\r\n    if (isStopped) {\r\n      break;\r\n    }\r\n\r\n    if (nextFiber.child && isDeepWalking && detectCanVisit(nextFiber.child)) {\r\n      const newFiber = nextFiber.child;\r\n\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap.set(newFiber, true);\r\n    } else if (nextFiber.nextSibling && detectCanVisit(nextFiber.nextSibling)) {\r\n      const newFiber = nextFiber.nextSibling;\r\n\r\n      isDeepWalking = true;\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap.set(newFiber, true);\r\n    } else if (\r\n      nextFiber.parent &&\r\n      nextFiber.parent === fiber &&\r\n      nextFiber.parent.nextSibling &&\r\n      detectCanVisit(nextFiber.parent.nextSibling)\r\n    ) {\r\n      const newFiber = nextFiber.parent.nextSibling;\r\n\r\n      isDeepWalking = true;\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap.set(newFiber, true);\r\n    } else if (nextFiber.parent && nextFiber.parent !== fiber) {\r\n      isDeepWalking = false;\r\n      isReturn = true;\r\n      nextFiber = nextFiber.parent;\r\n    } else {\r\n      nextFiber = null;\r\n    }\r\n  }\r\n}\r\n\r\nexport { walkFiber };\r\n","import { type Fiber } from '../fiber';\r\nimport { platform } from '../platform';\r\nimport { detectIsComponentFactory } from '../component';\r\nimport { dropEffects } from '../use-effect';\r\nimport { dropLayoutEffects } from '../use-layout-effect';\r\nimport { walkFiber } from '../walk';\r\nimport { detectIsUndefined } from '../helpers';\r\nimport { currentRootStore, eventsStore, rootStore } from '../scope';\r\n\r\nfunction unmountFiber(fiber: Fiber) {\r\n  if (!fiber.effectHost && !fiber.layoutEffectHost && !fiber.portalHost) return;\r\n\r\n  walkFiber({\r\n    fiber,\r\n    onLoop: ({ nextFiber, isReturn, stop }) => {\r\n      if (nextFiber === fiber.nextSibling || fiber.transposition) return stop();\r\n\r\n      if (!isReturn && detectIsComponentFactory(nextFiber.instance)) {\r\n        nextFiber.layoutEffectHost && dropLayoutEffects(nextFiber.hook);\r\n        nextFiber.effectHost && dropEffects(nextFiber.hook);\r\n        nextFiber.portalHost && platform.unmountPortal(nextFiber);\r\n      }\r\n    },\r\n  });\r\n}\r\n\r\nfunction unmountRoot(rootId: number, onComplete: () => void) {\r\n  if (detectIsUndefined(rootId)) return;\r\n\r\n  unmountFiber(currentRootStore.get(rootId));\r\n  eventsStore.unsubscribe(rootId);\r\n  rootStore.remove(rootId);\r\n  onComplete();\r\n}\r\n\r\nexport { unmountFiber, unmountRoot };\r\n","import { flatten, detectIsEmpty, error, keyBy, fromEnd, detectIsUndefined, detectIsArray } from '../helpers';\r\nimport { platform } from '../platform';\r\nimport {\r\n  wipRootStore,\r\n  currentRootStore,\r\n  nextUnitOfWorkStore,\r\n  deletionsStore,\r\n  fiberMountStore,\r\n  currentFiberStore,\r\n  isUpdateHookZone,\r\n  rootStore,\r\n  effectsStore,\r\n  layoutEffectsStore,\r\n  isLayoutEffectsZone,\r\n} from '../scope';\r\nimport { type ComponentFactory, detectIsComponentFactory, getComponentFactoryKey } from '../component';\r\nimport {\r\n  type TagVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  createEmptyVirtualNode,\r\n  getVirtualNodeKey,\r\n  detectIsVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n} from '../view';\r\nimport { detectIsMemo } from '../memo';\r\nimport type { Context, ContextProviderValue } from '../context';\r\nimport type { DarkElementKey, DarkElement, DarkElementInstance } from '../shared';\r\nimport { PARTIAL_UPDATE } from '../constants';\r\nimport { type NativeElement, type Hook, EffectTag, cloneTagMap } from './types';\r\nimport { hasEffects } from '../use-effect';\r\nimport { hasLayoutEffects } from '../use-layout-effect';\r\nimport { walkFiber } from '../walk';\r\nimport { unmountFiber } from '../unmount';\r\n\r\nclass Fiber<N = NativeElement> {\r\n  public nativeElement: N;\r\n  public parent: Fiber<N>;\r\n  public child: Fiber<N>;\r\n  public nextSibling: Fiber<N>;\r\n  public alternate: Fiber<N>;\r\n  public effectTag: EffectTag;\r\n  public instance: DarkElementInstance;\r\n  public hook: Hook;\r\n  public shadow: Fiber<N>;\r\n  public provider: Map<Context, ContextProviderValue>;\r\n  public transposition: boolean;\r\n  public mountedToHost: boolean;\r\n  public portalHost: boolean;\r\n  public effectHost: boolean;\r\n  public layoutEffectHost: boolean;\r\n  public childrenCount: number;\r\n  public marker: string;\r\n  public isUsed: boolean;\r\n  public idx: number;\r\n  public batched: Array<() => void>;\r\n  public catchException: (error: Error) => void;\r\n\r\n  constructor(options: Partial<Fiber<N>>) {\r\n    this.nativeElement = options.nativeElement || null;\r\n    this.parent = options.parent || null;\r\n    this.child = options.child || null;\r\n    this.nextSibling = options.nextSibling || null;\r\n    this.alternate = options.alternate || null;\r\n    this.effectTag = options.effectTag || null;\r\n    this.instance = options.instance || null;\r\n    this.hook = options.hook || createHook();\r\n    this.shadow = options.shadow || null;\r\n    this.provider = options.provider || null;\r\n    this.transposition = !detectIsUndefined(options.transposition) ? options.transposition : false;\r\n    this.mountedToHost = !detectIsUndefined(options.mountedToHost) || false;\r\n    this.portalHost = !detectIsUndefined(options.portalHost) ? options.portalHost : false;\r\n    this.effectHost = !detectIsUndefined(options.effectHost) ? options.effectHost : false;\r\n    this.layoutEffectHost = !detectIsUndefined(options.layoutEffectHost) ? options.layoutEffectHost : false;\r\n    this.childrenCount = options.childrenCount || 0;\r\n    this.marker = options.marker || '';\r\n    this.idx = options.idx || 0;\r\n    this.isUsed = options.isUsed || false;\r\n    this.batched = options.batched || [];\r\n  }\r\n\r\n  public markPortalHost() {\r\n    this.portalHost = true;\r\n    this.parent && !this.parent.portalHost && this.parent.markPortalHost();\r\n  }\r\n\r\n  public markEffectHost() {\r\n    this.effectHost = true;\r\n    this.parent && !this.parent.effectHost && this.parent.markEffectHost();\r\n  }\r\n\r\n  public markLayoutEffectHost() {\r\n    this.layoutEffectHost = true;\r\n    this.parent && !this.parent.layoutEffectHost && this.parent.markLayoutEffectHost();\r\n  }\r\n\r\n  public markMountedToHost() {\r\n    this.mountedToHost = true;\r\n    this.parent && !this.parent.mountedToHost && this.parent.markMountedToHost();\r\n  }\r\n\r\n  public setError(error: Error) {\r\n    if (typeof this.catchException === 'function') {\r\n      this.catchException(error);\r\n    } else if (this.parent) {\r\n      this.parent.setError(error);\r\n    }\r\n  }\r\n}\r\n\r\nfunction workLoop() {\r\n  const wipFiber = wipRootStore.get();\r\n  let nextUnitOfWork = nextUnitOfWorkStore.get();\r\n  let shouldYield = false;\r\n  let hasMoreWork = Boolean(nextUnitOfWork);\r\n\r\n  while (nextUnitOfWork && !shouldYield) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\r\n    nextUnitOfWorkStore.set(nextUnitOfWork);\r\n    hasMoreWork = Boolean(nextUnitOfWork);\r\n    shouldYield = platform.shouldYeildToHost();\r\n  }\r\n\r\n  if (!nextUnitOfWork && wipFiber) {\r\n    commitChanges();\r\n  }\r\n\r\n  return hasMoreWork;\r\n}\r\n\r\nfunction performUnitOfWork(fiber: Fiber) {\r\n  let isDeepWalking = true;\r\n  let nextFiber = fiber;\r\n  let shadow: Fiber = fiber.shadow;\r\n  let instance = fiber.instance;\r\n\r\n  while (true) {\r\n    isDeepWalking = fiberMountStore.deepWalking.get();\r\n    nextFiber.hook.idx = 0;\r\n\r\n    if (isDeepWalking) {\r\n      const hasChildren = hasChildrenProp(instance) && instance.children.length > 0;\r\n\r\n      if (hasChildren) {\r\n        const { performedFiber, performedNextFiber, performedShadow, performedInstance } = performChild({\r\n          nextFiber,\r\n          shadow,\r\n          instance,\r\n        });\r\n\r\n        nextFiber = performedNextFiber;\r\n        shadow = performedShadow;\r\n        instance = performedInstance;\r\n\r\n        if (performedFiber) return performedFiber;\r\n      } else {\r\n        const { performedFiber, performedNextFiber, performedShadow, performedInstance } = performSibling({\r\n          nextFiber,\r\n          shadow,\r\n          instance,\r\n        });\r\n\r\n        nextFiber = performedNextFiber;\r\n        shadow = performedShadow;\r\n        instance = performedInstance;\r\n\r\n        if (performedFiber) return performedFiber;\r\n      }\r\n    } else {\r\n      const { performedFiber, performedNextFiber, performedShadow, performedInstance } = performSibling({\r\n        nextFiber,\r\n        shadow,\r\n        instance,\r\n      });\r\n\r\n      nextFiber = performedNextFiber;\r\n      shadow = performedShadow;\r\n      instance = performedInstance;\r\n\r\n      if (performedFiber) return performedFiber;\r\n    }\r\n\r\n    performPartialUpdateEffects(nextFiber);\r\n\r\n    if (nextFiber.parent === null) return null;\r\n  }\r\n}\r\n\r\nfunction performPartialUpdateEffects(nextFiber: Fiber) {\r\n  if (nextFiber.marker !== PARTIAL_UPDATE) return;\r\n\r\n  const alternate = nextFiber.child?.alternate || null;\r\n  const fiber = nextFiber.child || null;\r\n\r\n  if (alternate && fiber && alternate.nextSibling && !fiber.nextSibling) {\r\n    let nextFiber = alternate.nextSibling;\r\n    const deletions: Array<Fiber> = [];\r\n\r\n    while (nextFiber) {\r\n      nextFiber.effectTag = EffectTag.DELETE;\r\n      deletions.push(nextFiber);\r\n      nextFiber = nextFiber.nextSibling;\r\n    }\r\n\r\n    deletionsStore.get().push(...deletions);\r\n  }\r\n}\r\n\r\ntype PerformChildOptions = {\r\n  nextFiber: Fiber;\r\n  shadow: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction performChild(options: PerformChildOptions) {\r\n  fiberMountStore.jumpToChild();\r\n  let nextFiber = options.nextFiber;\r\n  let shadow = options.shadow;\r\n  let instance = options.instance;\r\n  const childrenIdx = 0;\r\n\r\n  shadow = shadow ? shadow.child : null;\r\n  const alternate = getChildAlternate(nextFiber);\r\n  const sourceInstance = hasChildrenProp(instance) ? instance.children[childrenIdx] || null : null;\r\n  const prevKey = alternate ? getElementKey(alternate.instance) : null;\r\n  const nextKey = sourceInstance ? getElementKey(sourceInstance) : null;\r\n  shadow = prevKey !== null && nextKey !== null && prevKey === nextKey ? null : shadow;\r\n  const hook = getHook({ shadow, alternate, prevKey, nextKey });\r\n  const provider = shadow ? shadow.provider : alternate ? alternate.provider : null;\r\n  let fiber = new Fiber({ hook, provider });\r\n\r\n  currentFiberStore.set(fiber);\r\n  fiber.parent = nextFiber;\r\n\r\n  const { performedInstance, performedShadow } = pertformInstance({\r\n    instance,\r\n    idx: childrenIdx,\r\n    fiber,\r\n    alternate,\r\n  });\r\n  instance = performedInstance || instance;\r\n  shadow = performedShadow || shadow;\r\n  alternate && mutateAlternate({ alternate, instance });\r\n  mutateFiber({ fiber, alternate, instance });\r\n  fiber = alternate ? performMemo({ fiber, alternate, instance }) : fiber;\r\n\r\n  fiber.idx = childrenIdx;\r\n  nextFiber.child = fiber;\r\n  fiber.parent = nextFiber;\r\n  fiber.shadow = shadow;\r\n  nextFiber = fiber;\r\n\r\n  cloneTagMap[fiber.parent.effectTag] && (fiber.effectTag = fiber.parent.effectTag);\r\n\r\n  return {\r\n    performedFiber: nextFiber,\r\n    performedNextFiber: nextFiber,\r\n    performedShadow: shadow,\r\n    performedInstance: instance,\r\n  };\r\n}\r\n\r\ntype PerformSiblingOptions = {\r\n  nextFiber: Fiber;\r\n  shadow: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction performSibling(options: PerformSiblingOptions) {\r\n  fiberMountStore.jumpToSibling();\r\n  let nextFiber = options.nextFiber;\r\n  let shadow = options.shadow;\r\n  let instance = options.instance;\r\n  const parent = nextFiber.parent.instance;\r\n  const childrenIdx = fiberMountStore.getIndex();\r\n  const hasSibling = hasChildrenProp(parent) && parent.children[childrenIdx];\r\n\r\n  if (hasSibling) {\r\n    fiberMountStore.deepWalking.set(true);\r\n\r\n    shadow = shadow ? shadow.nextSibling : null;\r\n    const alternate = getNextSiblingAlternate(nextFiber);\r\n    const sourceInstance = hasChildrenProp(nextFiber.parent.instance)\r\n      ? nextFiber.parent.instance.children[childrenIdx] || null\r\n      : null;\r\n    const prevKey = alternate ? getElementKey(alternate.instance) : null;\r\n    const nextKey = sourceInstance ? getElementKey(sourceInstance) : null;\r\n    shadow = prevKey !== null && nextKey !== null && prevKey === nextKey ? null : shadow;\r\n    const hook = getHook({ shadow, alternate, prevKey, nextKey });\r\n    const provider = shadow ? shadow.provider : alternate ? alternate.provider : null;\r\n    let fiber = new Fiber({ hook, provider });\r\n\r\n    currentFiberStore.set(fiber);\r\n    fiber.parent = nextFiber.parent;\r\n\r\n    const { performedInstance, performedShadow } = pertformInstance({\r\n      instance: parent,\r\n      idx: childrenIdx,\r\n      fiber,\r\n      alternate,\r\n    });\r\n    instance = performedInstance || instance;\r\n    shadow = performedShadow || shadow;\r\n    alternate && mutateAlternate({ alternate, instance });\r\n    mutateFiber({ fiber, alternate, instance });\r\n    fiber = alternate ? performMemo({ fiber, alternate, instance }) : fiber;\r\n\r\n    fiber.idx = childrenIdx;\r\n    fiber.parent = nextFiber.parent;\r\n    nextFiber.nextSibling = fiber;\r\n    fiber.shadow = shadow;\r\n    nextFiber = fiber;\r\n\r\n    cloneTagMap[fiber.parent.effectTag] && (fiber.effectTag = fiber.parent.effectTag);\r\n\r\n    return {\r\n      performedFiber: nextFiber,\r\n      performedNextFiber: nextFiber,\r\n      performedShadow: shadow,\r\n      performedInstance: instance,\r\n    };\r\n  } else {\r\n    fiberMountStore.jumpToParent();\r\n    fiberMountStore.deepWalking.set(false);\r\n    shadow = shadow ? shadow.parent : null;\r\n    nextFiber = nextFiber.parent;\r\n    instance = nextFiber.instance;\r\n\r\n    if (hasChildrenProp(nextFiber.instance)) {\r\n      nextFiber.instance.children = [];\r\n    }\r\n  }\r\n\r\n  return {\r\n    performedFiber: null,\r\n    performedNextFiber: nextFiber,\r\n    performedShadow: shadow,\r\n    performedInstance: instance,\r\n  };\r\n}\r\n\r\ntype MutateFiberOptions = {\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction mutateFiber(options: MutateFiberOptions) {\r\n  const { fiber, alternate, instance } = options;\r\n  const key = alternate ? getElementKey(alternate.instance) : null;\r\n  const nextKey = alternate ? getElementKey(instance) : null;\r\n  const isDifferentKeys = key !== nextKey;\r\n  const isSameType = Boolean(alternate) && getInstanceType(alternate.instance) === getInstanceType(instance);\r\n  const isUpdate = isSameType && !isDifferentKeys;\r\n\r\n  fiber.instance = instance;\r\n  fiber.alternate = alternate || null;\r\n  fiber.nativeElement = isUpdate ? alternate.nativeElement : null;\r\n  fiber.effectTag = isUpdate ? EffectTag.UPDATE : EffectTag.CREATE;\r\n  fiber.mountedToHost = isUpdate;\r\n\r\n  if (hasChildrenProp(fiber.instance)) {\r\n    fiber.childrenCount = fiber.instance.children.length;\r\n  }\r\n\r\n  if (fiber.alternate) {\r\n    fiber.alternate.shadow = null;\r\n    fiber.alternate.alternate = null;\r\n  }\r\n\r\n  if (!fiber.nativeElement && detectIsVirtualNode(fiber.instance)) {\r\n    fiber.nativeElement = platform.createNativeElement(fiber.instance);\r\n  }\r\n}\r\n\r\ntype PerformAlternateOptions = {\r\n  alternate: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction mutateAlternate(options: PerformAlternateOptions) {\r\n  const { alternate, instance } = options;\r\n  const alternateType = getInstanceType(alternate.instance);\r\n  const elementType = getInstanceType(instance);\r\n  const isSameType = elementType === alternateType;\r\n  const prevKey = getElementKey(alternate.instance);\r\n  const nextKey = getElementKey(instance);\r\n  const isSameKeys = prevKey === nextKey;\r\n\r\n  alternate.isUsed = true;\r\n\r\n  if (!isSameType || !isSameKeys) {\r\n    alternate.effectTag = EffectTag.DELETE;\r\n    deletionsStore.get().push(alternate);\r\n  } else if (hasChildrenProp(alternate.instance) && hasChildrenProp(instance)) {\r\n    const prevElementsCount = alternate.childrenCount;\r\n    const nextElementsCount = instance.children.length;\r\n\r\n    if (prevElementsCount !== nextElementsCount) {\r\n      const children = hasChildrenProp(instance) ? instance.children : [];\r\n      const { prevKeys, nextKeys } = extractKeys(alternate.child, children);\r\n      const hasPrevKeys = prevKeys.length > 0;\r\n      const hasNextKeys = nextKeys.length > 0;\r\n      const hasAnyKeys = hasPrevKeys || hasNextKeys;\r\n\r\n      if (process.env.NODE_ENV === 'development') {\r\n        if (!hasAnyKeys && prevElementsCount !== 0 && nextElementsCount !== 0) {\r\n          error(`\r\n            [Dark]: Operation of inserting, adding, replacing elements into list requires to have a unique key for every node (string or number, but not array index)!\r\n          `);\r\n        }\r\n      }\r\n\r\n      const performRemoving = () => {\r\n        const diffKeys = getDiffKeys(prevKeys, nextKeys);\r\n\r\n        if (diffKeys.length > 0) {\r\n          const fibersMap = createFibersByKeyMap(alternate.child);\r\n\r\n          for (const key of diffKeys) {\r\n            const fiber = fibersMap[key] || null;\r\n\r\n            if (fiber) {\r\n              fiber.effectTag = EffectTag.DELETE;\r\n              deletionsStore.get().push(fiber);\r\n            }\r\n          }\r\n        } else {\r\n          const diffCount = prevElementsCount - nextElementsCount;\r\n          if (diffCount <= 0) return;\r\n          const fibers = fromEnd(getSiblingFibers(alternate.child), diffCount);\r\n\r\n          for (const fiber of fibers) {\r\n            fiber.effectTag = EffectTag.DELETE;\r\n          }\r\n\r\n          deletionsStore.get().push(...fibers);\r\n        }\r\n      };\r\n\r\n      const performInserting = () => {\r\n        const diffKeys = getDiffKeys(nextKeys, prevKeys);\r\n\r\n        if (diffKeys.length === 0 || diffKeys.length === nextKeys.length) return;\r\n\r\n        const diffKeyMap = keyBy(diffKeys, x => x);\r\n        const usedKeyMap = {};\r\n        let keyIdx = 0;\r\n\r\n        for (const nextKey of nextKeys) {\r\n          if (process.env.NODE_ENV === 'development') {\r\n            if (usedKeyMap[nextKey]) {\r\n              error(`Some key of node already has been used!`);\r\n            }\r\n          }\r\n\r\n          usedKeyMap[nextKey] = true;\r\n\r\n          if (nextKey !== prevKeys[keyIdx] && diffKeyMap[nextKey]) {\r\n            const insertionFiber = new Fiber({\r\n              instance: createEmptyVirtualNode(),\r\n              parent: alternate,\r\n              effectTag: EffectTag.CREATE,\r\n            });\r\n\r\n            if (keyIdx === 0) {\r\n              insertionFiber.nextSibling = alternate.child;\r\n              alternate.child = insertionFiber;\r\n            } else {\r\n              const [fiber, prevFiber] = getFibersByIdx(alternate.child, keyIdx);\r\n\r\n              if (fiber && prevFiber) {\r\n                insertionFiber.nextSibling = fiber;\r\n                prevFiber.nextSibling = insertionFiber;\r\n              }\r\n            }\r\n          }\r\n\r\n          keyIdx++;\r\n        }\r\n      };\r\n\r\n      performRemoving();\r\n      performInserting();\r\n    }\r\n  }\r\n}\r\n\r\ntype PerformMemoOptions = {\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction performMemo(options: PerformMemoOptions) {\r\n  const { fiber, alternate, instance } = options;\r\n\r\n  if (detectIsMemo(fiber.instance)) {\r\n    let memoFiber: Fiber = null;\r\n    const factory = instance as ComponentFactory;\r\n    const alternateFactory = alternate.instance as ComponentFactory;\r\n\r\n    if (factory.type !== alternateFactory.type) return fiber;\r\n\r\n    const props = alternateFactory.props;\r\n    const nextProps = factory.props;\r\n    const skip = !factory.shouldUpdate(props, nextProps);\r\n\r\n    if (skip) {\r\n      let nextFiber: Fiber = null;\r\n      fiberMountStore.deepWalking.set(false);\r\n\r\n      memoFiber = new Fiber({\r\n        ...alternate,\r\n        alternate,\r\n        effectTag: EffectTag.SKIP,\r\n        nextSibling: alternate.nextSibling\r\n          ? alternate.nextSibling.effectTag === EffectTag.DELETE\r\n            ? null\r\n            : alternate.nextSibling\r\n          : null,\r\n      });\r\n\r\n      alternate.alternate = null;\r\n      nextFiber = memoFiber.child;\r\n\r\n      while (nextFiber) {\r\n        nextFiber.parent = memoFiber;\r\n        nextFiber = nextFiber.nextSibling;\r\n      }\r\n\r\n      if (memoFiber.effectHost) {\r\n        fiber.markEffectHost();\r\n      }\r\n\r\n      if (memoFiber.layoutEffectHost) {\r\n        fiber.markLayoutEffectHost();\r\n      }\r\n\r\n      if (memoFiber.mountedToHost) {\r\n        fiber.markMountedToHost();\r\n      }\r\n\r\n      if (memoFiber.portalHost) {\r\n        fiber.markPortalHost();\r\n      }\r\n\r\n      return memoFiber;\r\n    }\r\n  }\r\n\r\n  return fiber;\r\n}\r\n\r\ntype PerformInstanceOptions = {\r\n  instance: DarkElementInstance;\r\n  idx: number;\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n};\r\n\r\nfunction pertformInstance(options: PerformInstanceOptions) {\r\n  const { instance, idx, fiber, alternate } = options;\r\n  let performedInstance: DarkElementInstance = null;\r\n  let performedShadow: Fiber = null;\r\n\r\n  if (hasChildrenProp(instance)) {\r\n    const elements = detectIsArray(instance.children[idx])\r\n      ? flatten([instance.children[idx]])\r\n      : [instance.children[idx]];\r\n\r\n    instance.children.splice(idx, 1, ...elements);\r\n    performedInstance = instance.children[idx];\r\n    performedShadow = alternate\r\n      ? getRootShadow({\r\n          instance: performedInstance,\r\n          fiber,\r\n          alternate,\r\n        })\r\n      : performedShadow;\r\n    performedInstance = mountInstance(fiber, performedInstance);\r\n  }\r\n\r\n  if (detectIsComponentFactory(performedInstance)) {\r\n    if (hasEffects(fiber)) {\r\n      fiber.markEffectHost();\r\n    }\r\n\r\n    if (hasLayoutEffects(fiber)) {\r\n      fiber.markLayoutEffectHost();\r\n    }\r\n\r\n    if (platform.detectIsPortal(performedInstance)) {\r\n      fiber.markPortalHost();\r\n    }\r\n  }\r\n\r\n  return {\r\n    performedInstance,\r\n    performedShadow,\r\n  };\r\n}\r\n\r\ntype GetRootShadowOptions = {\r\n  instance: DarkElementInstance;\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n};\r\n\r\nfunction getRootShadow(options: GetRootShadowOptions) {\r\n  const { instance, fiber, alternate } = options;\r\n  const key = getElementKey(alternate.instance);\r\n  const nextKey = getElementKey(instance);\r\n  let shadow: Fiber = null;\r\n\r\n  if (key !== nextKey) {\r\n    shadow = getAlternateByKey(nextKey, alternate.parent.child);\r\n\r\n    if (shadow) {\r\n      fiber.hook = shadow.hook;\r\n      fiber.provider = shadow.provider;\r\n      alternate.transposition = true;\r\n    }\r\n  }\r\n\r\n  return shadow;\r\n}\r\n\r\nfunction mountInstance(fiber: Fiber, instance: DarkElementInstance) {\r\n  const isComponentFactory = detectIsComponentFactory(instance);\r\n  const factory = instance as ComponentFactory;\r\n\r\n  if (isComponentFactory) {\r\n    try {\r\n      const result = factory.type(factory.props, factory.ref);\r\n\r\n      factory.children = detectIsArray(result)\r\n        ? (flatten([result]) as Array<DarkElementInstance>)\r\n        : ([result] as Array<DarkElementInstance>);\r\n    } catch (err) {\r\n      factory.children = [];\r\n      fiber.setError(err);\r\n      error(err);\r\n    }\r\n  } else if (detectIsVirtualNodeFactory(instance)) {\r\n    instance = instance();\r\n  }\r\n\r\n  if (hasChildrenProp(instance)) {\r\n    for (let i = 0; i < instance.children.length; i++) {\r\n      if (!instance.children[i]) {\r\n        instance.children[i] = transformElementInstance(instance.children[i]) as DarkElementInstance;\r\n      }\r\n    }\r\n\r\n    instance.children = isComponentFactory\r\n      ? instance.children\r\n      : detectIsArray(instance.children)\r\n      ? flatten([instance.children])\r\n      : [instance.children];\r\n\r\n    if (isComponentFactory && factory.children.length === 0) {\r\n      factory.children.push(createEmptyVirtualNode());\r\n    }\r\n  }\r\n\r\n  return instance;\r\n}\r\n\r\nfunction getFibersByIdx(fiber: Fiber, idx: number): [Fiber | null, Fiber | null] {\r\n  const map: Record<string, Fiber> = {};\r\n  let nextFiber = fiber;\r\n  let position = 0;\r\n\r\n  while (nextFiber) {\r\n    map[position] = nextFiber;\r\n\r\n    if (position === idx) {\r\n      return [map[position] || null, map[position - 1] || null];\r\n    }\r\n\r\n    position++;\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return [null, null];\r\n}\r\n\r\nfunction createFibersByKeyMap(fiber: Fiber) {\r\n  let nextFiber = fiber;\r\n  const map: Record<string, Fiber> = {};\r\n\r\n  while (nextFiber) {\r\n    const key = getElementKey(nextFiber.instance);\r\n\r\n    if (!detectIsEmpty(key)) {\r\n      map[key] = nextFiber;\r\n    }\r\n\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return map;\r\n}\r\n\r\nfunction extractKeys(alternate: Fiber, children: Array<DarkElementInstance>) {\r\n  let nextFiber = alternate;\r\n  let idx = 0;\r\n  const prevKeys: Array<DarkElementKey> = [];\r\n  const nextKeys: Array<DarkElementKey> = [];\r\n\r\n  while (nextFiber || idx < children.length) {\r\n    const key = nextFiber && getElementKey(nextFiber.instance);\r\n    const nextKey = children[idx] && getElementKey(children[idx]);\r\n\r\n    if (!detectIsEmpty(key)) {\r\n      prevKeys.push(key);\r\n    }\r\n\r\n    if (!detectIsEmpty(nextKey)) {\r\n      nextKeys.push(nextKey);\r\n    }\r\n\r\n    nextFiber = nextFiber ? nextFiber.nextSibling : null;\r\n    idx++;\r\n  }\r\n\r\n  return {\r\n    prevKeys,\r\n    nextKeys,\r\n  };\r\n}\r\n\r\nfunction getAlternateByKey(key: DarkElementKey, fiber: Fiber) {\r\n  if (detectIsEmpty(key)) return null;\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    if (key === getElementKey(nextFiber.instance)) {\r\n      return nextFiber;\r\n    }\r\n\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction getElementKey(instance: DarkElementInstance): DarkElementKey | null {\r\n  const key = detectIsComponentFactory(instance)\r\n    ? getComponentFactoryKey(instance)\r\n    : detectIsTagVirtualNode(instance)\r\n    ? getVirtualNodeKey(instance)\r\n    : null;\r\n\r\n  return key;\r\n}\r\n\r\nfunction getDiffKeys(keys: Array<DarkElementKey>, nextKeys: Array<DarkElementKey>): Array<DarkElementKey> {\r\n  const nextKeysMap = nextKeys.reduce((acc, key) => ((acc[key] = true), acc), {});\r\n  const diff = [];\r\n\r\n  for (const key of keys) {\r\n    if (!nextKeysMap[key]) {\r\n      diff.push(key);\r\n    }\r\n  }\r\n\r\n  return diff;\r\n}\r\n\r\nfunction getChildAlternate(fiber: Fiber): Fiber | null {\r\n  let alternate = fiber.alternate && fiber.alternate.effectTag !== EffectTag.DELETE ? fiber.alternate.child : null;\r\n\r\n  while (alternate && alternate.effectTag === EffectTag.DELETE) {\r\n    alternate = alternate.nextSibling;\r\n  }\r\n\r\n  return alternate;\r\n}\r\n\r\nfunction getNextSiblingAlternate(fiber: Fiber): Fiber | null {\r\n  let alternate = fiber.alternate?.nextSibling || null;\r\n\r\n  while (alternate && alternate.effectTag === EffectTag.DELETE) {\r\n    alternate = alternate.nextSibling;\r\n  }\r\n\r\n  return alternate;\r\n}\r\n\r\nfunction transformElementInstance(instance: DarkElement) {\r\n  return detectIsEmpty(instance) || instance === false ? createEmptyVirtualNode() : instance;\r\n}\r\n\r\nfunction getInstanceType(instance: DarkElementInstance): string | Function {\r\n  return detectIsTagVirtualNode(instance)\r\n    ? instance.name\r\n    : detectIsVirtualNode(instance)\r\n    ? instance.type\r\n    : detectIsComponentFactory(instance)\r\n    ? instance.type\r\n    : null;\r\n}\r\n\r\nfunction getSiblingFibers(fiber: Fiber): Array<Fiber> {\r\n  const list = [];\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    list.push(nextFiber);\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return list;\r\n}\r\n\r\nfunction hasChildrenProp(element: DarkElementInstance): element is TagVirtualNode | ComponentFactory {\r\n  return detectIsTagVirtualNode(element) || detectIsComponentFactory(element);\r\n}\r\n\r\nfunction commitChanges() {\r\n  const wipFiber = wipRootStore.get();\r\n\r\n  commitWork(wipFiber.child, () => {\r\n    const layoutEffects = layoutEffectsStore.get();\r\n    const effects = effectsStore.get();\r\n\r\n    isLayoutEffectsZone.set(true);\r\n    layoutEffects.forEach(fn => fn());\r\n    isLayoutEffectsZone.set(false);\r\n\r\n    setTimeout(() => {\r\n      effects.forEach(fn => fn());\r\n    });\r\n\r\n    wipRootStore.set(null); // important order\r\n    layoutEffectsStore.reset();\r\n    effectsStore.reset();\r\n\r\n    if (isUpdateHookZone.get()) {\r\n      isUpdateHookZone.set(false);\r\n    } else {\r\n      currentRootStore.set(wipFiber);\r\n    }\r\n  });\r\n}\r\n\r\nfunction commitWork(fiber: Fiber, onComplete: Function) {\r\n  const deletions = deletionsStore.get();\r\n\r\n  // important order\r\n  for (const fiber of deletions) {\r\n    unmountFiber(fiber);\r\n    platform.applyCommit(fiber);\r\n  }\r\n\r\n  walkFiber({\r\n    fiber,\r\n    onLoop: ({ nextFiber, isReturn, resetIsDeepWalking }) => {\r\n      const skip = nextFiber.effectTag === EffectTag.SKIP;\r\n\r\n      if (skip) {\r\n        resetIsDeepWalking();\r\n      } else if (!isReturn) {\r\n        platform.applyCommit(nextFiber);\r\n      }\r\n\r\n      if (nextFiber && nextFiber.shadow) {\r\n        nextFiber.shadow = null;\r\n      }\r\n    },\r\n  });\r\n\r\n  platform.finishCommitWork();\r\n  deletionsStore.set([]);\r\n  onComplete();\r\n}\r\n\r\nfunction createHook(): Hook {\r\n  return {\r\n    idx: 0,\r\n    values: [],\r\n  };\r\n}\r\n\r\ntype GetHookOptions = {\r\n  shadow: Fiber;\r\n  alternate: Fiber;\r\n  prevKey: DarkElementKey;\r\n  nextKey: DarkElementKey;\r\n};\r\n\r\nfunction getHook(options: GetHookOptions) {\r\n  const { shadow, alternate, prevKey, nextKey } = options;\r\n\r\n  if (shadow) return shadow.hook;\r\n  if (alternate && prevKey === nextKey) return alternate.hook;\r\n\r\n  return createHook();\r\n}\r\n\r\ntype CreateUpdateCallbackOptions = {\r\n  rootId: number;\r\n  fiber: Fiber;\r\n  forceStart?: boolean;\r\n  onStart: () => void;\r\n};\r\n\r\nfunction createUpdateCallback(options: CreateUpdateCallbackOptions) {\r\n  const { rootId, fiber, forceStart = false, onStart } = options;\r\n  const callback = () => {\r\n    forceStart && onStart();\r\n    if (fiber.isUsed) return;\r\n    !forceStart && onStart();\r\n    rootStore.set(rootId); // important order!\r\n    isUpdateHookZone.set(true);\r\n    fiberMountStore.reset();\r\n\r\n    fiber.alternate = new Fiber({\r\n      ...fiber,\r\n      alternate: null,\r\n    });\r\n    fiber.marker = PARTIAL_UPDATE;\r\n    fiber.effectTag = EffectTag.UPDATE;\r\n    fiber.child = null;\r\n\r\n    wipRootStore.set(fiber);\r\n    currentFiberStore.set(fiber);\r\n    fiber.instance = mountInstance(fiber, fiber.instance);\r\n    nextUnitOfWorkStore.set(fiber);\r\n  };\r\n\r\n  return callback;\r\n}\r\n\r\nexport { Fiber, workLoop, createHook, hasChildrenProp, createUpdateCallback };\r\n","import { type Fiber } from '../fiber';\r\nimport { isBatchZone } from '../scope';\r\nimport { platform } from '../platform';\r\n\r\nfunction batch(callback: () => void) {\r\n  isBatchZone.set(true);\r\n  callback();\r\n}\r\n\r\nfunction runBatch(fiber: Fiber, callback: () => void) {\r\n  fiber.batched.push(callback);\r\n\r\n  const update = () => {\r\n    const size = fiber.batched.length;\r\n\r\n    platform.requestAnimationFrame(() => {\r\n      if (size === fiber.batched.length) {\r\n        const fn = fiber.batched[fiber.batched.length - 1];\r\n\r\n        isBatchZone.set(false);\r\n        fiber.batched = [];\r\n        fn && fn();\r\n      } else {\r\n        update();\r\n      }\r\n    });\r\n  };\r\n\r\n  update();\r\n}\r\n\r\nexport { batch, runBatch };\r\n","import { platform, type ScheduleCallbackOptions } from '../platform';\r\nimport { getRootId, currentFiberStore, isLayoutEffectsZone, isBatchZone } from '../scope';\r\nimport { createUpdateCallback } from '../fiber';\r\nimport { useMemo } from '../use-memo';\r\nimport { dummyFn } from '../helpers';\r\nimport { runBatch as batch } from '../batch';\r\n\r\nfunction useUpdate(options?: ScheduleCallbackOptions) {\r\n  const rootId = getRootId();\r\n  const fiber = currentFiberStore.get();\r\n  const scope = useMemo(() => ({ fiber }), []);\r\n\r\n  scope.fiber = fiber;\r\n\r\n  const update = (onStart?: () => void) => {\r\n    const callback = createUpdateCallback({\r\n      rootId,\r\n      fiber: scope.fiber,\r\n      forceStart: Boolean(options?.timeoutMs),\r\n      onStart: onStart || dummyFn,\r\n    });\r\n\r\n    if (isLayoutEffectsZone.get()) {\r\n      options = {\r\n        ...(options || {}),\r\n        forceSync: true,\r\n      };\r\n    }\r\n\r\n    if (isBatchZone.get()) {\r\n      batch(scope.fiber, () => platform.scheduleCallback(callback, options));\r\n    } else {\r\n      platform.scheduleCallback(callback, options);\r\n    }\r\n  };\r\n\r\n  return update;\r\n}\r\n\r\nexport { useUpdate };\r\n","import { useEffect } from '../use-effect';\r\nimport { useMemo } from '../use-memo';\r\nimport { currentFiberStore } from '../scope';\r\nimport { useUpdate } from '../use-update';\r\nimport type { Fiber } from '../fiber';\r\nimport type { Context, ContextProviderValue } from '../context';\r\n\r\nfunction useContext<T>(context: Context<T>): T {\r\n  const { defaultValue } = context;\r\n  const fiber = currentFiberStore.get();\r\n  const provider = getProvider<T>(context, fiber);\r\n  const value = provider ? provider.value : defaultValue;\r\n  const update = useUpdate();\r\n  const scope = useMemo(() => ({ prevValue: value }), []);\r\n  const hasProvider = Boolean(provider);\r\n\r\n  useEffect(() => {\r\n    if (!hasProvider) return;\r\n\r\n    const subscriber = (newValue: T) => {\r\n      if (!Object.is(scope.prevValue, newValue)) {\r\n        update();\r\n      }\r\n    };\r\n\r\n    provider.subscribers.push(subscriber);\r\n\r\n    return () => {\r\n      const idx = provider.subscribers.findIndex(x => x === subscriber);\r\n\r\n      if (idx !== -1) {\r\n        provider.subscribers.splice(idx, 1);\r\n      }\r\n    };\r\n  }, [hasProvider]);\r\n\r\n  scope.prevValue = value;\r\n\r\n  return value;\r\n}\r\n\r\nfunction getProvider<T>(context: Context<T>, fiber: Fiber): ContextProviderValue<T> {\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    if (nextFiber.provider && nextFiber.provider.get(context)) {\r\n      return nextFiber.provider.get(context) as ContextProviderValue<T>;\r\n    }\r\n\r\n    nextFiber = nextFiber.parent;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { useContext };\r\n","import { createComponent } from '../component';\r\nimport { useEffect } from '../use-effect';\r\nimport { currentFiberStore } from '../scope';\r\nimport { useContext } from '../use-context';\r\nimport { detectIsFunction } from '../helpers';\r\nimport type { Context, ContexProviderProps } from './types';\r\n\r\nfunction createContext<T>(defaultValue: T): Context<T> {\r\n  let displayName = 'Context';\r\n  const context: Context<T> = {\r\n    displayName,\r\n    defaultValue,\r\n    Provider: null,\r\n    Consumer: null,\r\n  };\r\n\r\n  mutateContext(context, defaultValue, displayName);\r\n\r\n  Object.defineProperty(context, 'displayName', {\r\n    get: () => displayName,\r\n    set: (newValue: string) => {\r\n      displayName = newValue;\r\n      mutateContext(context, defaultValue, displayName);\r\n    },\r\n  });\r\n\r\n  return context;\r\n}\r\n\r\nfunction mutateContext<T>(context: Context<T>, defaultValue: T, displayName: string) {\r\n  context.Provider = createProvider(context, defaultValue, displayName);\r\n  context.Consumer = createConsumer(context, displayName);\r\n}\r\n\r\nfunction createProvider<T>(context: Context<T>, defaultValue: T, displayName: string) {\r\n  return createComponent<ContexProviderProps<T>>(\r\n    ({ value = defaultValue, slot }) => {\r\n      const fiber = currentFiberStore.get();\r\n\r\n      if (!fiber.provider) {\r\n        fiber.provider = new Map();\r\n      }\r\n\r\n      if (!fiber.provider.get(context)) {\r\n        fiber.provider.set(context, {\r\n          subscribers: [],\r\n          value,\r\n        });\r\n      }\r\n\r\n      const provider = fiber.provider.get(context);\r\n\r\n      useEffect(() => {\r\n        for (const subscriber of provider.subscribers) {\r\n          subscriber(value);\r\n        }\r\n      }, [value]);\r\n\r\n      provider.value = value;\r\n\r\n      return slot;\r\n    },\r\n    { displayName: `${displayName}.Provider` },\r\n  );\r\n}\r\n\r\nfunction createConsumer<T>(context: Context<T>, displayName: string) {\r\n  return createComponent(\r\n    ({ slot }) => {\r\n      const value = useContext(context);\r\n\r\n      return detectIsFunction(slot) ? slot(value) : null;\r\n    },\r\n    { displayName: `${displayName}.Consumer` },\r\n  );\r\n}\r\n\r\nexport { createContext };\r\n","import { detectIsNumber, detectIsString, detectIsFunction } from '../helpers';\r\nimport { View, Text, type TagVirtualNodeFactory } from '../view';\r\n\r\nfunction getChildren(children: Array<any>) {\r\n  children = children.map(x => (detectIsString(x) || detectIsNumber(x) ? Text(x.toString()) : x));\r\n\r\n  return children ? (Array.isArray(children) ? [...children] : [children]) : [];\r\n}\r\n\r\nfunction createElement(\r\n  tag: string | Function,\r\n  props: any,\r\n  ...children: Array<any>\r\n): TagVirtualNodeFactory | Function | null {\r\n  if (detectIsString(tag)) {\r\n    return View({\r\n      ...props,\r\n      as: tag,\r\n      slot: getChildren(children),\r\n    });\r\n  }\r\n\r\n  if (detectIsFunction(tag)) {\r\n    let slot = getChildren(children);\r\n\r\n    slot = slot.length === 1 ? slot[0] : slot;\r\n\r\n    return tag({ ...props, slot });\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { createElement };\r\n","import { useMemo } from '../use-memo';\r\n\r\nfunction useCallback<T = Function>(callback: T, deps: Array<any>): T {\r\n  const value = useMemo(() => callback, deps);\r\n\r\n  return value;\r\n}\r\n\r\nexport { useCallback };\r\n","import { type ScheduleCallbackOptions } from '../platform';\r\nimport { detectIsUndefined, detectIsFunction } from '../helpers';\r\nimport { currentFiberStore } from '../scope';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\nimport { TaskPriority } from '../constants';\r\n\r\ntype Value<T> = T | ((prevValue: T) => T);\r\ntype Scope = {\r\n  idx: number;\r\n  values: Array<any>;\r\n};\r\n\r\nfunction useState<T = unknown>(initialValue: T, options?: ScheduleCallbackOptions): [T, (value: Value<T>) => void] {\r\n  const fiber = currentFiberStore.get();\r\n  const update = useUpdate(options);\r\n  const scope: Scope = useMemo(\r\n    () => ({\r\n      idx: fiber.hook.idx,\r\n      values: fiber.hook.values,\r\n    }),\r\n    [],\r\n  );\r\n  const setState = useCallback((sourceValue: Value<T>) => {\r\n    const value = scope.values[scope.idx];\r\n    const newValue = detectIsFunction(sourceValue) ? sourceValue(value) : sourceValue;\r\n\r\n    if (!Object.is(value, newValue)) {\r\n      const setValue = () => {\r\n        scope.values[scope.idx] = newValue;\r\n      };\r\n\r\n      if (options?.priority === TaskPriority.LOW) {\r\n        update(() => setValue());\r\n      } else {\r\n        setValue();\r\n        update();\r\n      }\r\n    }\r\n  }, []);\r\n  const { hook } = fiber;\r\n  const { idx, values } = hook;\r\n  const value: T = !detectIsUndefined(values[idx]) ? values[idx] : initialValue;\r\n\r\n  values[idx] = value;\r\n  scope.idx = idx;\r\n  scope.values = values;\r\n  hook.idx++;\r\n\r\n  return [value, setState];\r\n}\r\n\r\nexport { useState };\r\n","import { createComponent } from '../component';\r\nimport { useState } from '../use-state';\r\nimport { createContext } from '../context';\r\nimport { useContext } from '../use-context';\r\nimport { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\nimport type { DarkElement } from '../shared';\r\n\r\ntype SuspenseProps = {\r\n  fallback: DarkElement;\r\n};\r\n\r\ntype SuspenseContextValue = {\r\n  fallback: DarkElement;\r\n  isLoaded: boolean;\r\n  trigger: () => void;\r\n};\r\n\r\nconst SuspenseContext = createContext<SuspenseContextValue>({\r\n  fallback: null,\r\n  isLoaded: true,\r\n  trigger: () => {},\r\n});\r\n\r\nconst Suspense = createComponent<SuspenseProps>(({ fallback, slot }) => {\r\n  if (!fallback) {\r\n    throw new Error(`[Dark]: Suspense fallback not found`);\r\n  }\r\n  const { isLoaded: isSuspenseLoaded } = useContext(SuspenseContext);\r\n  const [isLoaded, setIsLoaded] = useState(false);\r\n  const trigger = useCallback(() => setIsLoaded(true), []);\r\n  const value = useMemo(() => ({ fallback, isLoaded, trigger }), [fallback, isLoaded]);\r\n\r\n  return SuspenseContext.Provider({\r\n    value,\r\n    slot: isSuspenseLoaded ? slot : null,\r\n  });\r\n});\r\n\r\nexport { SuspenseContext, Suspense };\r\n","import { type Component, createComponent, detectIsComponentFactory } from '../component';\r\nimport { useState } from '../use-state';\r\nimport { useEffect } from '../use-effect';\r\nimport { forwardRef } from '../ref';\r\nimport { SuspenseContext } from '../suspense';\r\nimport { useContext } from '../use-context';\r\n\r\nconst $$lazy = Symbol('lazy');\r\n\r\ntype LazyScope<P, R> = {\r\n  component: Component<P, R>;\r\n};\r\n\r\nfunction lazy<P, R = unknown>(dynamic: () => Promise<{ default: Component<P> }>) {\r\n  return forwardRef(\r\n    createComponent<P, R>(\r\n      (props, ref) => {\r\n        const { fallback, trigger } = useContext(SuspenseContext);\r\n        const [scope, setScope] = useState<LazyScope<P, R>>({\r\n          component: null,\r\n        });\r\n\r\n        useEffect(() => {\r\n          fetchModule(dynamic).then(component => {\r\n            setScope({ component });\r\n          });\r\n        }, []);\r\n\r\n        useEffect(() => {\r\n          if (!scope.component) return;\r\n          trigger();\r\n        }, [scope.component]);\r\n\r\n        return scope.component ? scope.component(props, ref) : fallback;\r\n      },\r\n      { token: $$lazy },\r\n    ),\r\n  );\r\n}\r\n\r\nconst detectIsLazy = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$lazy;\r\n\r\nfunction fetchModule(dynamic: () => Promise<{ default: Component }>) {\r\n  return new Promise<Component>(resolve => {\r\n    dynamic().then(module => {\r\n      if (!module.default) {\r\n        throw new Error('[Dark]: lazy loaded component should be exported as default!');\r\n      }\r\n\r\n      resolve(module.default);\r\n    });\r\n  });\r\n}\r\n\r\nexport { lazy, detectIsLazy };\r\n","import { useState } from '../use-state';\r\nimport { useEffect } from '../use-effect';\r\nimport { TaskPriority } from '../constants';\r\n\r\ntype UseDeferredValueOprions = {\r\n  timeoutMs: number;\r\n};\r\n\r\nfunction useDeferredValue<T>(value: T, options?: UseDeferredValueOprions): T {\r\n  const { timeoutMs } = options || {};\r\n  const [deferredValue, setDeferredValue] = useState(value, {\r\n    priority: TaskPriority.LOW,\r\n    timeoutMs,\r\n  });\r\n\r\n  useEffect(() => {\r\n    setDeferredValue(value);\r\n  }, [value]);\r\n\r\n  return deferredValue;\r\n}\r\n\r\nexport { useDeferredValue };\r\n","import { currentFiberStore } from '../scope';\r\nimport { useEffect } from '../use-effect';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\n\r\ntype ErrorScope = {\r\n  error: Error;\r\n};\r\n\r\nfunction useError(): Error | null {\r\n  const fiber = currentFiberStore.get();\r\n  const update = useUpdate();\r\n  const scope: ErrorScope = useMemo(() => ({ error: null }), []);\r\n\r\n  fiber.catchException = (error: Error) => {\r\n    scope.error = error;\r\n    update();\r\n  };\r\n\r\n  useEffect(() => {\r\n    scope.error = null;\r\n  }, [scope.error]);\r\n\r\n  return scope.error;\r\n}\r\n\r\nexport { useError };\r\n","import { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\n\r\nfunction useEvent<T extends (...args) => any>(fn: T) {\r\n  const scope = useMemo(() => ({ fn }), []);\r\n\r\n  scope.fn = fn;\r\n\r\n  const callback = useCallback((...args) => {\r\n    return scope.fn(...args);\r\n  }, []);\r\n\r\n  return callback as unknown as T;\r\n}\r\n\r\nexport { useEvent };\r\n","import { useMemo } from '../use-memo';\r\nimport type { MutableRef } from '../ref';\r\n\r\nfunction useImperativeHandle<T>(ref: MutableRef<T>, createHandle: () => T, deps: Array<any>) {\r\n  const current = useMemo(() => createHandle(), deps);\r\n\r\n  ref.current = current;\r\n}\r\n\r\nexport { useImperativeHandle };\r\n","import { useState } from '../use-state';\r\nimport { useCallback } from '../use-callback';\r\nimport { useMemo } from '../use-memo';\r\nimport { detectIsFunction } from '../helpers';\r\nimport type { Reducer, Dispatch, ReducerAction, ReducerState } from './types';\r\n\r\nfunction useReducer<R extends Reducer>(\r\n  reducer: R,\r\n  initialState: ReducerState<R>,\r\n  initializer?: (state: ReducerState<R>) => ReducerState<R>,\r\n): [ReducerState<R>, Dispatch<ReducerAction<R>>] {\r\n  const initialValue = useMemo(() => {\r\n    return detectIsFunction(initializer) ? initializer(initialState) : initialState;\r\n  }, []);\r\n  const [state, setState] = useState<ReducerState<R>>(initialValue);\r\n  const dispatch = useCallback((action: ReducerAction<R>) => setState(state => reducer(state, action)), []) as Dispatch<\r\n    ReducerAction<R>\r\n  >;\r\n\r\n  return [state, dispatch];\r\n}\r\n\r\nexport { useReducer };\r\n","import { useMemo } from '../use-memo';\r\nimport type { MutableRef } from '../ref';\r\n\r\nfunction useRef<T>(initialValue: T = null): MutableRef<T> {\r\n  const ref = useMemo(() => ({ current: initialValue }), []) as MutableRef<T>;\r\n\r\n  return ref;\r\n}\r\n\r\nexport { useRef };\r\n","/* eslint-disable @typescript-eslint/no-namespace */\r\nexport * from './component';\r\nexport * from './context';\r\nexport { createElement as h } from './element';\r\nexport * from './fiber';\r\nexport * from './fragment';\r\nexport * from './platform';\r\nexport * from './helpers';\r\nexport * from './lazy';\r\nexport * from './memo';\r\nexport * from './ref';\r\nexport * from './scope';\r\nexport * from './shared';\r\nexport * from './suspense';\r\nexport * from './use-callback';\r\nexport * from './use-context';\r\nexport * from './use-deferred-value';\r\nexport { useEffect } from './use-effect';\r\nexport * from './use-error';\r\nexport * from './use-event';\r\nexport * from './use-imperative-handle';\r\nexport { useLayoutEffect } from './use-layout-effect';\r\nexport * from './use-memo';\r\nexport * from './use-reducer';\r\nexport * from './use-ref';\r\nexport * from './use-state';\r\nexport * from './use-update';\r\nexport * from './view';\r\nexport * from './constants';\r\nexport { walkFiber } from './walk';\r\nexport { unmountRoot } from './unmount';\r\nexport { batch } from './batch';\r\n\r\nexport const version = process.env.VERSION;\r\n\r\ndeclare global {\r\n  namespace JSX {\r\n    interface ElementChildrenAttribute {\r\n      slot: {};\r\n    }\r\n  }\r\n}\r\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ROOT","EMPTY_NODE","ATTR_KEY","ATTR_REF","PARTIAL_UPDATE","TaskPriority","detectIsFunction","detectIsUndefined","detectIsNumber","detectIsString","detectIsObject","detectIsBoolean","detectIsArray","Array","isArray","detectIsNull","detectIsEmpty","error","str","console","flatten","source","list","levelMap","idx","level","item","length","push","getTime","Date","now","keyBy","fn","reduce","acc","x","fromEnd","count","slice","dummyFn","detectIsDepsDifferent","deps","prevDeps","i","defaultOptions","displayName","defaultProps","token","ComponentFactory","type","props","ref","children","shouldUpdate","constructor","options","this","createComponent","createElement","computedOptions","computedProps","detectIsComponentFactory","getComponentFactoryKey","rootId","stores","Map","Store","wipRoot","currentRoot","nextUnitOfWork","events","unsubscribers","deletions","fiberMount","navigation","isDeepWalking","componentFiber","effects","layoutEffects","isLayoutEffectsZone","isUpdateHookZone","isBatchZone","trackUpdate","rootStore","set","id","remove","delete","getRootId","store","wipRootStore","fiber","currentRootStore","nextUnitOfWorkStore","currentFiberStore","eventsStore","addUnsubscriber","unsubscribe","forEach","deletionsStore","fiberMountStore","reset","getIndex","jumpToChild","nextLevel","jumpToParent","jumpToSibling","deepWalking","effectsStore","add","effect","layoutEffectsStore","$$useEffect","useEffect","hasEffects","dropEffects","createEffect","hook","values","runEffect","undefined","cleanup","some","NodeType","$$virtualNode","VirtualNode","TagVirtualNode","TAG","name","isVoid","attrs","super","TextVirtualNode","TEXT","text","CommentVirtualNode","COMMENT","detectIsVirtualNode","vNode","detectIsTagVirtualNode","detectIsCommentVirtualNode","detectIsTextVirtualNode","detectIsEmptyVirtualNode","getVirtualNodeKey","createEmptyVirtualNode","detectIsVirtualNodeFactory","View","def","as","slot","rest","Text","Comment","$$fragment","Fragment","detectIsFragment","forwardRef","component","detectIsMutableRef","mutableRef","$$memo","defaultShouldUpdate","nextProps","keys","detectIsMemo","memo","Memo","processValue","getValue","isDepsDifferent","check","wrap","useMemo","hookValue","computedGetValue","platform","createNativeElement","Error","requestAnimationFrame","scheduleCallback","shouldYeildToHost","applyCommit","finishCommitWork","detectIsPortal","unmountPortal","EffectTag","cloneTagMap","CREATE","SKIP","$$useLayoutEffect","useLayoutEffect","hasLayoutEffects","dropLayoutEffects","walkFiber","onLoop","nextFiber","isReturn","isStopped","visitedMap","detectCanVisit","resetIsDeepWalking","stop","child","newFiber","nextSibling","parent","unmountFiber","effectHost","layoutEffectHost","portalHost","transposition","instance","unmountRoot","onComplete","Fiber","nativeElement","alternate","effectTag","shadow","provider","mountedToHost","childrenCount","marker","isUsed","batched","catchException","markPortalHost","markEffectHost","markLayoutEffectHost","markMountedToHost","setError","workLoop","wipFiber","shouldYield","hasMoreWork","Boolean","performUnitOfWork","setTimeout","commitWork","commitChanges","hasChildrenProp","performedFiber","performedNextFiber","performedShadow","performedInstance","performChild","performSibling","performPartialUpdateEffects","DELETE","getChildAlternate","sourceInstance","prevKey","getElementKey","nextKey","getHook","pertformInstance","mutateAlternate","mutateFiber","performMemo","childrenIdx","getNextSiblingAlternate","isDifferentKeys","isUpdate","getInstanceType","UPDATE","alternateType","isSameType","isSameKeys","prevElementsCount","nextElementsCount","prevKeys","nextKeys","extractKeys","performInserting","diffKeys","getDiffKeys","diffKeyMap","usedKeyMap","keyIdx","insertionFiber","prevFiber","getFibersByIdx","fibersMap","map","createFibersByKeyMap","diffCount","fibers","getSiblingFibers","performRemoving","memoFiber","alternateFactory","elements","splice","getAlternateByKey","getRootShadow","mountInstance","isComponentFactory","result","err","transformElementInstance","position","nextKeysMap","diff","element","createHook","createUpdateCallback","forceStart","onStart","batch","callback","useUpdate","scope","timeoutMs","forceSync","update","size","useContext","context","defaultValue","getProvider","prevValue","hasProvider","subscriber","newValue","is","subscribers","findIndex","createContext","Provider","Consumer","mutateContext","createProvider","createConsumer","getChildren","toString","tag","useCallback","useState","initialValue","setState","sourceValue","setValue","priority","LOW","SuspenseContext","fallback","isLoaded","trigger","Suspense","isSuspenseLoaded","setIsLoaded","$$lazy","lazy","dynamic","setScope","Promise","resolve","then","default","fetchModule","detectIsLazy","useDeferredValue","deferredValue","setDeferredValue","useError","useEvent","args","useImperativeHandle","createHandle","current","useReducer","reducer","initialState","initializer","state","dispatch","action","useRef","version"],"sourceRoot":""}