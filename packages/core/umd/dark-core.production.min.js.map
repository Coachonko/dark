{"version":3,"file":"dark-core.production.min.js","mappings":"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","sources":["webpack://DarkCore/webpack/universalModuleDefinition","webpack://DarkCore/webpack/bootstrap","webpack://DarkCore/webpack/runtime/define property getters","webpack://DarkCore/webpack/runtime/hasOwnProperty shorthand","webpack://DarkCore/webpack/runtime/make namespace object","webpack://DarkCore/./src/constants.ts","webpack://DarkCore/./src/helpers/index.ts","webpack://DarkCore/./src/component/component.ts","webpack://DarkCore/./src/view/types.ts","webpack://DarkCore/./src/scope/scope.ts","webpack://DarkCore/./src/use-effect/use-effect.ts","webpack://DarkCore/./src/view/view.ts","webpack://DarkCore/./src/fragment/fragment.ts","webpack://DarkCore/./src/ref/ref.ts","webpack://DarkCore/./src/memo/memo.ts","webpack://DarkCore/./src/use-memo/use-memo.ts","webpack://DarkCore/./src/platform/platform.ts","webpack://DarkCore/./src/fiber/types.ts","webpack://DarkCore/./src/use-layout-effect/use-layout-effect.ts","webpack://DarkCore/./src/walk/walk.ts","webpack://DarkCore/./src/unmount/unmount.ts","webpack://DarkCore/./src/fiber/fiber.ts","webpack://DarkCore/./src/use-update/use-update.ts","webpack://DarkCore/./src/use-context/use-context.ts","webpack://DarkCore/./src/context/context.ts","webpack://DarkCore/./src/element/element.ts","webpack://DarkCore/./src/use-callback/use-callback.ts","webpack://DarkCore/./src/use-state/use-state.ts","webpack://DarkCore/./src/suspense/suspense.ts","webpack://DarkCore/./src/lazy/lazy.ts","webpack://DarkCore/./src/use-deferred-value/use-deferred-value.ts","webpack://DarkCore/./src/use-error/use-error.ts","webpack://DarkCore/./src/use-event/use-event.ts","webpack://DarkCore/./src/use-imperative-handle/use-imperative-handle.ts","webpack://DarkCore/./src/use-reducer/use-reducer.ts","webpack://DarkCore/./src/use-ref/use-ref.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"DarkCore\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"DarkCore\"] = factory();\n\telse\n\t\troot[\"DarkCore\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const ROOT = 'root';\r\nexport const EMPTY_NODE = 'dark:matter';\r\nexport const ATTR_KEY = 'key';\r\nexport const ATTR_REF = 'ref';\r\nexport const PARTIAL_UPDATE = 'partial-update';\r\n\r\nexport enum TaskPriority {\r\n  HIGH = 2,\r\n  NORMAL = 1,\r\n  LOW = 0,\r\n}\r\n","import type { NestedArray } from '../shared';\r\n\r\nconst detectIsFunction = (o: any): o is Function => typeof o === 'function';\r\nconst detectIsUndefined = (o: any) => typeof o === 'undefined';\r\nconst detectIsNumber = (o: any) => typeof o === 'number';\r\nconst detectIsString = (o: any) => typeof o === 'string';\r\nconst detectIsObject = (o: any) => typeof o === 'object';\r\nconst detectIsBoolean = (o: any) => typeof o === 'boolean';\r\nconst detectIsArray = (o: any): o is Array<any> => Array.isArray(o);\r\nconst detectIsNull = (o: any) => o === null;\r\nconst detectIsEmpty = (o: any) => detectIsNull(o) || detectIsUndefined(o);\r\n\r\nfunction error(str: string) {\r\n  !detectIsUndefined(console) && console.error(str);\r\n}\r\n\r\nfunction flatten<T = any>(source: Array<NestedArray<T>>): Array<T> {\r\n  const list = [];\r\n  const levelMap = { 0: { idx: 0, source } };\r\n  let level = 0;\r\n\r\n  do {\r\n    const { source, idx } = levelMap[level];\r\n    const item = source[idx];\r\n\r\n    if (idx >= source.length) {\r\n      level--;\r\n      levelMap[level].idx++;\r\n      continue;\r\n    }\r\n\r\n    if (detectIsArray(item)) {\r\n      level++;\r\n      levelMap[level] = {\r\n        idx: 0,\r\n        source: item,\r\n      };\r\n    } else {\r\n      list.push(item);\r\n      levelMap[level].idx++;\r\n    }\r\n  } while (level > 0 || levelMap[level].idx < levelMap[level].source.length);\r\n\r\n  return list;\r\n}\r\n\r\nfunction getTime() {\r\n  return Date.now();\r\n}\r\n\r\nfunction keyBy<T = any>(\r\n  list: Array<T>,\r\n  fn: (o: T) => string | number,\r\n  value = false,\r\n): Record<string | number, T | boolean> {\r\n  return list.reduce((acc, x) => ((acc[fn(x)] = value ? x : true), acc), {});\r\n}\r\n\r\nfunction takeListFromEnd<T>(source: Array<T>, count: number) {\r\n  return source.slice(source.length - count, source.length);\r\n}\r\n\r\nconst dummyFn = () => {};\r\n\r\nfunction detectIsDepsDifferent(deps: Array<unknown>, prevDeps: Array<unknown>): boolean {\r\n  if (!detectIsUndefined(deps) && !detectIsUndefined(prevDeps) && deps.length > 0 && prevDeps.length > 0) {\r\n    for (let i = 0; i < prevDeps.length; i++) {\r\n      if (prevDeps[i] !== deps[i]) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport {\r\n  detectIsFunction,\r\n  detectIsUndefined,\r\n  detectIsNumber,\r\n  detectIsString,\r\n  detectIsObject,\r\n  detectIsBoolean,\r\n  detectIsArray,\r\n  detectIsNull,\r\n  detectIsEmpty,\r\n  error,\r\n  flatten,\r\n  getTime,\r\n  keyBy,\r\n  takeListFromEnd,\r\n  dummyFn,\r\n  detectIsDepsDifferent,\r\n};\r\n","import { ATTR_KEY } from '../constants';\r\nimport { error, detectIsEmpty } from '../helpers';\r\nimport type { DarkElementKey, DarkElementInstance } from '../shared';\r\nimport type { MutableRef } from '../ref';\r\nimport type { CreateElement, ComponentOptions, StandardComponentProps, SlotProps } from './types';\r\n\r\nconst $$component = Symbol('component');\r\nconst defaultOptions: ComponentOptions<any> = {\r\n  displayName: '',\r\n  defaultProps: {},\r\n  token: $$component,\r\n};\r\nclass ComponentFactory<P extends StandardComponentProps = any, R = any> {\r\n  public type: CreateElement<P>;\r\n  public token: Symbol;\r\n  public props: P;\r\n  public ref: MutableRef<R>;\r\n  public displayName: string;\r\n  public children: Array<DarkElementInstance> = [];\r\n  public shouldUpdate?: (props: P, nextProps: P) => boolean;\r\n\r\n  constructor(options: ComponentFactory<P>) {\r\n    this.type = options.type || null;\r\n    this.token = options.token || null;\r\n    this.props = options.props || null;\r\n    this.ref = options.ref || null;\r\n    this.displayName = options.displayName || '';\r\n    this.shouldUpdate = options.shouldUpdate || null;\r\n  }\r\n}\r\n\r\nfunction createComponent<P, R = any>(\r\n  createElement: CreateElement<P & SlotProps, R>,\r\n  options: ComponentOptions<P> = {},\r\n) {\r\n  type Props = P & StandardComponentProps;\r\n  const computedOptions = { ...defaultOptions, ...options };\r\n  const { token, defaultProps, displayName, shouldUpdate } = computedOptions;\r\n\r\n  return (props = {} as Props, ref?: MutableRef<R>): ComponentFactory<Props> => {\r\n    const computedProps = { ...defaultProps, ...props };\r\n    const factory = new ComponentFactory({\r\n      token,\r\n      ref,\r\n      displayName,\r\n      shouldUpdate,\r\n      props: computedProps,\r\n      type: createElement,\r\n      children: [],\r\n    });\r\n\r\n    if (computedProps.ref) {\r\n      delete computedProps.ref;\r\n\r\n      if (process.env.NODE_ENV === 'development') {\r\n        error(`[Dark]: To use ref you need to wrap the createComponent with forwardRef!`);\r\n      }\r\n    }\r\n\r\n    return factory;\r\n  };\r\n}\r\n\r\nconst detectIsComponentFactory = (factory: unknown): factory is ComponentFactory => factory instanceof ComponentFactory;\r\n\r\nconst getComponentFactoryKey = (factory: ComponentFactory): DarkElementKey =>\r\n  !detectIsEmpty(factory.props[ATTR_KEY]) ? factory.props[ATTR_KEY] : null;\r\n\r\nexport { ComponentFactory, createComponent, detectIsComponentFactory, getComponentFactoryKey };\r\n","export type ViewDef = {\r\n  as: string;\r\n  slot?: any;\r\n  isVoid?: boolean;\r\n  [prop: string]: any;\r\n};\r\n\r\nexport enum NodeType {\r\n  TAG = 'TAG',\r\n  TEXT = 'TEXT',\r\n  COMMENT = 'COMMENT',\r\n}\r\n","import type { Fiber } from '../fiber';\r\n\r\nclass Store {\r\n  public wipRoot: Fiber = null;\r\n  public currentRoot: Fiber = null;\r\n  public nextUnitOfWork: Fiber = null;\r\n  public fromHookUpdate = false;\r\n  public events: Map<string, WeakMap<object, Function>> = new Map();\r\n  public unsubscribers: Array<() => void> = [];\r\n  public deletions: Array<Fiber> = [];\r\n  public fiberMount = {\r\n    level: 0,\r\n    navigation: {},\r\n    isDeepWalking: true,\r\n  };\r\n  public componentFiber: Fiber = null;\r\n  public effects: Array<() => void> = [];\r\n  public layoutEffects: Array<() => void> = [];\r\n}\r\n\r\nlet rootId = null;\r\nconst stores = new Map<number, Store>();\r\n\r\nconst effectStoreHelper = {\r\n  set: (id: number) => effectStore(id),\r\n  remove: (id: number) => stores.delete(id),\r\n};\r\n\r\nconst getRootId = (): number => rootId;\r\n\r\nconst effectStore = (id: number) => {\r\n  rootId = id;\r\n  !stores.get(rootId) && stores.set(rootId, new Store());\r\n};\r\n\r\nconst storeHelper = {\r\n  get: (id: number = rootId) => stores.get(id),\r\n};\r\n\r\nconst wipRootHelper = {\r\n  get: () => storeHelper.get()?.wipRoot || null,\r\n  set: (fiber: Fiber) => (storeHelper.get().wipRoot = fiber),\r\n};\r\n\r\nconst currentRootHelper = {\r\n  get: (id?: number) => storeHelper.get(id)?.currentRoot || null,\r\n  set: (fiber: Fiber) => (storeHelper.get().currentRoot = fiber),\r\n};\r\n\r\nconst nextUnitOfWorkHelper = {\r\n  get: () => storeHelper.get()?.nextUnitOfWork || null,\r\n  set: (fiber: Fiber) => (storeHelper.get().nextUnitOfWork = fiber),\r\n};\r\n\r\nconst componentFiberHelper = {\r\n  get: () => storeHelper.get()?.componentFiber,\r\n  set: (fiber: Fiber) => (storeHelper.get().componentFiber = fiber),\r\n};\r\n\r\nconst fromHookUpdateHelper = {\r\n  get: () => storeHelper.get()?.fromHookUpdate || false,\r\n  set: (value: boolean) => (storeHelper.get().fromHookUpdate = value),\r\n};\r\n\r\nconst eventsHelper = {\r\n  get: () => storeHelper.get().events,\r\n  addUnsubscriber: (fn: () => void) => storeHelper.get().unsubscribers.push(fn),\r\n  mapUnsubscribers: (id: number) => storeHelper.get(id).unsubscribers.forEach(fn => fn()),\r\n};\r\n\r\nconst deletionsHelper = {\r\n  get: () => storeHelper.get().deletions,\r\n  set: (deletions: Array<Fiber>) => (storeHelper.get().deletions = deletions),\r\n};\r\n\r\nconst fiberMountHelper = {\r\n  reset: () => {\r\n    storeHelper.get().fiberMount = {\r\n      level: 0,\r\n      navigation: {},\r\n      isDeepWalking: true,\r\n    };\r\n  },\r\n  getIndex: () => storeHelper.get().fiberMount.navigation[storeHelper.get().fiberMount.level],\r\n  jumpToChild: () => {\r\n    const { fiberMount } = storeHelper.get();\r\n    const level = fiberMount.level;\r\n    const nextLevel = level + 1;\r\n\r\n    fiberMount.level = nextLevel;\r\n    fiberMount.navigation[nextLevel] = 0;\r\n  },\r\n  jumpToParent: () => {\r\n    const { fiberMount } = storeHelper.get();\r\n    const level = fiberMount.level;\r\n    const nextLevel = level - 1;\r\n\r\n    fiberMount.navigation[level] = 0;\r\n    fiberMount.level = nextLevel;\r\n  },\r\n  jumpToSibling: () => {\r\n    const { fiberMount } = storeHelper.get();\r\n    const level = fiberMount.level;\r\n    const idx = fiberMount.navigation[level] + 1;\r\n\r\n    fiberMount.navigation[level] = idx;\r\n  },\r\n  deepWalking: {\r\n    get: () => storeHelper.get().fiberMount.isDeepWalking,\r\n    set: (value: boolean) => (storeHelper.get().fiberMount.isDeepWalking = value),\r\n  },\r\n};\r\n\r\nconst effectsHelper = {\r\n  get: () => storeHelper.get().effects,\r\n  reset: () => (storeHelper.get().effects = []),\r\n  add: (effect: () => void) => storeHelper.get().effects.push(effect),\r\n};\r\n\r\nconst layoutEffectsHelper = {\r\n  get: () => storeHelper.get().layoutEffects,\r\n  reset: () => (storeHelper.get().layoutEffects = []),\r\n  add: (effect: () => void) => storeHelper.get().layoutEffects.push(effect),\r\n};\r\n\r\nexport {\r\n  getRootId,\r\n  effectStoreHelper,\r\n  wipRootHelper,\r\n  currentRootHelper,\r\n  nextUnitOfWorkHelper,\r\n  componentFiberHelper,\r\n  fromHookUpdateHelper,\r\n  eventsHelper,\r\n  deletionsHelper,\r\n  fiberMountHelper,\r\n  effectsHelper,\r\n  layoutEffectsHelper,\r\n};\r\n","import { detectIsUndefined, detectIsFunction, detectIsDepsDifferent } from '../helpers';\r\nimport { componentFiberHelper, effectsHelper } from '../scope';\r\nimport type { Fiber, Hook, HookValue } from '../fiber';\r\nimport type { Effect, DropEffect } from './types';\r\n\r\nconst $$useEffect = Symbol('use-effect');\r\n\r\nconst { useEffect, hasEffects, dropEffects } = createEffect($$useEffect, effectsHelper);\r\n\r\nfunction createEffect(token: Symbol, store: typeof effectsHelper) {\r\n  function useEffect(effect: Effect, deps?: Array<any>) {\r\n    const fiber = componentFiberHelper.get();\r\n    const hook = fiber.hook as Hook<HookValue<DropEffect>>;\r\n    const { idx, values } = hook;\r\n    const runEffect = () => {\r\n      values[idx] = {\r\n        deps,\r\n        token,\r\n        value: undefined,\r\n      };\r\n\r\n      store.add(() => {\r\n        values[idx].value = effect();\r\n      });\r\n    };\r\n\r\n    if (detectIsUndefined(values[idx])) {\r\n      runEffect();\r\n    } else {\r\n      const { deps: prevDeps, value: cleanup } = values[idx];\r\n      const isDepsDifferent = deps ? detectIsDepsDifferent(deps, prevDeps) : true;\r\n\r\n      if (isDepsDifferent) {\r\n        detectIsFunction(cleanup) && cleanup();\r\n        runEffect();\r\n      }\r\n    }\r\n\r\n    hook.idx++;\r\n  }\r\n\r\n  function hasEffects(fiber: Fiber) {\r\n    const { values } = fiber.hook as Hook<HookValue>;\r\n    const hasEffect = values.some(x => x.token === token);\r\n\r\n    return hasEffect;\r\n  }\r\n\r\n  function dropEffects(hook: Hook<HookValue<DropEffect>>) {\r\n    const { values } = hook;\r\n\r\n    for (const value of values) {\r\n      if (value.token === token) {\r\n        const cleanup = value.value;\r\n\r\n        detectIsFunction(cleanup) && cleanup();\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    useEffect,\r\n    hasEffects,\r\n    dropEffects,\r\n  };\r\n}\r\n\r\nexport { useEffect, hasEffects, dropEffects, createEffect };\r\n","import { EMPTY_NODE, ATTR_KEY } from '../constants';\r\nimport { detectIsArray, detectIsEmpty, detectIsFunction } from '../helpers';\r\nimport type { DarkElementKey } from '../shared';\r\nimport type { ComponentFactory, StandardComponentProps } from '../component';\r\nimport { NodeType, type ViewDef } from './types';\r\n\r\nexport type VirtualNodeFactory = () => VirtualNode;\r\nexport type TagVirtualNodeFactory = () => TagVirtualNode;\r\nexport type TextVirtualNodeFactory = () => TextVirtualNode;\r\nexport type CommentVirtualNodeFactory = () => CommentVirtualNode;\r\n\r\nconst $$virtualNode = Symbol('virtual-node');\r\n\r\nclass VirtualNode {\r\n  public type: NodeType = null;\r\n\r\n  constructor(options: Partial<VirtualNode>) {\r\n    this.type = options.type;\r\n  }\r\n}\r\n\r\nclass TagVirtualNode extends VirtualNode {\r\n  public type = NodeType.TAG;\r\n  public name: string = null;\r\n  public isVoid = false;\r\n  public attrs: Record<string, any> = {};\r\n  public children: Array<VirtualNodeFactory | ComponentFactory> = [];\r\n\r\n  constructor(options: Partial<TagVirtualNode>) {\r\n    super(options);\r\n    this.name = options.name || this.name;\r\n    this.isVoid = options.isVoid || this.isVoid;\r\n    this.attrs = options.attrs || this.attrs;\r\n    this.children = options.children || this.children;\r\n  }\r\n}\r\n\r\nclass TextVirtualNode extends VirtualNode {\r\n  public type = NodeType.TEXT;\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super({});\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nclass CommentVirtualNode extends VirtualNode {\r\n  public type = NodeType.COMMENT;\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super({});\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nconst detectIsVirtualNode = (vNode: unknown): vNode is VirtualNode => vNode instanceof VirtualNode;\r\nconst detectIsTagVirtualNode = (vNode: unknown): vNode is TagVirtualNode => vNode instanceof TagVirtualNode;\r\nconst detectIsCommentVirtualNode = (vNode: unknown): vNode is CommentVirtualNode => vNode instanceof CommentVirtualNode;\r\nconst detectIsTextVirtualNode = (vNode: unknown): vNode is TextVirtualNode => vNode instanceof TextVirtualNode;\r\nconst detectIsEmptyVirtualNode = (vNode: unknown): boolean =>\r\n  detectIsCommentVirtualNode(vNode) && vNode.value === EMPTY_NODE;\r\n\r\nfunction getVirtualNodeKey(vNode: TagVirtualNode): DarkElementKey | null {\r\n  const key = vNode && vNode.attrs[ATTR_KEY];\r\n\r\n  return !detectIsEmpty(key) ? key : null;\r\n}\r\n\r\nfunction Text(source: string | StandardComponentProps['slot']): string | TextVirtualNode {\r\n  const text =\r\n    typeof source === 'string' ? new TextVirtualNode(source) : detectIsTextVirtualNode(source) ? source.value : '';\r\n\r\n  return text;\r\n}\r\n\r\nfunction Comment(text: string): CommentVirtualNodeFactory {\r\n  const factory = () => new CommentVirtualNode(text);\r\n\r\n  factory[$$virtualNode] = true;\r\n\r\n  return factory;\r\n}\r\n\r\nfunction View(def: ViewDef): TagVirtualNodeFactory {\r\n  const factory = () => {\r\n    const { as, slot, isVoid = false, ...rest } = def;\r\n    const children = isVoid ? [] : detectIsArray(slot) ? slot : slot ? [slot] : [];\r\n\r\n    return new TagVirtualNode({\r\n      name: as,\r\n      isVoid,\r\n      attrs: { ...rest },\r\n      children: children as Array<VirtualNodeFactory>,\r\n    });\r\n  };\r\n\r\n  factory[$$virtualNode] = true;\r\n\r\n  return factory;\r\n}\r\n\r\nconst createEmptyVirtualNode = () => new CommentVirtualNode(EMPTY_NODE);\r\n\r\nconst detectIsVirtualNodeFactory = (factory: unknown): factory is VirtualNodeFactory =>\r\n  detectIsFunction(factory) && factory[$$virtualNode] === true;\r\n\r\nexport {\r\n  VirtualNode,\r\n  TagVirtualNode,\r\n  TextVirtualNode,\r\n  CommentVirtualNode,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsCommentVirtualNode,\r\n  detectIsTextVirtualNode,\r\n  detectIsEmptyVirtualNode,\r\n  getVirtualNodeKey,\r\n  Text,\r\n  Comment,\r\n  View,\r\n  createEmptyVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n};\r\n","import { type KeyProps, createComponent, detectIsComponentFactory } from '../component';\r\n\r\nconst $$fragment = Symbol('fragment');\r\n\r\nconst Fragment = createComponent<KeyProps>(({ slot }) => slot || null, {\r\n  token: $$fragment,\r\n});\r\n\r\nconst detectIsFragment = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$fragment;\r\n\r\nexport { Fragment, detectIsFragment };\r\n","import { detectIsObject, detectIsNull } from '../helpers';\r\nimport type { Component, RefProps, ComponentFactory } from '../component';\r\nimport type { MutableRef } from './types';\r\n\r\nfunction forwardRef<P, R>(component: Component<P, R>) {\r\n  type Props = P & RefProps<R>;\r\n\r\n  return ({ ref, ...rest }: Props) => {\r\n    return component(rest as P, ref) as ComponentFactory<P, R>;\r\n  };\r\n}\r\n\r\nconst detectIsRef = (ref: unknown) => {\r\n  if (!detectIsObject(ref) || detectIsNull(ref)) return false;\r\n  const mutableRef = ref as MutableRef;\r\n\r\n  for (const key in mutableRef) {\r\n    if (key === 'current' && mutableRef.hasOwnProperty(key)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport { forwardRef, detectIsRef };\r\n","import {\r\n  type Component,\r\n  type ComponentFactory,\r\n  type StandardComponentProps,\r\n  type RefProps,\r\n  type SlotProps,\r\n  createComponent,\r\n  detectIsComponentFactory,\r\n} from '../component';\r\nimport { type MutableRef, forwardRef } from '../ref';\r\n\r\ntype ShouldUpdate<T> = (props: T, nextProps: T) => boolean;\r\n\r\nconst $$memo = Symbol('memo');\r\n\r\nconst defaultShouldUpdate = (props: {}, nextProps: {}): boolean => {\r\n  const keys = Object.keys(nextProps);\r\n\r\n  for (const key of keys) {\r\n    if (key !== 'slot' && nextProps[key] !== props[key]) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst detectIsMemo = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$memo;\r\n\r\nfunction memo<T>(\r\n  component: (props: T, ref?: MutableRef<unknown>) => ComponentFactory<T, unknown>,\r\n  shouldUpdate: ShouldUpdate<T & SlotProps> = defaultShouldUpdate,\r\n): Component<T & StandardComponentProps> {\r\n  return forwardRef(\r\n    createComponent(\r\n      (props: T & RefProps, ref) => {\r\n        ref && (props.ref = ref);\r\n\r\n        return component(props);\r\n      },\r\n      { token: $$memo, shouldUpdate },\r\n    ),\r\n  );\r\n}\r\n\r\nexport { $$memo, memo, detectIsMemo };\r\n","import { type DarkElement } from '../shared';\r\nimport { detectIsUndefined, detectIsArray, detectIsDepsDifferent } from '../helpers';\r\nimport { detectIsComponentFactory, createComponent } from '../component';\r\nimport { detectIsVirtualNodeFactory } from '../view';\r\nimport { componentFiberHelper } from '../scope';\r\nimport { Fragment } from '../fragment';\r\nimport { $$memo } from '../memo';\r\n\r\nconst Memo = createComponent(({ slot }) => slot, { token: $$memo });\r\n\r\nfunction wrap<T>(value: T, isDepsDifferent: boolean) {\r\n  const check = (value: T) => detectIsVirtualNodeFactory(value) || detectIsComponentFactory(value);\r\n\r\n  if (detectIsArray(value) ? check(value[0]) : check(value)) {\r\n    const slot = value as unknown as DarkElement;\r\n    const factory = Memo({\r\n      slot: Fragment({ slot }),\r\n    });\r\n\r\n    factory.shouldUpdate = () => isDepsDifferent;\r\n\r\n    return factory;\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction processValue<T>(getValue: () => T, isDepsDifferent = false) {\r\n  return wrap(getValue(), isDepsDifferent);\r\n}\r\n\r\nfunction useMemo<T>(getValue: () => T, deps: Array<any>): T {\r\n  const fiber = componentFiberHelper.get();\r\n  const { hook } = fiber;\r\n  const { idx, values } = hook;\r\n\r\n  if (detectIsUndefined(values[idx])) {\r\n    const value = processValue(getValue);\r\n\r\n    values[idx] = {\r\n      deps,\r\n      value,\r\n    };\r\n\r\n    hook.idx++;\r\n\r\n    return value as T;\r\n  }\r\n\r\n  const hookValue = values[idx];\r\n  const prevDeps = hookValue.deps as Array<any>;\r\n  const isDepsDifferent = detectIsDepsDifferent(deps, prevDeps);\r\n  const computedGetValue = isDepsDifferent ? getValue : () => hookValue.value;\r\n\r\n  hookValue.deps = deps;\r\n  hookValue.value = processValue(computedGetValue, isDepsDifferent);\r\n\r\n  hook.idx++;\r\n\r\n  return hookValue.value;\r\n}\r\n\r\nexport { useMemo };\r\n","import type { Platform } from './types';\r\n\r\nexport const platform: Platform = {\r\n  scheduleCallback: () => {\r\n    throw new Error('scheduleCallback not installed by renderer');\r\n  },\r\n  shouldYeildToHost: () => {\r\n    throw new Error('shouldYeildToHost not installed by renderer');\r\n  },\r\n  createNativeElement: () => {\r\n    throw new Error('createNativeElement not installed by renderer');\r\n  },\r\n  applyCommit: () => {\r\n    throw new Error('applyCommit not installed by renderer');\r\n  },\r\n  finishCommitWork: () => {\r\n    throw new Error('finishCommitWork not installed by renderer');\r\n  },\r\n  detectIsPortal: () => {\r\n    throw new Error('detectIsPortal not installed by renderer');\r\n  },\r\n  unmountPortal: () => {\r\n    throw new Error('unmountPortal not installed by renderer');\r\n  },\r\n};\r\n","export enum EffectTag {\r\n  PLACEMENT = 'PLACEMENT',\r\n  UPDATE = 'UPDATE',\r\n  DELETION = 'DELETION',\r\n  SKIP = 'SKIP',\r\n}\r\n\r\nexport type NativeElement = unknown;\r\n\r\nexport type HookValue<T = any> = {\r\n  token?: Symbol;\r\n  deps: Array<any>;\r\n  value: T;\r\n};\r\n\r\nexport type Hook<T = any> = {\r\n  idx: number;\r\n  values: Array<T>;\r\n};\r\n\r\nexport const cloneTagMap = {\r\n  [EffectTag.PLACEMENT]: true,\r\n  [EffectTag.SKIP]: true,\r\n};\r\n","import { layoutEffectsHelper } from '../scope';\r\nimport { createEffect } from '../use-effect';\r\n\r\nconst $$useLayoutEffect = Symbol('use-layout-effect');\r\n\r\nconst {\r\n  useEffect: useLayoutEffect,\r\n  hasEffects: hasLayoutEffects,\r\n  dropEffects: dropLayoutEffects,\r\n} = createEffect($$useLayoutEffect, layoutEffectsHelper);\r\n\r\nexport { useLayoutEffect, hasLayoutEffects, dropLayoutEffects };\r\n","import { type Fiber } from '../fiber';\r\n\r\ntype WalkFiberOptions<T> = {\r\n  fiber: Fiber;\r\n  onLoop: (options: OnLoopOptions<T>) => void;\r\n};\r\n\r\ntype OnLoopOptions<T> = {\r\n  nextFiber: Fiber<T>;\r\n  isReturn: boolean;\r\n  resetIsDeepWalking: () => void;\r\n  stop: () => void;\r\n};\r\n\r\nfunction walkFiber<T = unknown>(options: WalkFiberOptions<T>) {\r\n  const { fiber, onLoop } = options;\r\n  let nextFiber = fiber;\r\n  let isDeepWalking = true;\r\n  let isReturn = false;\r\n  let isStopped = false;\r\n  const visitedMap = new Map<Fiber, true>();\r\n  const detectCanVisit = (fiber: Fiber) => !visitedMap.get(fiber);\r\n\r\n  while (nextFiber) {\r\n    onLoop({\r\n      nextFiber: nextFiber as Fiber<T>,\r\n      isReturn,\r\n      resetIsDeepWalking: () => (isDeepWalking = false),\r\n      stop: () => (isStopped = true),\r\n    });\r\n\r\n    if (isStopped) {\r\n      break;\r\n    }\r\n\r\n    if (nextFiber.child && isDeepWalking && detectCanVisit(nextFiber.child)) {\r\n      const newFiber = nextFiber.child;\r\n\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap.set(newFiber, true);\r\n    } else if (nextFiber.nextSibling && detectCanVisit(nextFiber.nextSibling)) {\r\n      const newFiber = nextFiber.nextSibling;\r\n\r\n      isDeepWalking = true;\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap.set(newFiber, true);\r\n    } else if (\r\n      nextFiber.parent &&\r\n      nextFiber.parent === fiber &&\r\n      nextFiber.parent.nextSibling &&\r\n      detectCanVisit(nextFiber.parent.nextSibling)\r\n    ) {\r\n      const newFiber = nextFiber.parent.nextSibling;\r\n\r\n      isDeepWalking = true;\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap.set(newFiber, true);\r\n    } else if (nextFiber.parent && nextFiber.parent !== fiber) {\r\n      isDeepWalking = false;\r\n      isReturn = true;\r\n      nextFiber = nextFiber.parent;\r\n    } else {\r\n      nextFiber = null;\r\n    }\r\n  }\r\n}\r\n\r\nexport { walkFiber };\r\n","import { type Fiber } from '../fiber';\r\nimport { platform } from '../platform';\r\nimport { detectIsComponentFactory } from '../component';\r\nimport { dropEffects } from '../use-effect';\r\nimport { dropLayoutEffects } from '../use-layout-effect';\r\nimport { walkFiber } from '../walk';\r\nimport { detectIsUndefined } from '../helpers';\r\nimport { currentRootHelper, eventsHelper, effectStoreHelper } from '../scope';\r\n\r\nfunction unmountFiber(fiber: Fiber) {\r\n  if (!fiber.effectHost && !fiber.layoutEffectHost && !fiber.portalHost) return;\r\n\r\n  walkFiber({\r\n    fiber,\r\n    onLoop: ({ nextFiber, isReturn, stop }) => {\r\n      if (nextFiber === fiber.nextSibling || fiber.transposition) return stop();\r\n\r\n      if (!isReturn && detectIsComponentFactory(nextFiber.instance)) {\r\n        nextFiber.layoutEffectHost && dropLayoutEffects(nextFiber.hook);\r\n        nextFiber.effectHost && dropEffects(nextFiber.hook);\r\n        nextFiber.portalHost && platform.unmountPortal(nextFiber);\r\n      }\r\n    },\r\n  });\r\n}\r\n\r\nfunction unmountRoot(rootId: number, onComplete: () => void) {\r\n  if (detectIsUndefined(rootId)) return;\r\n\r\n  unmountFiber(currentRootHelper.get(rootId));\r\n  eventsHelper.mapUnsubscribers(rootId);\r\n  effectStoreHelper.remove(rootId);\r\n  onComplete();\r\n}\r\n\r\nexport { unmountFiber, unmountRoot };\r\n","import { flatten, detectIsEmpty, error, keyBy, takeListFromEnd, detectIsUndefined, detectIsArray } from '../helpers';\r\nimport { platform } from '../platform';\r\nimport {\r\n  wipRootHelper,\r\n  currentRootHelper,\r\n  nextUnitOfWorkHelper,\r\n  deletionsHelper,\r\n  fiberMountHelper,\r\n  componentFiberHelper,\r\n  fromHookUpdateHelper,\r\n  effectStoreHelper,\r\n  effectsHelper,\r\n  layoutEffectsHelper,\r\n} from '../scope';\r\nimport { type ComponentFactory, detectIsComponentFactory, getComponentFactoryKey } from '../component';\r\nimport {\r\n  type TagVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  createEmptyVirtualNode,\r\n  getVirtualNodeKey,\r\n  detectIsVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n} from '../view';\r\nimport { detectIsMemo } from '../memo';\r\nimport type { Context, ContextProviderValue } from '../context';\r\nimport type { DarkElementKey, DarkElement, DarkElementInstance } from '../shared';\r\nimport { PARTIAL_UPDATE } from '../constants';\r\nimport { type NativeElement, type Hook, EffectTag, cloneTagMap } from './types';\r\nimport { hasEffects } from '../use-effect';\r\nimport { hasLayoutEffects } from '../use-layout-effect';\r\nimport { walkFiber } from '../walk';\r\nimport { unmountFiber } from '../unmount';\r\n\r\nclass Fiber<N = NativeElement> {\r\n  public nativeElement: N;\r\n  public parent: Fiber<N>;\r\n  public child: Fiber<N>;\r\n  public nextSibling: Fiber<N>;\r\n  public alternate: Fiber<N>;\r\n  public effectTag: EffectTag;\r\n  public instance: DarkElementInstance;\r\n  public hook: Hook;\r\n  public shadow: Fiber<N>;\r\n  public provider: Map<Context, ContextProviderValue>;\r\n  public transposition: boolean;\r\n  public mountedToHost: boolean;\r\n  public portalHost: boolean;\r\n  public effectHost: boolean;\r\n  public layoutEffectHost: boolean;\r\n  public childrenCount: number;\r\n  public marker: string;\r\n  public isUsed: boolean;\r\n  public catchException: (error: Error) => void;\r\n\r\n  constructor(options: Partial<Fiber<N>>) {\r\n    this.nativeElement = options.nativeElement || null;\r\n    this.parent = options.parent || null;\r\n    this.child = options.child || null;\r\n    this.nextSibling = options.nextSibling || null;\r\n    this.alternate = options.alternate || null;\r\n    this.effectTag = options.effectTag || null;\r\n    this.instance = options.instance || null;\r\n    this.hook = options.hook || createHook();\r\n    this.shadow = options.shadow || null;\r\n    this.provider = options.provider || null;\r\n    this.transposition = !detectIsUndefined(options.transposition) ? options.transposition : false;\r\n    this.mountedToHost = !detectIsUndefined(options.mountedToHost) || false;\r\n    this.portalHost = !detectIsUndefined(options.portalHost) ? options.portalHost : false;\r\n    this.effectHost = !detectIsUndefined(options.effectHost) ? options.effectHost : false;\r\n    this.layoutEffectHost = !detectIsUndefined(options.layoutEffectHost) ? options.layoutEffectHost : false;\r\n    this.childrenCount = options.childrenCount || 0;\r\n    this.marker = options.marker || '';\r\n    this.isUsed = options.isUsed || false;\r\n  }\r\n\r\n  public markPortalHost() {\r\n    this.portalHost = true;\r\n    this.parent && !this.parent.portalHost && this.parent.markPortalHost();\r\n  }\r\n\r\n  public markEffectHost() {\r\n    this.effectHost = true;\r\n    this.parent && !this.parent.effectHost && this.parent.markEffectHost();\r\n  }\r\n\r\n  public markLayoutEffectHost() {\r\n    this.layoutEffectHost = true;\r\n    this.parent && !this.parent.layoutEffectHost && this.parent.markLayoutEffectHost();\r\n  }\r\n\r\n  public setError(error: Error) {\r\n    if (typeof this.catchException === 'function') {\r\n      this.catchException(error);\r\n    } else if (this.parent) {\r\n      this.parent.setError(error);\r\n    }\r\n  }\r\n}\r\n\r\nfunction workLoop() {\r\n  const wipFiber = wipRootHelper.get();\r\n  let nextUnitOfWork = nextUnitOfWorkHelper.get();\r\n  let shouldYield = false;\r\n  let hasMoreWork = Boolean(nextUnitOfWork);\r\n\r\n  while (nextUnitOfWork && !shouldYield) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\r\n    nextUnitOfWorkHelper.set(nextUnitOfWork);\r\n    hasMoreWork = Boolean(nextUnitOfWork);\r\n    shouldYield = platform.shouldYeildToHost();\r\n  }\r\n\r\n  if (!nextUnitOfWork && wipFiber) {\r\n    commitChanges();\r\n  }\r\n\r\n  return hasMoreWork;\r\n}\r\n\r\nfunction performUnitOfWork(fiber: Fiber) {\r\n  let isDeepWalking = true;\r\n  let nextFiber = fiber;\r\n  let shadow: Fiber = fiber.shadow;\r\n  let instance = fiber.instance;\r\n\r\n  while (true) {\r\n    isDeepWalking = fiberMountHelper.deepWalking.get();\r\n    nextFiber.hook.idx = 0;\r\n\r\n    if (isDeepWalking) {\r\n      const hasChildren = hasChildrenProp(instance) && instance.children.length > 0;\r\n\r\n      if (hasChildren) {\r\n        const { performedFiber, performedNextFiber, performedShadow, performedInstance } = performChild({\r\n          nextFiber,\r\n          shadow,\r\n          instance,\r\n        });\r\n\r\n        nextFiber = performedNextFiber;\r\n        shadow = performedShadow;\r\n        instance = performedInstance;\r\n\r\n        if (performedFiber) return performedFiber;\r\n      } else {\r\n        const { performedFiber, performedNextFiber, performedShadow, performedInstance } = performSibling({\r\n          nextFiber,\r\n          shadow,\r\n          instance,\r\n        });\r\n\r\n        nextFiber = performedNextFiber;\r\n        shadow = performedShadow;\r\n        instance = performedInstance;\r\n\r\n        if (performedFiber) return performedFiber;\r\n      }\r\n    } else {\r\n      const { performedFiber, performedNextFiber, performedShadow, performedInstance } = performSibling({\r\n        nextFiber,\r\n        shadow,\r\n        instance,\r\n      });\r\n\r\n      nextFiber = performedNextFiber;\r\n      shadow = performedShadow;\r\n      instance = performedInstance;\r\n\r\n      if (performedFiber) return performedFiber;\r\n    }\r\n\r\n    performPartialUpdateEffects(nextFiber);\r\n\r\n    if (nextFiber.parent === null) return null;\r\n  }\r\n}\r\n\r\nfunction performPartialUpdateEffects(nextFiber: Fiber) {\r\n  if (nextFiber.marker === PARTIAL_UPDATE) {\r\n    const alternate = nextFiber.child?.alternate || null;\r\n    const fiber = nextFiber.child || null;\r\n\r\n    if (alternate && fiber && alternate.nextSibling && !fiber.nextSibling) {\r\n      let nextFiber = alternate.nextSibling;\r\n      const deletions: Array<Fiber> = [];\r\n\r\n      while (nextFiber) {\r\n        nextFiber.effectTag = EffectTag.DELETION;\r\n        deletions.push(nextFiber);\r\n        nextFiber = nextFiber.nextSibling;\r\n      }\r\n\r\n      deletionsHelper.get().push(...deletions);\r\n    }\r\n  }\r\n}\r\n\r\ntype PerformChildOptions = {\r\n  nextFiber: Fiber;\r\n  shadow: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction performChild(options: PerformChildOptions) {\r\n  fiberMountHelper.jumpToChild();\r\n  let nextFiber = options.nextFiber;\r\n  let shadow = options.shadow;\r\n  let instance = options.instance;\r\n\r\n  shadow = shadow ? shadow.child : null;\r\n\r\n  const alternate = getChildAlternate(nextFiber);\r\n  const hook = getHook({ shadow, alternate, instance });\r\n  const provider = shadow ? shadow.provider : alternate ? alternate.provider : null;\r\n  let fiber = new Fiber({ hook, provider });\r\n\r\n  componentFiberHelper.set(fiber);\r\n  fiber.parent = nextFiber;\r\n\r\n  const { performedInstance, performedShadow } = pertformInstance({\r\n    instance,\r\n    idx: 0,\r\n    fiber,\r\n    alternate,\r\n  });\r\n  instance = performedInstance || instance;\r\n  shadow = performedShadow || shadow;\r\n  alternate && mutateAlternate({ alternate, instance });\r\n  mutateFiber({ fiber, alternate, instance });\r\n  fiber = alternate ? performMemo({ fiber, alternate, instance }) : fiber;\r\n\r\n  nextFiber.child = fiber;\r\n  fiber.parent = nextFiber;\r\n  fiber.shadow = shadow;\r\n  nextFiber = fiber;\r\n\r\n  cloneTagMap[fiber.parent.effectTag] && (fiber.effectTag = fiber.parent.effectTag);\r\n\r\n  return {\r\n    performedFiber: nextFiber,\r\n    performedNextFiber: nextFiber,\r\n    performedShadow: shadow,\r\n    performedInstance: instance,\r\n  };\r\n}\r\n\r\ntype PerformSiblingOptions = {\r\n  nextFiber: Fiber;\r\n  shadow: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction performSibling(options: PerformSiblingOptions) {\r\n  fiberMountHelper.jumpToSibling();\r\n  let nextFiber = options.nextFiber;\r\n  let shadow = options.shadow;\r\n  let instance = options.instance;\r\n  const parent = nextFiber.parent.instance;\r\n  const childrenIdx = fiberMountHelper.getIndex();\r\n  const hasSibling = hasChildrenProp(parent) && parent.children[childrenIdx];\r\n\r\n  if (hasSibling) {\r\n    fiberMountHelper.deepWalking.set(true);\r\n\r\n    shadow = shadow ? shadow.nextSibling : null;\r\n    const alternate = getNextSiblingAlternate(nextFiber);\r\n    const hook = getHook({ shadow, alternate, instance });\r\n    const provider = shadow ? shadow.provider : alternate ? alternate.provider : null;\r\n    let fiber = new Fiber({ hook, provider });\r\n\r\n    componentFiberHelper.set(fiber);\r\n    fiber.parent = nextFiber.parent;\r\n\r\n    const { performedInstance, performedShadow } = pertformInstance({\r\n      instance: parent,\r\n      idx: childrenIdx,\r\n      fiber,\r\n      alternate,\r\n    });\r\n    instance = performedInstance || instance;\r\n    shadow = performedShadow || shadow;\r\n    alternate && mutateAlternate({ alternate, instance });\r\n    mutateFiber({ fiber, alternate, instance });\r\n    fiber = alternate ? performMemo({ fiber, alternate, instance }) : fiber;\r\n\r\n    fiber.parent = nextFiber.parent;\r\n    nextFiber.nextSibling = fiber;\r\n    fiber.shadow = shadow;\r\n    nextFiber = fiber;\r\n\r\n    cloneTagMap[fiber.parent.effectTag] && (fiber.effectTag = fiber.parent.effectTag);\r\n\r\n    return {\r\n      performedFiber: nextFiber,\r\n      performedNextFiber: nextFiber,\r\n      performedShadow: shadow,\r\n      performedInstance: instance,\r\n    };\r\n  } else {\r\n    fiberMountHelper.jumpToParent();\r\n    fiberMountHelper.deepWalking.set(false);\r\n    shadow = shadow ? shadow.parent : null;\r\n    nextFiber = nextFiber.parent;\r\n    instance = nextFiber.instance;\r\n\r\n    if (hasChildrenProp(nextFiber.instance)) {\r\n      nextFiber.instance.children = [];\r\n    }\r\n  }\r\n\r\n  return {\r\n    performedFiber: null,\r\n    performedNextFiber: nextFiber,\r\n    performedShadow: shadow,\r\n    performedInstance: instance,\r\n  };\r\n}\r\n\r\ntype MutateFiberOptions = {\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction mutateFiber(options: MutateFiberOptions) {\r\n  const { fiber, alternate, instance } = options;\r\n  const key = alternate ? getElementKey(alternate.instance) : null;\r\n  const nextKey = alternate ? getElementKey(instance) : null;\r\n  const isDifferentKeys = key !== nextKey;\r\n  const isSameType = Boolean(alternate) && getInstanceType(alternate.instance) === getInstanceType(instance);\r\n  const isUpdate = isSameType && !isDifferentKeys;\r\n\r\n  fiber.instance = instance;\r\n  fiber.alternate = alternate || null;\r\n  fiber.nativeElement = isUpdate ? alternate.nativeElement : null;\r\n  fiber.effectTag = isUpdate ? EffectTag.UPDATE : EffectTag.PLACEMENT;\r\n  fiber.mountedToHost = fiber.nativeElement ? isUpdate : false;\r\n\r\n  if (hasChildrenProp(fiber.instance)) {\r\n    fiber.childrenCount = fiber.instance.children.length;\r\n  }\r\n\r\n  if (fiber.alternate) {\r\n    fiber.alternate.shadow = null;\r\n    fiber.alternate.alternate = null;\r\n  }\r\n\r\n  if (!fiber.nativeElement && detectIsVirtualNode(fiber.instance)) {\r\n    fiber.nativeElement = platform.createNativeElement(fiber);\r\n  }\r\n}\r\n\r\ntype PerformAlternateOptions = {\r\n  alternate: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction mutateAlternate(options: PerformAlternateOptions) {\r\n  const { alternate, instance } = options;\r\n  const alternateType = getInstanceType(alternate.instance);\r\n  const elementType = getInstanceType(instance);\r\n  const isSameType = elementType === alternateType;\r\n  const prevKey = getElementKey(alternate.instance);\r\n  const nextKey = getElementKey(instance);\r\n  const isSameKeys = prevKey === nextKey;\r\n\r\n  alternate.isUsed = true;\r\n\r\n  if (!isSameType || !isSameKeys) {\r\n    alternate.effectTag = EffectTag.DELETION;\r\n    deletionsHelper.get().push(alternate);\r\n  } else if (hasChildrenProp(alternate.instance) && hasChildrenProp(instance)) {\r\n    const prevElementsCount = alternate.childrenCount;\r\n    const nextElementsCount = instance.children.length;\r\n    const isRequestedKeys = prevElementsCount !== nextElementsCount;\r\n\r\n    if (isRequestedKeys) {\r\n      const isRemovingCase = nextElementsCount < prevElementsCount;\r\n      const isInsertingCase = nextElementsCount > prevElementsCount;\r\n      const children = hasChildrenProp(instance) ? instance.children : [];\r\n      const { prevKeys, nextKeys } = extractKeys(alternate.child, children);\r\n      const hasKeys = prevKeys.length > 0;\r\n      const hasAnyKeys = hasKeys || nextKeys.length > 0;\r\n\r\n      if (process.env.NODE_ENV === 'development') {\r\n        if (!hasAnyKeys && prevElementsCount !== 0 && nextElementsCount !== 0) {\r\n          error(`\r\n            [Dark]: Operation of inserting, adding, replacing elements into list requires to have a unique key for every node (string or number, but not array index)!\r\n          `);\r\n        }\r\n      }\r\n\r\n      const performRemovingNodes = () => {\r\n        const diffKeys = getDiffKeys(prevKeys, nextKeys);\r\n\r\n        if (diffKeys.length > 0) {\r\n          const fibersMap = createFibersByKeyMap(alternate.child);\r\n\r\n          for (const key of diffKeys) {\r\n            const fiber = fibersMap[key] || null;\r\n\r\n            if (fiber) {\r\n              fiber.effectTag = EffectTag.DELETION;\r\n              deletionsHelper.get().push(fiber);\r\n            }\r\n          }\r\n        } else if (!hasKeys) {\r\n          const diffCount = prevElementsCount - nextElementsCount;\r\n          const fibers = takeListFromEnd(getSiblingFibers(alternate.child), diffCount);\r\n\r\n          for (const fiber of fibers) {\r\n            fiber.effectTag = EffectTag.DELETION;\r\n          }\r\n\r\n          deletionsHelper.get().push(...fibers);\r\n        }\r\n      };\r\n\r\n      const performInsertingNodes = () => {\r\n        const diffKeys = getDiffKeys(nextKeys, prevKeys);\r\n\r\n        if (diffKeys.length > 0) {\r\n          const diffKeyMap = keyBy(diffKeys, x => x);\r\n          const fibersByPositionsMap = createFibersByPositionMap(alternate.child);\r\n          const usedKeyMap = {};\r\n          let keyIdx = 0;\r\n\r\n          for (const nextKey of nextKeys) {\r\n            if (process.env.NODE_ENV === 'development') {\r\n              if (usedKeyMap[nextKey]) {\r\n                error(`Some key of node already has been used!`);\r\n              }\r\n            }\r\n\r\n            usedKeyMap[nextKey] = true;\r\n\r\n            if (nextKey !== prevKeys[keyIdx] && diffKeyMap[nextKey]) {\r\n              const insertionFiber = new Fiber({\r\n                instance: createEmptyVirtualNode(),\r\n                parent: alternate,\r\n                effectTag: EffectTag.PLACEMENT,\r\n              });\r\n\r\n              if (keyIdx === 0) {\r\n                insertionFiber.nextSibling = alternate.child;\r\n                alternate.child = insertionFiber;\r\n              } else {\r\n                const fiber = fibersByPositionsMap[keyIdx] || null;\r\n\r\n                if (fiber) {\r\n                  insertionFiber.nextSibling = fiber;\r\n                }\r\n              }\r\n            }\r\n\r\n            keyIdx++;\r\n          }\r\n        }\r\n      };\r\n\r\n      isRemovingCase && performRemovingNodes();\r\n      isInsertingCase && performInsertingNodes();\r\n    }\r\n  }\r\n}\r\n\r\ntype PerformMemoOptions = {\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction performMemo(options: PerformMemoOptions) {\r\n  const { fiber, alternate, instance } = options;\r\n\r\n  if (detectIsMemo(fiber.instance)) {\r\n    let memoFiber: Fiber = null;\r\n    const factory = instance as ComponentFactory;\r\n    const alternateFactory = alternate.instance as ComponentFactory;\r\n\r\n    if (factory.type !== alternateFactory.type) return fiber;\r\n\r\n    const props = alternateFactory.props;\r\n    const nextProps = factory.props;\r\n    const skip = !factory.shouldUpdate(props, nextProps);\r\n\r\n    if (skip) {\r\n      let nextFiber: Fiber = null;\r\n      fiberMountHelper.deepWalking.set(false);\r\n\r\n      memoFiber = new Fiber({\r\n        ...alternate,\r\n        alternate,\r\n        effectTag: EffectTag.SKIP,\r\n        nextSibling: alternate.nextSibling\r\n          ? alternate.nextSibling.effectTag === EffectTag.DELETION\r\n            ? null\r\n            : alternate.nextSibling\r\n          : null,\r\n      });\r\n\r\n      alternate.alternate = null;\r\n      nextFiber = memoFiber.child;\r\n\r\n      while (nextFiber) {\r\n        nextFiber.parent = memoFiber;\r\n        nextFiber = nextFiber.nextSibling;\r\n      }\r\n\r\n      if (memoFiber.effectHost) {\r\n        fiber.markEffectHost();\r\n      }\r\n\r\n      if (memoFiber.layoutEffectHost) {\r\n        fiber.markLayoutEffectHost();\r\n      }\r\n\r\n      if (memoFiber.portalHost) {\r\n        fiber.markPortalHost();\r\n      }\r\n\r\n      return memoFiber;\r\n    }\r\n  }\r\n\r\n  return fiber;\r\n}\r\n\r\ntype PerformInstanceOptions = {\r\n  instance: DarkElementInstance;\r\n  idx: number;\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n};\r\n\r\nfunction pertformInstance(options: PerformInstanceOptions) {\r\n  const { instance, idx, fiber, alternate } = options;\r\n  let performedInstance: DarkElementInstance = null;\r\n  let performedShadow: Fiber = null;\r\n\r\n  if (hasChildrenProp(instance)) {\r\n    const elements = detectIsArray(instance.children[idx])\r\n      ? flatten([instance.children[idx]])\r\n      : [instance.children[idx]];\r\n\r\n    instance.children.splice(idx, 1, ...elements);\r\n    performedInstance = instance.children[idx];\r\n    performedShadow = alternate\r\n      ? getRootShadow({\r\n          instance: performedInstance,\r\n          fiber,\r\n          alternate,\r\n        })\r\n      : performedShadow;\r\n    performedInstance = mountInstance(fiber, performedInstance);\r\n  }\r\n\r\n  if (detectIsComponentFactory(performedInstance)) {\r\n    if (hasEffects(fiber)) {\r\n      fiber.markEffectHost();\r\n    }\r\n\r\n    if (hasLayoutEffects(fiber)) {\r\n      fiber.markLayoutEffectHost();\r\n    }\r\n\r\n    if (platform.detectIsPortal(performedInstance)) {\r\n      fiber.markPortalHost();\r\n    }\r\n  }\r\n\r\n  return {\r\n    performedInstance,\r\n    performedShadow,\r\n  };\r\n}\r\n\r\ntype GetRootShadowOptions = {\r\n  instance: DarkElementInstance;\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n};\r\n\r\nfunction getRootShadow(options: GetRootShadowOptions) {\r\n  const { instance, fiber, alternate } = options;\r\n  const key = getElementKey(alternate.instance);\r\n  const nextKey = getElementKey(instance);\r\n  let shadow: Fiber = null;\r\n\r\n  if (key !== nextKey) {\r\n    shadow = getAlternateByKey(nextKey, alternate.parent.child);\r\n\r\n    if (shadow) {\r\n      fiber.hook = shadow.hook;\r\n      fiber.provider = shadow.provider;\r\n      alternate.transposition = true;\r\n    }\r\n  }\r\n\r\n  return shadow;\r\n}\r\n\r\nfunction mountInstance(fiber: Fiber, instance: DarkElementInstance) {\r\n  const isComponentFactory = detectIsComponentFactory(instance);\r\n  const factory = instance as ComponentFactory;\r\n\r\n  if (isComponentFactory) {\r\n    try {\r\n      const result = factory.type(factory.props, factory.ref);\r\n\r\n      factory.children = detectIsArray(result)\r\n        ? (flatten([result]) as Array<DarkElementInstance>)\r\n        : ([result] as Array<DarkElementInstance>);\r\n    } catch (err) {\r\n      factory.children = [];\r\n      fiber.setError(err);\r\n      error(err);\r\n    }\r\n  } else if (detectIsVirtualNodeFactory(instance)) {\r\n    instance = instance();\r\n  }\r\n\r\n  if (hasChildrenProp(instance)) {\r\n    for (let i = 0; i < instance.children.length; i++) {\r\n      if (!instance.children[i]) {\r\n        instance.children[i] = transformElementInstance(instance.children[i]) as DarkElementInstance;\r\n      }\r\n    }\r\n\r\n    instance.children = isComponentFactory\r\n      ? instance.children\r\n      : detectIsArray(instance.children)\r\n      ? flatten([instance.children])\r\n      : [instance.children];\r\n\r\n    if (isComponentFactory && factory.children.length === 0) {\r\n      factory.children.push(createEmptyVirtualNode());\r\n    }\r\n  }\r\n\r\n  return instance;\r\n}\r\n\r\nfunction createFibersByPositionMap(fiber: Fiber) {\r\n  let nextFiber = fiber;\r\n  let position = 0;\r\n  const map: Record<string, Fiber> = {};\r\n\r\n  while (nextFiber) {\r\n    map[position] = nextFiber;\r\n\r\n    position++;\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return map;\r\n}\r\n\r\nfunction createFibersByKeyMap(fiber: Fiber) {\r\n  let nextFiber = fiber;\r\n  const map: Record<string, Fiber> = {};\r\n\r\n  while (nextFiber) {\r\n    const key = getElementKey(nextFiber.instance);\r\n\r\n    if (!detectIsEmpty(key)) {\r\n      map[key] = nextFiber;\r\n    }\r\n\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return map;\r\n}\r\n\r\nfunction extractKeys(alternate: Fiber, children: Array<DarkElementInstance>) {\r\n  let nextFiber = alternate;\r\n  let idx = 0;\r\n  const prevKeys: Array<DarkElementKey> = [];\r\n  const nextKeys: Array<DarkElementKey> = [];\r\n\r\n  while (nextFiber || idx < children.length) {\r\n    const key = nextFiber && getElementKey(nextFiber.instance);\r\n    const nextKey = children[idx] && getElementKey(children[idx]);\r\n\r\n    if (!detectIsEmpty(key)) {\r\n      prevKeys.push(key);\r\n    }\r\n\r\n    if (!detectIsEmpty(nextKey)) {\r\n      nextKeys.push(nextKey);\r\n    }\r\n\r\n    nextFiber = nextFiber ? nextFiber.nextSibling : null;\r\n    idx++;\r\n  }\r\n\r\n  return {\r\n    prevKeys,\r\n    nextKeys,\r\n  };\r\n}\r\n\r\nfunction getAlternateByKey(key: DarkElementKey, fiber: Fiber) {\r\n  if (detectIsEmpty(key)) return null;\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    if (key === getElementKey(nextFiber.instance)) {\r\n      return nextFiber;\r\n    }\r\n\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction getElementKey(instance: DarkElementInstance): DarkElementKey | null {\r\n  const key = detectIsComponentFactory(instance)\r\n    ? getComponentFactoryKey(instance)\r\n    : detectIsTagVirtualNode(instance)\r\n    ? getVirtualNodeKey(instance)\r\n    : null;\r\n\r\n  return key;\r\n}\r\n\r\nfunction getDiffKeys(keys: Array<DarkElementKey>, nextKeys: Array<DarkElementKey>): Array<DarkElementKey> {\r\n  const nextKeysMap = nextKeys.reduce((acc, key) => ((acc[key] = true), acc), {});\r\n  const diff = [];\r\n\r\n  for (const key of keys) {\r\n    if (!nextKeysMap[key]) {\r\n      diff.push(key);\r\n    }\r\n  }\r\n\r\n  return diff;\r\n}\r\n\r\nfunction getChildAlternate(fiber: Fiber): Fiber | null {\r\n  let alternate = fiber.alternate && fiber.alternate.effectTag !== EffectTag.DELETION ? fiber.alternate.child : null;\r\n\r\n  while (alternate && alternate.effectTag === EffectTag.DELETION) {\r\n    alternate = alternate.nextSibling;\r\n  }\r\n\r\n  return alternate;\r\n}\r\n\r\nfunction getNextSiblingAlternate(fiber: Fiber): Fiber | null {\r\n  let alternate = fiber.alternate?.nextSibling || null;\r\n\r\n  while (alternate && alternate.effectTag === EffectTag.DELETION) {\r\n    alternate = alternate.nextSibling;\r\n  }\r\n\r\n  return alternate;\r\n}\r\n\r\nfunction transformElementInstance(instance: DarkElement) {\r\n  return detectIsEmpty(instance) || instance === false ? createEmptyVirtualNode() : instance;\r\n}\r\n\r\nfunction getInstanceType(instance: DarkElementInstance): string | Function {\r\n  return detectIsTagVirtualNode(instance)\r\n    ? instance.name\r\n    : detectIsVirtualNode(instance)\r\n    ? instance.type\r\n    : detectIsComponentFactory(instance)\r\n    ? instance.type\r\n    : null;\r\n}\r\n\r\nfunction getSiblingFibers(fiber: Fiber): Array<Fiber> {\r\n  const list = [];\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    list.push(nextFiber);\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return list;\r\n}\r\n\r\nfunction hasChildrenProp(element: DarkElementInstance): element is TagVirtualNode | ComponentFactory {\r\n  return detectIsTagVirtualNode(element) || detectIsComponentFactory(element);\r\n}\r\n\r\nfunction commitChanges() {\r\n  const wipFiber = wipRootHelper.get();\r\n  const fromHook = fromHookUpdateHelper.get();\r\n  const deletions = deletionsHelper.get();\r\n  const hasEffects = Boolean(wipFiber.alternate?.effectHost);\r\n  const hasLayoutEffects = Boolean(wipFiber.alternate?.layoutEffectHost);\r\n  const hasPortals = Boolean(wipFiber.alternate?.portalHost);\r\n\r\n  if (hasEffects || hasLayoutEffects || hasPortals) {\r\n    for (const fiber of deletions) {\r\n      unmountFiber(fiber);\r\n    }\r\n  }\r\n\r\n  commitWork(wipFiber.child, () => {\r\n    const layoutEffects = layoutEffectsHelper.get();\r\n    const effects = effectsHelper.get();\r\n\r\n    for (const fiber of deletions) {\r\n      platform.applyCommit(fiber);\r\n    }\r\n\r\n    deletionsHelper.set([]);\r\n    wipRootHelper.set(null);\r\n\r\n    for (const layoutEffect of layoutEffects) {\r\n      layoutEffect();\r\n    }\r\n\r\n    setTimeout(() => {\r\n      for (const effect of effects) {\r\n        effect();\r\n      }\r\n    });\r\n\r\n    layoutEffectsHelper.reset();\r\n    effectsHelper.reset();\r\n\r\n    if (fromHook) {\r\n      fromHookUpdateHelper.set(false);\r\n    } else {\r\n      currentRootHelper.set(wipFiber);\r\n    }\r\n  });\r\n}\r\n\r\nfunction commitWork(fiber: Fiber, onComplete: Function) {\r\n  walkFiber({\r\n    fiber,\r\n    onLoop: ({ nextFiber, isReturn, resetIsDeepWalking }) => {\r\n      const skip = nextFiber.effectTag === EffectTag.SKIP;\r\n\r\n      if (skip) {\r\n        resetIsDeepWalking();\r\n      } else if (!isReturn) {\r\n        platform.applyCommit(nextFiber);\r\n      }\r\n\r\n      if (nextFiber && nextFiber.shadow) {\r\n        nextFiber.shadow = null;\r\n      }\r\n    },\r\n  });\r\n\r\n  platform.finishCommitWork();\r\n  onComplete();\r\n}\r\n\r\nfunction createHook(): Hook {\r\n  return {\r\n    idx: 0,\r\n    values: [],\r\n  };\r\n}\r\n\r\ntype GetHookOptions = {\r\n  shadow: Fiber;\r\n  alternate: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction getHook(options: GetHookOptions) {\r\n  const { shadow, alternate, instance } = options;\r\n\r\n  if (shadow) return shadow.hook;\r\n\r\n  if (alternate && getElementKey(alternate.instance) === getElementKey(instance)) {\r\n    return alternate.hook;\r\n  }\r\n\r\n  return createHook();\r\n}\r\n\r\ntype CreateUpdateCallbackOptions = {\r\n  rootId: number;\r\n  fiber: Fiber;\r\n  forceStart?: boolean;\r\n  onStart: () => void;\r\n};\r\n\r\nfunction createUpdateCallback(options: CreateUpdateCallbackOptions) {\r\n  const { rootId, fiber, forceStart = false, onStart } = options;\r\n  const callback = () => {\r\n    forceStart && onStart();\r\n    if (fiber.isUsed) return;\r\n    !forceStart && onStart();\r\n    effectStoreHelper.set(rootId); // important order!\r\n    fromHookUpdateHelper.set(true);\r\n    fiberMountHelper.reset();\r\n\r\n    fiber.alternate = new Fiber({\r\n      ...fiber,\r\n      alternate: null,\r\n    });\r\n    fiber.marker = PARTIAL_UPDATE;\r\n    fiber.effectTag = EffectTag.UPDATE;\r\n    fiber.child = null;\r\n\r\n    wipRootHelper.set(fiber);\r\n    componentFiberHelper.set(fiber);\r\n    fiber.instance = mountInstance(fiber, fiber.instance);\r\n    nextUnitOfWorkHelper.set(fiber);\r\n  };\r\n\r\n  return callback;\r\n}\r\n\r\nexport { Fiber, workLoop, createHook, hasChildrenProp, createUpdateCallback };\r\n","import { platform, type ScheduleCallbackOptions } from '../platform';\r\nimport { getRootId, componentFiberHelper } from '../scope';\r\nimport { createUpdateCallback } from '../fiber';\r\nimport { useMemo } from '../use-memo';\r\nimport { dummyFn } from '../helpers';\r\n\r\nfunction useUpdate(options?: ScheduleCallbackOptions) {\r\n  const rootId = getRootId();\r\n  const fiber = componentFiberHelper.get();\r\n  const scope = useMemo(() => ({ fiber }), []);\r\n\r\n  scope.fiber = fiber;\r\n\r\n  const update = (onStart?: () => void) => {\r\n    const callback = createUpdateCallback({\r\n      rootId,\r\n      fiber: scope.fiber,\r\n      forceStart: Boolean(options?.timeoutMs),\r\n      onStart: onStart || dummyFn,\r\n    });\r\n\r\n    platform.scheduleCallback(callback, options);\r\n  };\r\n\r\n  return update;\r\n}\r\n\r\nexport { useUpdate };\r\n","import { useEffect } from '../use-effect';\r\nimport { useMemo } from '../use-memo';\r\nimport { componentFiberHelper } from '../scope';\r\nimport { useUpdate } from '../use-update';\r\nimport type { Fiber } from '../fiber';\r\nimport type { Context, ContextProviderValue } from '../context';\r\n\r\nfunction useContext<T>(context: Context<T>): T {\r\n  const { defaultValue } = context;\r\n  const fiber = componentFiberHelper.get();\r\n  const provider = getProvider<T>(context, fiber);\r\n  const value = provider ? provider.value : defaultValue;\r\n  const update = useUpdate();\r\n  const scope = useMemo(() => ({ prevValue: value }), []);\r\n  const hasProvider = Boolean(provider);\r\n\r\n  useEffect(() => {\r\n    if (!hasProvider) return;\r\n\r\n    const subscriber = (newValue: T) => {\r\n      if (!Object.is(scope.prevValue, newValue)) {\r\n        update();\r\n      }\r\n    };\r\n\r\n    provider.subscribers.push(subscriber);\r\n\r\n    return () => {\r\n      const idx = provider.subscribers.findIndex(x => x === subscriber);\r\n\r\n      if (idx !== -1) {\r\n        provider.subscribers.splice(idx, 1);\r\n      }\r\n    };\r\n  }, [hasProvider]);\r\n\r\n  scope.prevValue = value;\r\n\r\n  return value;\r\n}\r\n\r\nfunction getProvider<T>(context: Context<T>, fiber: Fiber): ContextProviderValue<T> {\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    if (nextFiber.provider && nextFiber.provider.get(context)) {\r\n      return nextFiber.provider.get(context) as ContextProviderValue<T>;\r\n    }\r\n\r\n    nextFiber = nextFiber.parent;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { useContext };\r\n","import { createComponent } from '../component';\r\nimport { useEffect } from '../use-effect';\r\nimport { componentFiberHelper } from '../scope';\r\nimport { useContext } from '../use-context';\r\nimport { detectIsFunction } from '../helpers';\r\nimport type { Context, ContexProviderProps } from './types';\r\n\r\nfunction createContext<T>(defaultValue: T): Context<T> {\r\n  let displayName = 'Context';\r\n  const context: Context<T> = {\r\n    displayName,\r\n    defaultValue,\r\n    Provider: null,\r\n    Consumer: null,\r\n  };\r\n\r\n  mutateContext(context, defaultValue, displayName);\r\n\r\n  Object.defineProperty(context, 'displayName', {\r\n    get: () => displayName,\r\n    set: (newValue: string) => {\r\n      displayName = newValue;\r\n      mutateContext(context, defaultValue, displayName);\r\n    },\r\n  });\r\n\r\n  return context;\r\n}\r\n\r\nfunction mutateContext<T>(context: Context<T>, defaultValue: T, displayName: string) {\r\n  context.Provider = createProvider(context, defaultValue, displayName);\r\n  context.Consumer = createConsumer(context, displayName);\r\n}\r\n\r\nfunction createProvider<T>(context: Context<T>, defaultValue: T, displayName: string) {\r\n  return createComponent<ContexProviderProps<T>>(\r\n    ({ value = defaultValue, slot }) => {\r\n      const fiber = componentFiberHelper.get();\r\n\r\n      if (!fiber.provider) {\r\n        fiber.provider = new Map();\r\n      }\r\n\r\n      if (!fiber.provider.get(context)) {\r\n        fiber.provider.set(context, {\r\n          subscribers: [],\r\n          value,\r\n        });\r\n      }\r\n\r\n      const provider = fiber.provider.get(context);\r\n\r\n      useEffect(() => {\r\n        for (const subscriber of provider.subscribers) {\r\n          subscriber(value);\r\n        }\r\n      }, [value]);\r\n\r\n      provider.value = value;\r\n\r\n      return slot;\r\n    },\r\n    { displayName: `${displayName}.Provider` },\r\n  );\r\n}\r\n\r\nfunction createConsumer<T>(context: Context<T>, displayName: string) {\r\n  return createComponent(\r\n    ({ slot }) => {\r\n      const value = useContext(context);\r\n\r\n      return detectIsFunction(slot) ? slot(value) : null;\r\n    },\r\n    { displayName: `${displayName}.Consumer` },\r\n  );\r\n}\r\n\r\nexport { createContext };\r\n","import { detectIsNumber, detectIsString, detectIsFunction } from '../helpers';\r\nimport { View, Text, type TagVirtualNodeFactory } from '../view';\r\n\r\nfunction getChildren(children: Array<any>) {\r\n  children = children.map(x => (detectIsString(x) || detectIsNumber(x) ? Text(x.toString()) : x));\r\n\r\n  return children ? (Array.isArray(children) ? [...children] : [children]) : [];\r\n}\r\n\r\nfunction createElement(\r\n  tag: string | Function,\r\n  props: any,\r\n  ...children: Array<any>\r\n): TagVirtualNodeFactory | Function | null {\r\n  if (detectIsString(tag)) {\r\n    return View({\r\n      ...props,\r\n      as: tag,\r\n      slot: getChildren(children),\r\n    });\r\n  }\r\n\r\n  if (detectIsFunction(tag)) {\r\n    let slot = getChildren(children);\r\n\r\n    slot = slot.length === 1 ? slot[0] : slot;\r\n\r\n    return tag({ ...props, slot });\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { createElement };\r\n","import { useMemo } from '../use-memo';\r\n\r\nfunction useCallback<T = Function>(callback: T, deps: Array<any>): T {\r\n  const value = useMemo(() => callback, deps);\r\n\r\n  return value;\r\n}\r\n\r\nexport { useCallback };\r\n","import { type ScheduleCallbackOptions } from '../platform';\r\nimport { detectIsUndefined, detectIsFunction } from '../helpers';\r\nimport { componentFiberHelper } from '../scope';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\nimport { TaskPriority } from '../constants';\r\n\r\ntype Value<T> = T | ((prevValue: T) => T);\r\ntype Scope = {\r\n  idx: number;\r\n  values: Array<any>;\r\n};\r\n\r\nfunction useState<T = unknown>(initialValue: T, options?: ScheduleCallbackOptions): [T, (value: Value<T>) => void] {\r\n  const fiber = componentFiberHelper.get();\r\n  const update = useUpdate(options);\r\n  const scope: Scope = useMemo(\r\n    () => ({\r\n      idx: fiber.hook.idx,\r\n      values: fiber.hook.values,\r\n    }),\r\n    [],\r\n  );\r\n  const setState = useCallback((sourceValue: Value<T>) => {\r\n    const value = scope.values[scope.idx];\r\n    const newValue = detectIsFunction(sourceValue) ? sourceValue(value) : sourceValue;\r\n\r\n    if (!Object.is(value, newValue)) {\r\n      const setValue = () => {\r\n        scope.values[scope.idx] = newValue;\r\n      };\r\n\r\n      if (options?.priority === TaskPriority.LOW) {\r\n        update(() => setValue());\r\n      } else {\r\n        setValue();\r\n        update();\r\n      }\r\n    }\r\n  }, []);\r\n  const { hook } = fiber;\r\n  const { idx, values } = hook;\r\n  const value: T = !detectIsUndefined(values[idx]) ? values[idx] : initialValue;\r\n\r\n  values[idx] = value;\r\n  scope.idx = idx;\r\n  scope.values = values;\r\n  hook.idx++;\r\n\r\n  return [value, setState];\r\n}\r\n\r\nexport { useState };\r\n","import { createComponent } from '../component';\r\nimport { useState } from '../use-state';\r\nimport { createContext } from '../context';\r\nimport { useContext } from '../use-context';\r\nimport { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\nimport type { DarkElement } from '../shared';\r\n\r\ntype SuspenseProps = {\r\n  fallback: DarkElement;\r\n};\r\n\r\ntype SuspenseContextValue = {\r\n  fallback: DarkElement;\r\n  isLoaded: boolean;\r\n  trigger: () => void;\r\n};\r\n\r\nconst SuspenseContext = createContext<SuspenseContextValue>({\r\n  fallback: null,\r\n  isLoaded: true,\r\n  trigger: () => {},\r\n});\r\n\r\nconst Suspense = createComponent<SuspenseProps>(({ fallback, slot }) => {\r\n  if (!fallback) {\r\n    throw new Error(`[Dark]: Suspense fallback not found`);\r\n  }\r\n  const { isLoaded: isSuspenseLoaded } = useContext(SuspenseContext);\r\n  const [isLoaded, setIsLoaded] = useState(false);\r\n  const trigger = useCallback(() => setIsLoaded(true), []);\r\n  const value = useMemo(() => ({ fallback, isLoaded, trigger }), [fallback, isLoaded]);\r\n\r\n  return SuspenseContext.Provider({\r\n    value,\r\n    slot: isSuspenseLoaded ? slot : null,\r\n  });\r\n});\r\n\r\nexport { SuspenseContext, Suspense };\r\n","import { type Component, createComponent, detectIsComponentFactory } from '../component';\r\nimport { useState } from '../use-state';\r\nimport { useEffect } from '../use-effect';\r\nimport { forwardRef } from '../ref';\r\nimport { SuspenseContext } from '../suspense';\r\nimport { useContext } from '../use-context';\r\n\r\nconst $$lazy = Symbol('lazy');\r\n\r\ntype LazyScope<P, R> = {\r\n  component: Component<P, R>;\r\n};\r\n\r\nfunction lazy<P, R = unknown>(dynamic: () => Promise<{ default: Component<P> }>) {\r\n  return forwardRef(\r\n    createComponent<P, R>(\r\n      (props, ref) => {\r\n        const { fallback, trigger } = useContext(SuspenseContext);\r\n        const [scope, setScope] = useState<LazyScope<P, R>>({\r\n          component: null,\r\n        });\r\n\r\n        useEffect(() => {\r\n          fetchModule(dynamic).then(component => {\r\n            setScope({ component });\r\n          });\r\n        }, []);\r\n\r\n        useEffect(() => {\r\n          if (!scope.component) return;\r\n          trigger();\r\n        }, [scope.component]);\r\n\r\n        return scope.component ? scope.component(props, ref) : fallback;\r\n      },\r\n      { token: $$lazy },\r\n    ),\r\n  );\r\n}\r\n\r\nconst detectIsLazy = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$lazy;\r\n\r\nfunction fetchModule(dynamic: () => Promise<{ default: Component }>) {\r\n  return new Promise<Component>(resolve => {\r\n    dynamic().then(module => {\r\n      if (!module.default) {\r\n        throw new Error('[Dark]: lazy loaded component should be exported as default!');\r\n      }\r\n\r\n      resolve(module.default);\r\n    });\r\n  });\r\n}\r\n\r\nexport { lazy, detectIsLazy };\r\n","import { useState } from '../use-state';\r\nimport { useEffect } from '../use-effect';\r\nimport { TaskPriority } from '../constants';\r\n\r\ntype UseDeferredValueOprions = {\r\n  timeoutMs: number;\r\n};\r\n\r\nfunction useDeferredValue<T>(value: T, options?: UseDeferredValueOprions): T {\r\n  const { timeoutMs } = options || {};\r\n  const [deferredValue, setDeferredValue] = useState(value, {\r\n    priority: TaskPriority.LOW,\r\n    timeoutMs,\r\n  });\r\n\r\n  useEffect(() => {\r\n    setDeferredValue(value);\r\n  }, [value]);\r\n\r\n  return deferredValue;\r\n}\r\n\r\nexport { useDeferredValue };\r\n","import { componentFiberHelper } from '../scope';\r\nimport { useEffect } from '../use-effect';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\n\r\ntype ErrorScope = {\r\n  error: Error;\r\n};\r\n\r\nfunction useError(): Error | null {\r\n  const fiber = componentFiberHelper.get();\r\n  const update = useUpdate();\r\n  const scope: ErrorScope = useMemo(() => ({ error: null }), []);\r\n\r\n  fiber.catchException = (error: Error) => {\r\n    scope.error = error;\r\n    update();\r\n  };\r\n\r\n  useEffect(() => {\r\n    scope.error = null;\r\n  }, [scope.error]);\r\n\r\n  return scope.error;\r\n}\r\n\r\nexport { useError };\r\n","import { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\n\r\nfunction useEvent<T extends (...args) => any>(fn: T) {\r\n  const scope = useMemo(() => ({ fn }), []);\r\n\r\n  scope.fn = fn;\r\n\r\n  const callback = useCallback((...args) => {\r\n    return scope.fn(...args);\r\n  }, []);\r\n\r\n  return callback as unknown as T;\r\n}\r\n\r\nexport { useEvent };\r\n","import { useMemo } from '../use-memo';\r\nimport type { MutableRef } from '../ref';\r\n\r\nfunction useImperativeHandle<T>(ref: MutableRef<T>, createHandle: () => T, deps: Array<any>) {\r\n  const current = useMemo(() => createHandle(), deps);\r\n\r\n  ref.current = current;\r\n}\r\n\r\nexport { useImperativeHandle };\r\n","import { useState } from '../use-state';\r\nimport { useCallback } from '../use-callback';\r\nimport { useMemo } from '../use-memo';\r\nimport { detectIsFunction } from '../helpers';\r\nimport type { Reducer, Dispatch, ReducerAction, ReducerState } from './types';\r\n\r\nfunction useReducer<R extends Reducer>(\r\n  reducer: R,\r\n  initialState: ReducerState<R>,\r\n  initializer?: (state: ReducerState<R>) => ReducerState<R>,\r\n): [ReducerState<R>, Dispatch<ReducerAction<R>>] {\r\n  const initialValue = useMemo(() => {\r\n    return detectIsFunction(initializer) ? initializer(initialState) : initialState;\r\n  }, []);\r\n  const [state, setState] = useState<ReducerState<R>>(initialValue);\r\n  const dispatch = useCallback((action: ReducerAction<R>) => setState(state => reducer(state, action)), []) as Dispatch<\r\n    ReducerAction<R>\r\n  >;\r\n\r\n  return [state, dispatch];\r\n}\r\n\r\nexport { useReducer };\r\n","import { useMemo } from '../use-memo';\r\nimport type { MutableRef } from '../ref';\r\n\r\nfunction useRef<T>(initialValue: T = null): MutableRef<T> {\r\n  const ref = useMemo(() => ({ current: initialValue }), []) as MutableRef<T>;\r\n\r\n  return ref;\r\n}\r\n\r\nexport { useRef };\r\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","TaskPriority","ROOT","EMPTY_NODE","ATTR_KEY","ATTR_REF","PARTIAL_UPDATE","detectIsFunction","detectIsUndefined","detectIsNumber","detectIsString","detectIsObject","detectIsBoolean","detectIsArray","Array","isArray","detectIsNull","detectIsEmpty","error","str","console","flatten","source","list","levelMap","idx","level","item","length","push","getTime","Date","now","keyBy","fn","reduce","acc","x","takeListFromEnd","count","slice","dummyFn","detectIsDepsDifferent","deps","prevDeps","i","defaultOptions","displayName","defaultProps","token","options","children","this","type","props","ref","shouldUpdate","createComponent","createElement","computedOptions","computedProps","ComponentFactory","NodeType","detectIsComponentFactory","getComponentFactoryKey","wipRoot","currentRoot","nextUnitOfWork","fromHookUpdate","events","Map","unsubscribers","deletions","fiberMount","navigation","isDeepWalking","componentFiber","effects","layoutEffects","rootId","stores","effectStoreHelper","set","id","effectStore","remove","delete","getRootId","Store","storeHelper","wipRootHelper","fiber","currentRootHelper","nextUnitOfWorkHelper","componentFiberHelper","fromHookUpdateHelper","eventsHelper","addUnsubscriber","mapUnsubscribers","forEach","deletionsHelper","fiberMountHelper","reset","getIndex","jumpToChild","nextLevel","jumpToParent","jumpToSibling","deepWalking","effectsHelper","add","effect","layoutEffectsHelper","createEffect","useEffect","hasEffects","dropEffects","store","hook","values","runEffect","undefined","cleanup","some","$$virtualNode","TAG","name","isVoid","attrs","VirtualNode","text","TEXT","COMMENT","detectIsVirtualNode","vNode","detectIsTagVirtualNode","TagVirtualNode","detectIsCommentVirtualNode","CommentVirtualNode","detectIsTextVirtualNode","TextVirtualNode","detectIsEmptyVirtualNode","getVirtualNodeKey","Text","Comment","View","def","as","slot","rest","createEmptyVirtualNode","detectIsVirtualNodeFactory","$$fragment","Fragment","detectIsFragment","forwardRef","component","detectIsRef","mutableRef","$$memo","defaultShouldUpdate","nextProps","keys","detectIsMemo","memo","Memo","processValue","getValue","isDepsDifferent","check","wrap","useMemo","hookValue","computedGetValue","EffectTag","platform","scheduleCallback","Error","shouldYeildToHost","createNativeElement","applyCommit","finishCommitWork","detectIsPortal","unmountPortal","cloneTagMap","PLACEMENT","SKIP","useLayoutEffect","hasLayoutEffects","dropLayoutEffects","walkFiber","onLoop","nextFiber","isReturn","isStopped","visitedMap","detectCanVisit","resetIsDeepWalking","stop","child","newFiber","nextSibling","parent","unmountFiber","effectHost","layoutEffectHost","portalHost","transposition","instance","unmountRoot","onComplete","nativeElement","alternate","effectTag","shadow","provider","mountedToHost","childrenCount","marker","isUsed","markPortalHost","markEffectHost","markLayoutEffectHost","setError","catchException","workLoop","wipFiber","shouldYield","hasMoreWork","Boolean","performUnitOfWork","fromHook","hasPortals","layoutEffect","setTimeout","commitChanges","hasChildrenProp","performChild","performedFiber","performSibling","performPartialUpdateEffects","DELETION","getChildAlternate","getHook","Fiber","pertformInstance","mutateAlternate","mutateFiber","performMemo","performedNextFiber","performedShadow","performedInstance","childrenIdx","getNextSiblingAlternate","isDifferentKeys","getElementKey","isUpdate","getInstanceType","UPDATE","alternateType","isSameType","isSameKeys","isRemovingCase","isInsertingCase","prevKeys","nextKeys","nextKey","extractKeys","diffKeys","getDiffKeys","fibersMap","map","createFibersByKeyMap","diffCount","fibers","getSiblingFibers","performRemovingNodes","diffKeyMap","fibersByPositionsMap","position","createFibersByPositionMap","usedKeyMap","keyIdx","insertionFiber","performInsertingNodes","memoFiber","alternateFactory","elements","splice","getAlternateByKey","getRootShadow","mountInstance","isComponentFactory","result","err","transformElementInstance","nextKeysMap","diff","element","createHook","createUpdateCallback","forceStart","onStart","useUpdate","scope","callback","timeoutMs","useContext","context","defaultValue","getProvider","update","prevValue","hasProvider","subscriber","newValue","is","subscribers","findIndex","createContext","Provider","Consumer","mutateContext","createProvider","createConsumer","getChildren","toString","tag","useCallback","useState","initialValue","setState","sourceValue","priority","LOW","SuspenseContext","fallback","isLoaded","trigger","Suspense","isSuspenseLoaded","setIsLoaded","$$lazy","lazy","dynamic","setScope","Promise","resolve","then","default","fetchModule","detectIsLazy","useDeferredValue","deferredValue","setDeferredValue","useError","useEvent","args","useImperativeHandle","createHandle","current","useReducer","reducer","initialState","initializer","state","dispatch","action","useRef"],"sourceRoot":""}