{"version":3,"file":"dark-core.production.min.js","mappings":"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","sources":["webpack://DarkCore/webpack/universalModuleDefinition","webpack://DarkCore/webpack/bootstrap","webpack://DarkCore/webpack/runtime/define property getters","webpack://DarkCore/webpack/runtime/hasOwnProperty shorthand","webpack://DarkCore/webpack/runtime/make namespace object","webpack://DarkCore/./src/constants.ts","webpack://DarkCore/./src/helpers/index.ts","webpack://DarkCore/./src/component/component.ts","webpack://DarkCore/./src/scope/scope.ts","webpack://DarkCore/./src/shared/index.ts","webpack://DarkCore/./src/view/model.ts","webpack://DarkCore/./src/use-effect/use-effect.ts","webpack://DarkCore/./src/view/view.ts","webpack://DarkCore/./src/ref/ref.ts","webpack://DarkCore/./src/memo/memo.ts","webpack://DarkCore/./src/use-memo/use-memo.ts","webpack://DarkCore/./src/global/global.ts","webpack://DarkCore/./src/fiber/model.ts","webpack://DarkCore/./src/fiber/fiber.ts","webpack://DarkCore/./src/use-update/use-update.ts","webpack://DarkCore/./src/use-context/use-context.ts","webpack://DarkCore/./src/context/context.ts","webpack://DarkCore/./src/element/element.ts","webpack://DarkCore/./src/fragment/fragment.ts","webpack://DarkCore/./src/use-callback/use-callback.ts","webpack://DarkCore/./src/use-state/use-state.ts","webpack://DarkCore/./src/suspense/suspense.ts","webpack://DarkCore/./src/lazy/lazy.ts","webpack://DarkCore/./src/use-error/use-error.ts","webpack://DarkCore/./src/use-imperative-handle/use-imperative-handle.ts","webpack://DarkCore/./src/use-reducer/use-reducer.ts","webpack://DarkCore/./src/use-ref/use-ref.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"DarkCore\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"DarkCore\"] = factory();\n\telse\n\t\troot[\"DarkCore\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const ROOT = 'root';\r\nexport const EMPTY_NODE = 'dark:matter';\r\nexport const ATTR_KEY = 'key';\r\nexport const ATTR_REF = 'ref';\r\n","import type { NestedArray } from '../shared';\r\n\r\nconst detectIsFunction = (o: any): o is Function => typeof o === 'function';\r\nconst detectIsUndefined = (o: any) => typeof o === 'undefined';\r\nconst detectIsNumber = (o: any) => typeof o === 'number';\r\nconst detectIsString = (o: any) => typeof o === 'string';\r\nconst detectIsObject = (o: any) => typeof o === 'object';\r\nconst detectIsBoolean = (o: any) => typeof o === 'boolean';\r\nconst detectIsArray = (o: any): o is Array<any> => Array.isArray(o);\r\nconst detectIsNull = (o: any) => o === null;\r\nconst detectIsEmpty = (o: any) => detectIsNull(o) || detectIsUndefined(o);\r\n\r\nfunction error(str: string) {\r\n  if (typeof console !== 'undefined') {\r\n    console.error(str);\r\n  }\r\n}\r\n\r\nfunction flatten<T = any>(source: Array<NestedArray<T>>): Array<T> {\r\n  const list = [];\r\n  const levelMap = { 0: { idx: 0, source } };\r\n  let level = 0;\r\n\r\n  do {\r\n    const { source, idx } = levelMap[level];\r\n    const item = source[idx];\r\n\r\n    if (idx >= source.length) {\r\n      level--;\r\n      levelMap[level].idx++;\r\n      continue;\r\n    }\r\n\r\n    if (detectIsArray(item)) {\r\n      level++;\r\n      levelMap[level] = {\r\n        idx: 0,\r\n        source: item,\r\n      };\r\n    } else {\r\n      list.push(item);\r\n      levelMap[level].idx++;\r\n    }\r\n  } while (!(level === 0 && levelMap[level].idx >= levelMap[level].source.length));\r\n\r\n  return list;\r\n}\r\n\r\nfunction getTime() {\r\n  return performance.now();\r\n}\r\n\r\nfunction keyBy<T = any>(\r\n  list: Array<T>,\r\n  fn: (o: T) => string | number,\r\n  value = false,\r\n): Record<string | number, T | boolean> {\r\n  return list.reduce((acc, x) => ((acc[fn(x)] = value ? x : true), acc), {});\r\n}\r\n\r\nfunction takeListFromEnd(source: Array<any>, count: number) {\r\n  const list = [];\r\n\r\n  for (let i = 0; i <= count; i++) {\r\n    const idx = source.length - i - 1;\r\n    list.push(source[idx]);\r\n  }\r\n\r\n  return list;\r\n}\r\n\r\nexport {\r\n  detectIsFunction,\r\n  detectIsUndefined,\r\n  detectIsNumber,\r\n  detectIsString,\r\n  detectIsObject,\r\n  detectIsBoolean,\r\n  detectIsArray,\r\n  detectIsNull,\r\n  detectIsEmpty,\r\n  error,\r\n  flatten,\r\n  getTime,\r\n  keyBy,\r\n  takeListFromEnd,\r\n};\r\n","import { ATTR_KEY } from '../constants';\r\nimport { error, detectIsEmpty } from '../helpers';\r\nimport type { DarkElementKey, DarkElementInstance } from '../shared/model';\r\nimport type { MutableRef } from '../ref';\r\nimport type { CreateElement, ComponentOptions, StandardComponentProps, SlotProps } from './model';\r\n\r\nconst $$component = Symbol('component');\r\nconst defaultOptions: ComponentOptions<any> = {\r\n  displayName: '',\r\n  defaultProps: {},\r\n  token: $$component,\r\n};\r\nclass ComponentFactory<P extends StandardComponentProps = any, R = any> {\r\n  public type: CreateElement<P>;\r\n  public token: Symbol;\r\n  public props: P;\r\n  public ref: MutableRef<R>;\r\n  public displayName: string;\r\n  public children: Array<DarkElementInstance> = [];\r\n  public shouldUpdate?: (props: P, nextProps: P) => boolean;\r\n\r\n  constructor(options: ComponentFactory<P>) {\r\n    this.type = options.type || null;\r\n    this.token = options.token || null;\r\n    this.props = options.props || null;\r\n    this.ref = options.ref || null;\r\n    this.displayName = options.displayName || '';\r\n    this.shouldUpdate = options.shouldUpdate || null;\r\n  }\r\n}\r\n\r\nfunction createComponent<P, R = any>(\r\n  createElement: CreateElement<P & SlotProps, R>,\r\n  options: ComponentOptions<P> = {},\r\n) {\r\n  type Props = P & StandardComponentProps;\r\n  const computedOptions = { ...defaultOptions, ...options };\r\n  const { token, defaultProps, displayName, shouldUpdate } = computedOptions;\r\n\r\n  return (props = {} as Props, ref?: MutableRef<R>): ComponentFactory<Props> => {\r\n    const computedProps = { ...defaultProps, ...props };\r\n    const factory = new ComponentFactory({\r\n      token,\r\n      ref,\r\n      displayName,\r\n      shouldUpdate,\r\n      props: computedProps,\r\n      type: createElement,\r\n      children: [],\r\n    });\r\n\r\n    if (computedProps.ref) {\r\n      delete computedProps.ref;\r\n\r\n      if (process.env.NODE_ENV === 'development') {\r\n        error(`[Dark]: To use ref you need to wrap the createComponent with forwardRef!`);\r\n      }\r\n    }\r\n\r\n    return factory;\r\n  };\r\n}\r\n\r\nconst detectIsComponentFactory = (factory: unknown): factory is ComponentFactory => factory instanceof ComponentFactory;\r\n\r\nconst getComponentFactoryKey = (factory: ComponentFactory): DarkElementKey =>\r\n  !detectIsEmpty(factory.props[ATTR_KEY]) ? factory.props[ATTR_KEY] : null;\r\n\r\nexport { ComponentFactory, createComponent, detectIsComponentFactory, getComponentFactoryKey };\r\n","import type { Fiber } from '../fiber';\r\n\r\nclass Store {\r\n  public wipRoot: Fiber = null;\r\n  public currentRoot: Fiber = null;\r\n  public nextUnitOfWork: Fiber = null;\r\n  public fromHookUpdate = false;\r\n  public events: Map<string, WeakMap<object, Function>> = new Map();\r\n  public deletions: Array<Fiber> = [];\r\n  public fiberMount = {\r\n    level: 0,\r\n    navigation: {},\r\n    isDeepWalking: true,\r\n  };\r\n  public componentFiber: Fiber = null;\r\n  public effects: Array<() => void> = [];\r\n}\r\n\r\nlet rootId = null;\r\nconst stores = new Map<number, Store>();\r\n\r\nconst effectStoreHelper = {\r\n  set: (id: number) => effectStore(id),\r\n};\r\n\r\nconst getRootId = (): number => rootId;\r\n\r\nconst effectStore = (id: number) => {\r\n  rootId = id;\r\n  !stores.get(rootId) && stores.set(rootId, new Store());\r\n};\r\n\r\nconst storeHelper = {\r\n  get: (id: number = rootId) => stores.get(id),\r\n};\r\n\r\nconst wipRootHelper = {\r\n  get: () => storeHelper.get()?.wipRoot || null,\r\n  set: (fiber: Fiber) => (storeHelper.get().wipRoot = fiber),\r\n};\r\n\r\nconst currentRootHelper = {\r\n  get: () => storeHelper.get()?.currentRoot || null,\r\n  set: (fiber: Fiber) => (storeHelper.get().currentRoot = fiber),\r\n};\r\n\r\nconst nextUnitOfWorkHelper = {\r\n  get: () => storeHelper.get()?.nextUnitOfWork || null,\r\n  set: (fiber: Fiber) => (storeHelper.get().nextUnitOfWork = fiber),\r\n};\r\n\r\nconst componentFiberHelper = {\r\n  get: () => storeHelper.get()?.componentFiber,\r\n  set: (fiber: Fiber) => (storeHelper.get().componentFiber = fiber),\r\n};\r\n\r\nconst fromHookUpdateHelper = {\r\n  get: () => storeHelper.get()?.fromHookUpdate || false,\r\n  set: (value: boolean) => (storeHelper.get().fromHookUpdate = value),\r\n};\r\n\r\nconst eventsHelper = {\r\n  get: () => storeHelper.get().events,\r\n};\r\n\r\nconst deletionsHelper = {\r\n  get: () => storeHelper.get().deletions,\r\n  set: (deletions: Array<Fiber>) => (storeHelper.get().deletions = deletions),\r\n};\r\n\r\nconst fiberMountHelper = {\r\n  reset: () => {\r\n    storeHelper.get().fiberMount = {\r\n      level: 0,\r\n      navigation: {},\r\n      isDeepWalking: true,\r\n    };\r\n  },\r\n  getIndex: () => storeHelper.get().fiberMount.navigation[storeHelper.get().fiberMount.level],\r\n  jumpToChild: () => {\r\n    const { fiberMount } = storeHelper.get();\r\n    const level = fiberMount.level;\r\n    const nextLevel = level + 1;\r\n\r\n    fiberMount.level = nextLevel;\r\n    fiberMount.navigation[nextLevel] = 0;\r\n  },\r\n  jumpToParent: () => {\r\n    const { fiberMount } = storeHelper.get();\r\n    const level = fiberMount.level;\r\n    const nextLevel = level - 1;\r\n\r\n    fiberMount.navigation[level] = 0;\r\n    fiberMount.level = nextLevel;\r\n  },\r\n  jumpToSibling: () => {\r\n    const { fiberMount } = storeHelper.get();\r\n    const level = fiberMount.level;\r\n    const idx = fiberMount.navigation[level] + 1;\r\n\r\n    fiberMount.navigation[level] = idx;\r\n  },\r\n  deepWalking: {\r\n    get: () => storeHelper.get().fiberMount.isDeepWalking,\r\n    set: (value: boolean) => (storeHelper.get().fiberMount.isDeepWalking = value),\r\n  },\r\n};\r\n\r\nconst effectsHelper = {\r\n  get: () => storeHelper.get().effects,\r\n  reset: () => (storeHelper.get().effects = []),\r\n  add: (effect: () => void) => storeHelper.get().effects.push(effect),\r\n};\r\n\r\nexport {\r\n  getRootId,\r\n  effectStoreHelper,\r\n  wipRootHelper,\r\n  currentRootHelper,\r\n  nextUnitOfWorkHelper,\r\n  componentFiberHelper,\r\n  fromHookUpdateHelper,\r\n  eventsHelper,\r\n  deletionsHelper,\r\n  fiberMountHelper,\r\n  effectsHelper,\r\n};\r\n","import { detectIsUndefined } from '@dark-engine/core/helpers';\r\n\r\nfunction detectIsDepsDifferent(deps: Array<unknown>, prevDeps: Array<unknown>): boolean {\r\n  if (!detectIsUndefined(deps) && !detectIsUndefined(prevDeps) && deps.length > 0 && prevDeps.length > 0) {\r\n    for (let i = 0; i < prevDeps.length; i++) {\r\n      if (prevDeps[i] !== deps[i]) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport * from './model';\r\nexport { detectIsDepsDifferent };\r\n","export type ViewDef = {\r\n  as: string;\r\n  slot?: any;\r\n  isVoid?: boolean;\r\n  [prop: string]: any;\r\n};\r\n\r\nexport enum NodeType {\r\n  TAG = 'TAG',\r\n  TEXT = 'TEXT',\r\n  COMMENT = 'COMMENT',\r\n}\r\n","import { detectIsUndefined, detectIsFunction } from '../helpers';\r\nimport { componentFiberHelper, effectsHelper } from '../scope';\r\nimport type { Hook, HookValue } from '../fiber';\r\nimport { detectIsDepsDifferent } from '../shared';\r\nimport type { Effect, EffectCleanup } from './model';\r\n\r\nconst $$useEffect = Symbol('use-effect');\r\n\r\nfunction useEffect(effect: Effect, deps?: Array<any>) {\r\n  const fiber = componentFiberHelper.get();\r\n  const hook = fiber.hook as Hook<HookValue<EffectCleanup>>;\r\n  const { idx, values } = hook;\r\n  const runEffect = () => {\r\n    const run = () => {\r\n      values[idx] = {\r\n        deps,\r\n        value: effect(),\r\n        token: $$useEffect,\r\n      };\r\n    };\r\n\r\n    effectsHelper.add(() => setTimeout(run));\r\n  };\r\n\r\n  if (detectIsUndefined(values[idx])) {\r\n    runEffect();\r\n  } else {\r\n    const { deps: prevDeps, value: cleanup } = values[idx];\r\n    const isDepsDifferent = deps ? detectIsDepsDifferent(deps, prevDeps) : true;\r\n\r\n    if (isDepsDifferent) {\r\n      detectIsFunction(cleanup) && cleanup();\r\n      runEffect();\r\n    }\r\n  }\r\n\r\n  hook.idx++;\r\n}\r\n\r\nfunction runEffectCleanup(hook: Hook<HookValue<EffectCleanup>>) {\r\n  const { values } = hook;\r\n\r\n  for (const hookValue of values) {\r\n    if (hookValue.token === $$useEffect) {\r\n      const cleanup = hookValue.value;\r\n\r\n      detectIsFunction(cleanup) && cleanup();\r\n    }\r\n  }\r\n}\r\n\r\nexport { useEffect, runEffectCleanup };\r\n","import { EMPTY_NODE, ATTR_KEY } from '../constants';\r\nimport { detectIsArray, detectIsEmpty, detectIsFunction } from '../helpers';\r\nimport type { DarkElementKey } from '../shared/model';\r\nimport type { ComponentFactory, StandardComponentProps } from '../component';\r\nimport { NodeType, type ViewDef } from './model';\r\n\r\nexport type VirtualNodeFactory = () => VirtualNode;\r\nexport type TagVirtualNodeFactory = () => TagVirtualNode;\r\nexport type TextVirtualNodeFactory = () => TextVirtualNode;\r\nexport type CommentVirtualNodeFactory = () => CommentVirtualNode;\r\n\r\nconst $$virtualNode = Symbol('virtual-node');\r\nclass VirtualNode {\r\n  public type: NodeType = null;\r\n\r\n  constructor(options: Partial<VirtualNode>) {\r\n    this.type = options.type;\r\n  }\r\n}\r\n\r\nclass TagVirtualNode extends VirtualNode {\r\n  public type = NodeType.TAG;\r\n  public name: string = null;\r\n  public isVoid = false;\r\n  public attrs: Record<string, any> = {};\r\n  public children: Array<VirtualNodeFactory | ComponentFactory> = [];\r\n\r\n  constructor(options: Partial<TagVirtualNode>) {\r\n    super(options);\r\n    this.name = options.name || this.name;\r\n    this.isVoid = options.isVoid || this.isVoid;\r\n    this.attrs = options.attrs || this.attrs;\r\n    this.children = options.children || this.children;\r\n  }\r\n}\r\n\r\nclass TextVirtualNode extends VirtualNode {\r\n  public type = NodeType.TEXT;\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super({});\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nclass CommentVirtualNode extends VirtualNode {\r\n  public type = NodeType.COMMENT;\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super({});\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nconst detectIsVirtualNode = (vNode: unknown): vNode is VirtualNode => vNode instanceof VirtualNode;\r\nconst detectIsTagVirtualNode = (vNode: unknown): vNode is TagVirtualNode => vNode instanceof TagVirtualNode;\r\nconst detectIsCommentVirtualNode = (vNode: unknown): vNode is CommentVirtualNode => vNode instanceof CommentVirtualNode;\r\nconst detectIsTextVirtualNode = (vNode: unknown): vNode is TextVirtualNode => vNode instanceof TextVirtualNode;\r\nconst detectIsEmptyVirtualNode = (vNode: CommentVirtualNode): boolean =>\r\n  detectIsCommentVirtualNode(vNode) && vNode.value === EMPTY_NODE;\r\n\r\nfunction getVirtualNodeKey(vNode: TagVirtualNode): DarkElementKey | null {\r\n  const key = vNode && vNode.attrs[ATTR_KEY];\r\n\r\n  return !detectIsEmpty(key) ? key : null;\r\n}\r\n\r\nfunction getAttribute(vNode: VirtualNode, attrName: string) {\r\n  return detectIsTagVirtualNode(vNode) && !detectIsEmpty(vNode.attrs[attrName]) ? vNode.attrs[attrName] : undefined;\r\n}\r\n\r\nfunction setAttribute(vNode: VirtualNode, name: string, value: any) {\r\n  detectIsTagVirtualNode(vNode) && (vNode.attrs[name] = value);\r\n}\r\n\r\nfunction Text(source: string | StandardComponentProps['slot']): string | TextVirtualNode {\r\n  const text =\r\n    typeof source === 'string' ? new TextVirtualNode(source) : detectIsTextVirtualNode(source) ? source.value : '';\r\n\r\n  return text;\r\n}\r\n\r\nfunction Comment(text: string): CommentVirtualNodeFactory {\r\n  const factory = () => new CommentVirtualNode(text);\r\n\r\n  factory[$$virtualNode] = true;\r\n\r\n  return factory;\r\n}\r\n\r\nfunction View(def: ViewDef): TagVirtualNodeFactory {\r\n  const factory = () => {\r\n    const { as, slot, isVoid = false, ...rest } = def;\r\n    const children = isVoid ? [] : detectIsArray(slot) ? slot : slot ? [slot] : [];\r\n\r\n    return new TagVirtualNode({\r\n      name: as,\r\n      isVoid,\r\n      attrs: { ...rest },\r\n      children: children as Array<VirtualNodeFactory>,\r\n    });\r\n  };\r\n\r\n  factory[$$virtualNode] = true;\r\n\r\n  return factory;\r\n}\r\n\r\nconst createEmptyVirtualNode = () => new CommentVirtualNode(EMPTY_NODE);\r\n\r\nconst detectIsVirtualNodeFactory = (factory: unknown): factory is VirtualNodeFactory =>\r\n  detectIsFunction(factory) && factory[$$virtualNode] === true;\r\n\r\nexport {\r\n  VirtualNode,\r\n  TagVirtualNode,\r\n  TextVirtualNode,\r\n  CommentVirtualNode,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsCommentVirtualNode,\r\n  detectIsTextVirtualNode,\r\n  detectIsEmptyVirtualNode,\r\n  getAttribute,\r\n  setAttribute,\r\n  getVirtualNodeKey,\r\n  Text,\r\n  Comment,\r\n  View,\r\n  createEmptyVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n};\r\n","import { detectIsObject, detectIsNull } from '../helpers';\r\nimport type { Component, RefProps, ComponentFactory } from '../component';\r\nimport type { MutableRef } from './model';\r\n\r\nfunction forwardRef<P, R>(component: Component<P, R>) {\r\n  type Props = P & RefProps<R>;\r\n\r\n  return ({ ref, ...rest }: Props) => {\r\n    return component(rest as P, ref) as ComponentFactory<P, R>;\r\n  };\r\n}\r\n\r\nconst detectIsRef = (ref: unknown) => {\r\n  if (!detectIsObject(ref) || detectIsNull(ref)) return false;\r\n  const mutableRef = ref as MutableRef;\r\n\r\n  for (const key in mutableRef) {\r\n    if (key === 'current' && mutableRef.hasOwnProperty(key)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport { forwardRef, detectIsRef };\r\n","import {\r\n  type Component,\r\n  type ComponentFactory,\r\n  type StandardComponentProps,\r\n  type RefProps,\r\n  type SlotProps,\r\n  createComponent,\r\n  detectIsComponentFactory,\r\n} from '../component';\r\nimport { type MutableRef, forwardRef } from '../ref';\r\n\r\ntype ShouldUpdate<T> = (props: T, nextProps: T) => boolean;\r\n\r\nconst $$memo = Symbol('memo');\r\n\r\nconst defaultShouldUpdate = (props: {}, nextProps: {}): boolean => {\r\n  const keys = Object.keys(nextProps);\r\n\r\n  for (const key of keys) {\r\n    if (key !== 'slot' && nextProps[key] !== props[key]) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst detectIsMemo = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$memo;\r\n\r\nfunction memo<T>(\r\n  component: (props: T, ref?: MutableRef<unknown>) => ComponentFactory<T, unknown>,\r\n  shouldUpdate: ShouldUpdate<T & SlotProps> = defaultShouldUpdate,\r\n): Component<T & StandardComponentProps> {\r\n  return forwardRef(\r\n    createComponent(\r\n      (props: T & RefProps, ref) => {\r\n        ref && (props.ref = ref);\r\n\r\n        return component(props);\r\n      },\r\n      { token: $$memo, shouldUpdate },\r\n    ),\r\n  );\r\n}\r\n\r\nexport { $$memo, memo, detectIsMemo };\r\n","import { detectIsUndefined, detectIsArray } from '../helpers';\r\nimport { detectIsComponentFactory, createComponent } from '../component';\r\nimport { detectIsTagVirtualNode } from '../view';\r\nimport { componentFiberHelper } from '../scope';\r\nimport { detectIsDepsDifferent } from '../shared';\r\nimport { $$memo } from '../memo';\r\n\r\nconst Memo = createComponent(({ slot }) => slot, { token: $$memo });\r\n\r\nfunction wrap(value: unknown, isDepsDifferent: boolean) {\r\n  if (detectIsTagVirtualNode(value) || detectIsComponentFactory(value)) {\r\n    const factory = Memo({ slot: value });\r\n\r\n    factory.shouldUpdate = () => isDepsDifferent;\r\n\r\n    return factory;\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction processValue(getValue: () => any, isDepsDifferent = false) {\r\n  let value = getValue();\r\n\r\n  if (detectIsArray(value)) {\r\n    value = value.map(x => wrap(x, isDepsDifferent));\r\n  } else {\r\n    value = wrap(value, isDepsDifferent);\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction useMemo(getValue: () => any, deps: Array<any>) {\r\n  const fiber = componentFiberHelper.get();\r\n  const { hook } = fiber;\r\n  const { idx, values } = hook;\r\n\r\n  if (detectIsUndefined(values[idx])) {\r\n    const value = processValue(getValue);\r\n\r\n    values[idx] = {\r\n      deps,\r\n      value,\r\n    };\r\n\r\n    hook.idx++;\r\n\r\n    return value;\r\n  }\r\n\r\n  const hookValue = values[idx];\r\n  const prevDeps = hookValue.deps as Array<any>;\r\n  const isDepsDifferent = detectIsDepsDifferent(deps, prevDeps);\r\n  const computedGetValue = isDepsDifferent ? getValue : () => hookValue.value;\r\n\r\n  hookValue.deps = deps;\r\n  hookValue.value = processValue(computedGetValue, isDepsDifferent);\r\n  hook.idx++;\r\n\r\n  return hookValue.value;\r\n}\r\n\r\nexport { useMemo };\r\n","import type { Platform } from './model';\r\n\r\nexport const platform: Platform = {\r\n  raf: () => {\r\n    throw new Error('raf not installed by renderer');\r\n  },\r\n  scheduleCallback: () => {\r\n    throw new Error('scheduleCallback not installed by renderer');\r\n  },\r\n  shouldYeildToHost: () => {\r\n    throw new Error('shouldYeildToHost not installed by renderer');\r\n  },\r\n  createNativeElement: () => {\r\n    throw new Error('createNativeElement not installed by renderer');\r\n  },\r\n  applyCommits: () => {\r\n    throw new Error('applyCommits not installed by renderer');\r\n  },\r\n  detectIsPortal: () => {\r\n    throw new Error('detectIsPortal not installed by renderer');\r\n  },\r\n  unmountPortal: () => {\r\n    throw new Error('unmountPortal not installed by renderer');\r\n  },\r\n};\r\n","export enum EffectTag {\r\n  PLACEMENT = 'PLACEMENT',\r\n  UPDATE = 'UPDATE',\r\n  DELETION = 'DELETION',\r\n  SKIP = 'SKIP',\r\n}\r\n\r\nexport type NativeElement = unknown;\r\n\r\nexport type HookValue<T = any> = {\r\n  token?: Symbol;\r\n  deps: Array<any>;\r\n  value: T;\r\n};\r\n\r\nexport type Hook<T = any> = {\r\n  idx: number;\r\n  values: Array<T>;\r\n};\r\n\r\nexport const cloneTagMap = {\r\n  [EffectTag.PLACEMENT]: true,\r\n  [EffectTag.SKIP]: true,\r\n};\r\n","import {\r\n  flatten,\r\n  detectIsEmpty,\r\n  error,\r\n  keyBy,\r\n  takeListFromEnd,\r\n  detectIsUndefined,\r\n  detectIsArray,\r\n  detectIsFunction,\r\n} from '../helpers';\r\nimport { platform } from '../global';\r\nimport {\r\n  getRootId,\r\n  wipRootHelper,\r\n  currentRootHelper,\r\n  nextUnitOfWorkHelper,\r\n  deletionsHelper,\r\n  fiberMountHelper,\r\n  componentFiberHelper,\r\n  fromHookUpdateHelper,\r\n  effectStoreHelper,\r\n  effectsHelper,\r\n} from '../scope';\r\nimport { type ComponentFactory, detectIsComponentFactory, getComponentFactoryKey } from '../component';\r\nimport {\r\n  type TagVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  createEmptyVirtualNode,\r\n  getVirtualNodeKey,\r\n  detectIsVirtualNode,\r\n  detectIsCommentVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n} from '../view';\r\nimport { detectIsMemo } from '../memo';\r\nimport type { Context, ContextProviderValue } from '../context/model';\r\nimport type { DarkElementKey, DarkElement, DarkElementInstance } from '../shared/model';\r\nimport { type NativeElement, type Hook, EffectTag, cloneTagMap } from './model';\r\n\r\nclass Fiber<N = NativeElement> {\r\n  public nativeElement: N;\r\n  public parent: Fiber<N>;\r\n  public child: Fiber<N>;\r\n  public nextSibling: Fiber<N>;\r\n  public alternate: Fiber<N>;\r\n  public effectTag: EffectTag;\r\n  public instance: DarkElementInstance;\r\n  public hook: Hook;\r\n  public shadow: Fiber<N>;\r\n  public provider: Map<Context, ContextProviderValue>;\r\n  public transposition: boolean;\r\n  public mountedToHost: boolean;\r\n  public portalHost: boolean;\r\n  public childrenCount: number;\r\n  public catchException: (error: Error) => void;\r\n\r\n  constructor(options: Partial<Fiber<N>>) {\r\n    this.nativeElement = options.nativeElement || null;\r\n    this.parent = options.parent || null;\r\n    this.child = options.child || null;\r\n    this.nextSibling = options.nextSibling || null;\r\n    this.alternate = options.alternate || null;\r\n    this.effectTag = options.effectTag || null;\r\n    this.instance = options.instance || null;\r\n    this.hook = options.hook || createHook();\r\n    this.shadow = options.shadow || null;\r\n    this.provider = options.provider || null;\r\n    this.transposition = !detectIsUndefined(options.transposition) ? options.transposition : false;\r\n    this.mountedToHost = !detectIsUndefined(options.mountedToHost) || false;\r\n    this.portalHost = !detectIsUndefined(options.portalHost) ? options.portalHost : false;\r\n    this.childrenCount = options.childrenCount || 0;\r\n  }\r\n\r\n  public markPortalHost() {\r\n    this.portalHost = true;\r\n    this.parent && !this.parent.portalHost && this.parent.markPortalHost();\r\n  }\r\n\r\n  public setError(error: Error) {\r\n    if (typeof this.catchException === 'function') {\r\n      this.catchException(error);\r\n    } else if (this.parent) {\r\n      this.parent.setError(error);\r\n    }\r\n  }\r\n}\r\n\r\nfunction workLoop() {\r\n  const wipFiber = wipRootHelper.get();\r\n  let nextUnitOfWork = nextUnitOfWorkHelper.get();\r\n  let shouldYield = false;\r\n  let hasMoreWork = Boolean(nextUnitOfWork);\r\n\r\n  while (nextUnitOfWork && !shouldYield) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\r\n    nextUnitOfWorkHelper.set(nextUnitOfWork);\r\n    hasMoreWork = Boolean(nextUnitOfWork);\r\n    shouldYield = platform.shouldYeildToHost();\r\n  }\r\n\r\n  if (!nextUnitOfWork && wipFiber) {\r\n    commitChanges();\r\n  }\r\n\r\n  return hasMoreWork;\r\n}\r\n\r\nfunction performUnitOfWork(fiber: Fiber) {\r\n  let isDeepWalking = true;\r\n  let nextFiber = fiber;\r\n  let shadow: Fiber = fiber.shadow;\r\n  let instance = fiber.instance;\r\n\r\n  while (true) {\r\n    isDeepWalking = fiberMountHelper.deepWalking.get();\r\n    nextFiber.hook.idx = 0;\r\n\r\n    if (isDeepWalking) {\r\n      const hasChildren = hasChildrenProp(instance) && instance.children.length > 0;\r\n\r\n      if (hasChildren) {\r\n        const { performedFiber, performedNextFiber, performedShadow, performedInstance } = performChild({\r\n          nextFiber,\r\n          shadow,\r\n          instance,\r\n        });\r\n\r\n        nextFiber = performedNextFiber;\r\n        shadow = performedShadow;\r\n        instance = performedInstance;\r\n\r\n        if (performedFiber) return performedFiber;\r\n      } else {\r\n        const { performedFiber, performedNextFiber, performedShadow, performedInstance } = performSibling({\r\n          nextFiber,\r\n          shadow,\r\n          instance,\r\n        });\r\n\r\n        nextFiber = performedNextFiber;\r\n        shadow = performedShadow;\r\n        instance = performedInstance;\r\n\r\n        if (performedFiber) return performedFiber;\r\n      }\r\n    } else {\r\n      const { performedFiber, performedNextFiber, performedShadow, performedInstance } = performSibling({\r\n        nextFiber,\r\n        shadow,\r\n        instance,\r\n      });\r\n\r\n      nextFiber = performedNextFiber;\r\n      shadow = performedShadow;\r\n      instance = performedInstance;\r\n\r\n      if (performedFiber) return performedFiber;\r\n    }\r\n\r\n    if (nextFiber.parent === null) return null;\r\n  }\r\n}\r\n\r\ntype PerformChildOptions = {\r\n  nextFiber: Fiber;\r\n  shadow: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction performChild(options: PerformChildOptions) {\r\n  fiberMountHelper.jumpToChild();\r\n  let nextFiber = options.nextFiber;\r\n  let shadow = options.shadow;\r\n  let instance = options.instance;\r\n  const optimizedFiber = nextFiber.alternate ? tryOptimizeFiber(nextFiber) : null;\r\n\r\n  if (optimizedFiber) {\r\n    return {\r\n      performedFiber: optimizedFiber,\r\n      performedNextFiber: optimizedFiber,\r\n      performedShadow: shadow,\r\n      performedInstance: instance,\r\n    };\r\n  }\r\n\r\n  shadow = shadow ? shadow.child : null;\r\n  const alternate = getChildAlternate(nextFiber);\r\n  const hook = shadow ? shadow.hook : alternate ? alternate.hook : createHook();\r\n  const provider = shadow ? shadow.provider : alternate ? alternate.provider : null;\r\n  let fiber = new Fiber({ hook, provider });\r\n\r\n  componentFiberHelper.set(fiber);\r\n  fiber.parent = nextFiber;\r\n\r\n  const { performedInstance, performedShadow } = pertformInstance({\r\n    instance,\r\n    idx: 0,\r\n    fiber,\r\n    alternate,\r\n  });\r\n  instance = performedInstance || instance;\r\n  shadow = performedShadow || shadow;\r\n  alternate && mutateAlternate({ fiber, alternate, instance });\r\n  mutateFiber({ fiber, alternate, instance });\r\n  fiber = alternate ? performMemo({ fiber, alternate, instance }) : fiber;\r\n\r\n  nextFiber.child = fiber;\r\n  fiber.parent = nextFiber;\r\n  fiber.shadow = shadow;\r\n  nextFiber = fiber;\r\n\r\n  cloneTagMap[fiber.parent.effectTag] && (fiber.effectTag = fiber.parent.effectTag);\r\n\r\n  return {\r\n    performedFiber: nextFiber,\r\n    performedNextFiber: nextFiber,\r\n    performedShadow: shadow,\r\n    performedInstance: instance,\r\n  };\r\n}\r\n\r\nfunction tryOptimizeFiber(fiber: Fiber): Fiber | null {\r\n  const { instance, alternate } = fiber;\r\n  const children = hasChildrenProp(instance) ? instance.children : [];\r\n  const canTryOptimize = alternate.childrenCount === children.length && children.length > 1;\r\n\r\n  if (canTryOptimize) {\r\n    const rootId = getRootId();\r\n    const canOptimize = detectCanOptimizeFiber(alternate.child, children);\r\n    let childAlternate = alternate.child;\r\n    let idx = 0;\r\n\r\n    if (!canOptimize) return null;\r\n\r\n    const fibersByPositionsMap = createFibersByPositionMap(childAlternate);\r\n\r\n    for (const child of children) {\r\n      const factory = child as ComponentFactory;\r\n      const alternateFactory = childAlternate.instance as ComponentFactory;\r\n      const props = alternateFactory.props;\r\n      const nextProps = factory.props;\r\n      const shouldUpdate = factory.shouldUpdate(props, nextProps);\r\n\r\n      if (shouldUpdate) {\r\n        childAlternate.instance = factory;\r\n        const callback = createUpdateCallback({\r\n          rootId,\r\n          currentFiber: childAlternate,\r\n          replacingFiberIdx: idx,\r\n          onCreateFiber: (fiber, idx) => {\r\n            const replacingFiberPrev = fibersByPositionsMap[idx - 1];\r\n            const replacingFiber = fibersByPositionsMap[idx];\r\n\r\n            fiber.parent = replacingFiber.parent;\r\n            fiber.nextSibling = replacingFiber.nextSibling;\r\n            replacingFiberPrev && (replacingFiberPrev.nextSibling = fiber);\r\n          },\r\n        });\r\n\r\n        platform.scheduleCallback(callback);\r\n      }\r\n\r\n      childAlternate = childAlternate.nextSibling;\r\n      idx++;\r\n    }\r\n\r\n    fiberMountHelper.deepWalking.set(false);\r\n    fiber.effectTag = EffectTag.SKIP;\r\n    fiber.child = fiber.alternate.child;\r\n\r\n    let nextFiber = fiber.child;\r\n\r\n    while (nextFiber) {\r\n      nextFiber.parent = fiber;\r\n      nextFiber = nextFiber.nextSibling;\r\n    }\r\n\r\n    fiberMountHelper.jumpToParent();\r\n\r\n    return fiber;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction detectCanOptimizeFiber(alternate: Fiber, children: Array<DarkElementInstance>) {\r\n  let nextFiber = alternate;\r\n  let idx = 0;\r\n\r\n  while (nextFiber || idx < children.length) {\r\n    const key = nextFiber && getElementKey(nextFiber.instance);\r\n    const nextKey = children[idx] && getElementKey(children[idx]);\r\n    const isMemoPrev = detectIsMemo(nextFiber.instance);\r\n    const isMemo = detectIsMemo(children[idx]);\r\n\r\n    if (key !== nextKey || !isMemoPrev || !isMemo) return false;\r\n\r\n    nextFiber = nextFiber ? nextFiber.nextSibling : null;\r\n    idx++;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\ntype PerformSiblingOptions = {\r\n  nextFiber: Fiber;\r\n  shadow: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction performSibling(options: PerformSiblingOptions) {\r\n  fiberMountHelper.jumpToSibling();\r\n  let nextFiber = options.nextFiber;\r\n  let shadow = options.shadow;\r\n  let instance = options.instance;\r\n  const parent = nextFiber.parent.instance;\r\n  const childrenIdx = fiberMountHelper.getIndex();\r\n  const hasSibling = hasChildrenProp(parent) && parent.children[childrenIdx];\r\n\r\n  if (hasSibling) {\r\n    fiberMountHelper.deepWalking.set(true);\r\n\r\n    shadow = shadow ? shadow.nextSibling : null;\r\n    const alternate = getNextSiblingAlternate(nextFiber);\r\n    const hook = shadow ? shadow.hook : alternate ? alternate.hook : createHook();\r\n    const provider = shadow ? shadow.provider : alternate ? alternate.provider : null;\r\n    let fiber = new Fiber({ hook, provider });\r\n\r\n    componentFiberHelper.set(fiber);\r\n    fiber.parent = nextFiber.parent;\r\n\r\n    const { performedInstance, performedShadow } = pertformInstance({\r\n      instance: parent,\r\n      idx: childrenIdx,\r\n      fiber,\r\n      alternate,\r\n    });\r\n    instance = performedInstance || instance;\r\n    shadow = performedShadow || shadow;\r\n    alternate && mutateAlternate({ fiber, alternate, instance });\r\n    mutateFiber({ fiber, alternate, instance });\r\n    fiber = alternate ? performMemo({ fiber, alternate, instance }) : fiber;\r\n\r\n    fiber.parent = nextFiber.parent;\r\n    nextFiber.nextSibling = fiber;\r\n    fiber.shadow = shadow;\r\n    nextFiber = fiber;\r\n\r\n    cloneTagMap[fiber.parent.effectTag] && (fiber.effectTag = fiber.parent.effectTag);\r\n\r\n    return {\r\n      performedFiber: nextFiber,\r\n      performedNextFiber: nextFiber,\r\n      performedShadow: shadow,\r\n      performedInstance: instance,\r\n    };\r\n  } else {\r\n    fiberMountHelper.jumpToParent();\r\n    fiberMountHelper.deepWalking.set(false);\r\n    shadow = shadow ? shadow.parent : null;\r\n    nextFiber = nextFiber.parent;\r\n    instance = nextFiber.instance;\r\n\r\n    if (hasChildrenProp(nextFiber.instance)) {\r\n      nextFiber.instance.children = [];\r\n    }\r\n  }\r\n\r\n  return {\r\n    performedFiber: null,\r\n    performedNextFiber: nextFiber,\r\n    performedShadow: shadow,\r\n    performedInstance: instance,\r\n  };\r\n}\r\n\r\ntype PerformAlternateOptions = {\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction mutateAlternate(options: PerformAlternateOptions) {\r\n  const { fiber, alternate, instance } = options;\r\n  const alternateType = getInstanceType(alternate.instance);\r\n  const elementType = getInstanceType(instance);\r\n  const isSameType = elementType === alternateType;\r\n\r\n  if (!isSameType) {\r\n    let nextFiber = alternate;\r\n\r\n    while (nextFiber) {\r\n      nextFiber.effectTag = EffectTag.DELETION;\r\n      deletionsHelper.get().push(nextFiber);\r\n      nextFiber = !detectIsCommentVirtualNode(nextFiber.instance) ? nextFiber.nextSibling : null;\r\n    }\r\n  } else if (hasChildrenProp(alternate.instance) && hasChildrenProp(instance)) {\r\n    const isRequestedKeys = alternate.childrenCount !== instance.children.length;\r\n\r\n    if (isRequestedKeys) {\r\n      const children = hasChildrenProp(instance) ? instance.children : [];\r\n      const { keys, nextKeys } = extractKeys(alternate.child, children);\r\n      const hasKeys = keys.length > 0;\r\n      const hasAnyKeys = hasKeys || nextKeys.length > 0;\r\n\r\n      if (process.env.NODE_ENV === 'development') {\r\n        if (!hasAnyKeys) {\r\n          error(`\r\n            [Dark]: Operation of inserting, adding, replacing elements into list requires to have a unique key for every node (string or number, but not array index)!\r\n          `);\r\n        }\r\n      }\r\n\r\n      const performRemovingNodes = () => {\r\n        const diffKeys = getDiffKeys(keys, nextKeys);\r\n\r\n        if (diffKeys.length > 0) {\r\n          const fibersMap = createFibersByKeyMap(alternate.child);\r\n\r\n          for (const key of diffKeys) {\r\n            const childAlternate = fibersMap[key] || null;\r\n\r\n            if (childAlternate) {\r\n              childAlternate.effectTag = EffectTag.DELETION;\r\n              deletionsHelper.get().push(childAlternate);\r\n\r\n              if (childAlternate.portalHost) {\r\n                fiber.markPortalHost();\r\n              }\r\n            }\r\n          }\r\n        } else if (!hasKeys) {\r\n          const diffCount = alternate.childrenCount - instance.children.length;\r\n          const childAlternates: Array<Fiber> = takeListFromEnd(getSiblingFibers(alternate.child), diffCount);\r\n\r\n          for (const childAlternate of childAlternates) {\r\n            childAlternate.effectTag = EffectTag.DELETION;\r\n\r\n            if (childAlternate.portalHost) {\r\n              fiber.markPortalHost();\r\n            }\r\n          }\r\n\r\n          deletionsHelper.get().push(...childAlternates);\r\n        }\r\n      };\r\n\r\n      const performInsertingNodes = () => {\r\n        const diffKeys = getDiffKeys(nextKeys, keys);\r\n\r\n        if (diffKeys.length > 0) {\r\n          const diffKeyMap = keyBy(diffKeys, x => x);\r\n          const fibersByPositionsMap = createFibersByPositionMap(alternate.child);\r\n          const usedKeyMap = {};\r\n          let keyIdx = 0;\r\n\r\n          for (const nextKey of nextKeys) {\r\n            if (process.env.NODE_ENV === 'development') {\r\n              if (usedKeyMap[nextKey]) {\r\n                error(`Some key of node already has been used!`);\r\n              }\r\n            }\r\n\r\n            usedKeyMap[nextKey] = true;\r\n\r\n            if (nextKey !== keys[keyIdx] && diffKeyMap[nextKey]) {\r\n              const insertionFiber = new Fiber({\r\n                instance: createEmptyVirtualNode(),\r\n                parent: alternate,\r\n                effectTag: EffectTag.PLACEMENT,\r\n              });\r\n\r\n              if (keyIdx === 0) {\r\n                insertionFiber.nextSibling = alternate.child;\r\n                alternate.child = insertionFiber;\r\n              } else {\r\n                const fiber = fibersByPositionsMap[keyIdx] || null;\r\n\r\n                if (fiber) {\r\n                  insertionFiber.nextSibling = fiber;\r\n                }\r\n              }\r\n            }\r\n\r\n            keyIdx++;\r\n          }\r\n        }\r\n      };\r\n\r\n      performRemovingNodes();\r\n      performInsertingNodes();\r\n    }\r\n  }\r\n}\r\n\r\ntype PerformMemoOptions = {\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction performMemo(options: PerformMemoOptions) {\r\n  const { fiber, alternate, instance } = options;\r\n\r\n  if (detectIsMemo(fiber.instance)) {\r\n    let memoFiber: Fiber = null;\r\n    const factory = instance as ComponentFactory;\r\n    const alternateFactory = alternate.instance as ComponentFactory;\r\n\r\n    if (factory.type !== alternateFactory.type) return fiber;\r\n\r\n    const props = alternateFactory.props;\r\n    const nextProps = factory.props;\r\n    const skip = !factory.shouldUpdate(props, nextProps);\r\n\r\n    if (skip) {\r\n      let nextFiber: Fiber = null;\r\n      fiberMountHelper.deepWalking.set(false);\r\n\r\n      memoFiber = new Fiber({\r\n        ...alternate,\r\n        alternate,\r\n        effectTag: EffectTag.SKIP,\r\n        nextSibling: alternate.nextSibling\r\n          ? alternate.nextSibling.effectTag === EffectTag.DELETION\r\n            ? null\r\n            : alternate.nextSibling\r\n          : null,\r\n      });\r\n\r\n      alternate.alternate = null;\r\n      nextFiber = memoFiber.child;\r\n\r\n      while (nextFiber) {\r\n        nextFiber.parent = memoFiber;\r\n        nextFiber = nextFiber.nextSibling;\r\n      }\r\n\r\n      return memoFiber;\r\n    }\r\n  }\r\n\r\n  return fiber;\r\n}\r\n\r\ntype PerformInstanceOptions = {\r\n  instance: DarkElementInstance;\r\n  idx: number;\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n};\r\n\r\nfunction pertformInstance(options: PerformInstanceOptions) {\r\n  const { instance, idx, fiber, alternate } = options;\r\n  let performedInstance: DarkElementInstance = null;\r\n  let performedShadow: Fiber = null;\r\n\r\n  if (hasChildrenProp(instance)) {\r\n    const elements = detectIsArray(instance.children[idx])\r\n      ? flatten([instance.children[idx]])\r\n      : [instance.children[idx]];\r\n\r\n    instance.children.splice(idx, 1, ...elements);\r\n    performedInstance = instance.children[idx];\r\n    performedShadow = alternate\r\n      ? getRootShadow({\r\n          instance: performedInstance,\r\n          fiber,\r\n          alternate,\r\n        })\r\n      : performedShadow;\r\n    performedInstance = mountInstance(fiber, performedInstance);\r\n  }\r\n\r\n  if (detectIsComponentFactory(performedInstance) && platform.detectIsPortal(performedInstance)) {\r\n    fiber.markPortalHost();\r\n  }\r\n\r\n  return {\r\n    performedInstance,\r\n    performedShadow,\r\n  };\r\n}\r\n\r\ntype GetRootShadowOptions = {\r\n  instance: DarkElementInstance;\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n};\r\n\r\nfunction getRootShadow(options: GetRootShadowOptions) {\r\n  const { instance, fiber, alternate } = options;\r\n  const key = getElementKey(alternate.instance);\r\n  const nextKey = getElementKey(instance);\r\n  let shadow: Fiber = null;\r\n\r\n  if (key !== nextKey) {\r\n    shadow = getAlternateByKey(nextKey, alternate.parent.child);\r\n\r\n    if (shadow) {\r\n      fiber.hook = shadow.hook;\r\n      fiber.provider = shadow.provider;\r\n      alternate.transposition = true;\r\n    }\r\n  }\r\n\r\n  return shadow;\r\n}\r\n\r\nfunction mountInstance(fiber: Fiber, instance: DarkElementInstance) {\r\n  const isComponentFactory = detectIsComponentFactory(instance);\r\n  const factory = instance as ComponentFactory;\r\n\r\n  if (isComponentFactory) {\r\n    try {\r\n      const result = factory.type(factory.props, factory.ref);\r\n\r\n      factory.children = detectIsArray(result)\r\n        ? (flatten([result]) as Array<DarkElementInstance>)\r\n        : ([result] as Array<DarkElementInstance>);\r\n    } catch (err) {\r\n      factory.children = [];\r\n      fiber.setError(err);\r\n      error(err);\r\n    }\r\n  } else if (detectIsVirtualNodeFactory(instance)) {\r\n    instance = instance();\r\n  }\r\n\r\n  if (hasChildrenProp(instance)) {\r\n    for (let i = 0; i < instance.children.length; i++) {\r\n      if (!instance.children[i]) {\r\n        instance.children[i] = transformElementInstance(instance.children[i]) as DarkElementInstance;\r\n      }\r\n    }\r\n\r\n    instance.children = isComponentFactory\r\n      ? instance.children\r\n      : detectIsArray(instance.children)\r\n      ? flatten([instance.children])\r\n      : [instance.children];\r\n\r\n    if (isComponentFactory && factory.children.length === 0) {\r\n      factory.children.push(createEmptyVirtualNode());\r\n    }\r\n  }\r\n\r\n  return instance;\r\n}\r\n\r\ntype MutateFiberOptions = {\r\n  fiber: Fiber;\r\n  alternate: Fiber;\r\n  instance: DarkElementInstance;\r\n};\r\n\r\nfunction mutateFiber(options: MutateFiberOptions) {\r\n  const { fiber, alternate, instance } = options;\r\n  const key = alternate ? getElementKey(alternate.instance) : null;\r\n  const nextKey = alternate ? getElementKey(instance) : null;\r\n  const isDifferentKeys = key !== nextKey;\r\n  const isSameType = Boolean(alternate) && getInstanceType(alternate.instance) === getInstanceType(instance);\r\n  const isUpdate = isSameType && !isDifferentKeys;\r\n\r\n  fiber.instance = instance;\r\n  fiber.alternate = alternate || null;\r\n  fiber.nativeElement = isUpdate ? alternate.nativeElement : null;\r\n  fiber.effectTag = isUpdate ? EffectTag.UPDATE : EffectTag.PLACEMENT;\r\n  fiber.mountedToHost = fiber.nativeElement ? isUpdate : false;\r\n\r\n  if (hasChildrenProp(fiber.instance)) {\r\n    fiber.childrenCount = fiber.instance.children.length;\r\n  }\r\n\r\n  if (isSameType && isDifferentKeys) {\r\n    alternate.effectTag = EffectTag.DELETION;\r\n    deletionsHelper.get().push(alternate);\r\n  }\r\n\r\n  if (fiber.alternate) {\r\n    fiber.alternate.shadow = null;\r\n    fiber.alternate.alternate = null;\r\n  }\r\n\r\n  if (!fiber.nativeElement && detectIsVirtualNode(fiber.instance)) {\r\n    fiber.nativeElement = platform.createNativeElement(fiber);\r\n  }\r\n}\r\n\r\nfunction createFibersByPositionMap(fiber: Fiber) {\r\n  let nextFiber = fiber;\r\n  let position = 0;\r\n  const map: Record<string, Fiber> = {};\r\n\r\n  while (nextFiber) {\r\n    map[position] = nextFiber;\r\n\r\n    position++;\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return map;\r\n}\r\n\r\nfunction createFibersByKeyMap(fiber: Fiber) {\r\n  let nextFiber = fiber;\r\n  const map: Record<string, Fiber> = {};\r\n\r\n  while (nextFiber) {\r\n    const key = getElementKey(nextFiber.instance);\r\n\r\n    if (!detectIsEmpty(key)) {\r\n      map[key] = nextFiber;\r\n    }\r\n\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return map;\r\n}\r\n\r\nfunction extractKeys(alternate: Fiber, children: Array<DarkElementInstance>) {\r\n  let nextFiber = alternate;\r\n  let idx = 0;\r\n  const keys: Array<DarkElementKey> = [];\r\n  const nextKeys: Array<DarkElementKey> = [];\r\n\r\n  while (nextFiber || idx < children.length) {\r\n    const key = nextFiber && getElementKey(nextFiber.instance);\r\n    const nextKey = children[idx] && getElementKey(children[idx]);\r\n\r\n    if (!detectIsEmpty(key)) {\r\n      keys.push(key);\r\n    }\r\n\r\n    if (!detectIsEmpty(nextKey)) {\r\n      nextKeys.push(nextKey);\r\n    }\r\n\r\n    nextFiber = nextFiber ? nextFiber.nextSibling : null;\r\n    idx++;\r\n  }\r\n\r\n  return {\r\n    keys,\r\n    nextKeys,\r\n  };\r\n}\r\n\r\nfunction getAlternateByKey(key: DarkElementKey, fiber: Fiber) {\r\n  if (detectIsEmpty(key)) return null;\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    if (key === getElementKey(nextFiber.instance)) {\r\n      return nextFiber;\r\n    }\r\n\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction getElementKey(instance: DarkElementInstance): DarkElementKey | null {\r\n  const key = detectIsComponentFactory(instance)\r\n    ? getComponentFactoryKey(instance)\r\n    : detectIsTagVirtualNode(instance)\r\n    ? getVirtualNodeKey(instance)\r\n    : null;\r\n\r\n  return key;\r\n}\r\n\r\nfunction getDiffKeys(keys: Array<DarkElementKey>, nextKeys: Array<DarkElementKey>): Array<DarkElementKey> {\r\n  const nextKeysMap = nextKeys.reduce((acc, key) => ((acc[key] = true), acc), {});\r\n  const diff = [];\r\n\r\n  for (const key of keys) {\r\n    if (!nextKeysMap[key]) {\r\n      diff.push(key);\r\n    }\r\n  }\r\n\r\n  return diff;\r\n}\r\n\r\nfunction getChildAlternate(fiber: Fiber): Fiber | null {\r\n  let alternate =\r\n    (fiber.alternate && fiber.alternate.effectTag !== EffectTag.DELETION && fiber.alternate.child) || null;\r\n\r\n  while (alternate && alternate.effectTag === EffectTag.DELETION) {\r\n    alternate = alternate.nextSibling;\r\n  }\r\n\r\n  return alternate;\r\n}\r\n\r\nfunction getNextSiblingAlternate(fiber: Fiber): Fiber | null {\r\n  let alternate = (fiber.alternate && fiber.alternate.nextSibling) || null;\r\n\r\n  while (alternate && alternate.effectTag === EffectTag.DELETION) {\r\n    alternate = alternate.nextSibling;\r\n  }\r\n\r\n  return alternate;\r\n}\r\n\r\nfunction transformElementInstance(instance: DarkElement) {\r\n  return detectIsEmpty(instance) || instance === false ? createEmptyVirtualNode() : instance;\r\n}\r\n\r\nfunction getInstanceType(instance: DarkElementInstance): string | Function {\r\n  return detectIsTagVirtualNode(instance)\r\n    ? instance.name\r\n    : detectIsVirtualNode(instance)\r\n    ? instance.type\r\n    : detectIsComponentFactory(instance)\r\n    ? instance.type\r\n    : null;\r\n}\r\n\r\nfunction getSiblingFibers(fiber: Fiber): Array<Fiber> {\r\n  const list = [];\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    list.push(nextFiber);\r\n    nextFiber = nextFiber.nextSibling;\r\n  }\r\n\r\n  return list;\r\n}\r\n\r\nfunction hasChildrenProp(element: DarkElementInstance): element is TagVirtualNode | ComponentFactory {\r\n  return detectIsTagVirtualNode(element) || detectIsComponentFactory(element);\r\n}\r\n\r\nfunction commitChanges() {\r\n  const wipFiber = wipRootHelper.get();\r\n  const fromHook = fromHookUpdateHelper.get();\r\n  const deletions = deletionsHelper.get();\r\n  const hasPortals = wipFiber.alternate && wipFiber.alternate.portalHost;\r\n\r\n  // console.log('wip', wipFiber);\r\n\r\n  if (hasPortals) {\r\n    for (const fiber of deletions) {\r\n      fiber.portalHost && platform.unmountPortal(fiber);\r\n    }\r\n  }\r\n\r\n  commitWork(wipFiber.child, () => {\r\n    for (const fiber of deletions) {\r\n      platform.applyCommits(fiber);\r\n    }\r\n\r\n    deletionsHelper.set([]);\r\n    wipRootHelper.set(null);\r\n\r\n    for (const effect of effectsHelper.get()) {\r\n      effect();\r\n    }\r\n\r\n    effectsHelper.reset();\r\n\r\n    if (fromHook) {\r\n      fromHookUpdateHelper.set(false);\r\n    } else {\r\n      currentRootHelper.set(wipFiber);\r\n    }\r\n  });\r\n}\r\n\r\nfunction commitWork(fiber: Fiber, onComplete: Function) {\r\n  let nextFiber = fiber;\r\n  let isDeepWalking = true;\r\n  let isReturn = false;\r\n\r\n  while (nextFiber) {\r\n    const skip = nextFiber.effectTag === EffectTag.SKIP;\r\n\r\n    if (skip) {\r\n      isDeepWalking = false;\r\n    } else if (!isReturn) {\r\n      platform.applyCommits(nextFiber);\r\n    }\r\n\r\n    if (nextFiber && nextFiber.shadow) {\r\n      nextFiber.shadow = null;\r\n    }\r\n\r\n    if (nextFiber.child && isDeepWalking) {\r\n      nextFiber = nextFiber.child;\r\n    } else if (nextFiber.nextSibling && nextFiber.nextSibling !== fiber.nextSibling) {\r\n      isDeepWalking = true;\r\n      isReturn = false;\r\n      nextFiber = nextFiber.nextSibling;\r\n    } else if (\r\n      nextFiber.parent &&\r\n      nextFiber !== fiber &&\r\n      nextFiber.parent !== fiber &&\r\n      nextFiber.parent !== fiber.parent\r\n    ) {\r\n      isDeepWalking = false;\r\n      isReturn = true;\r\n      nextFiber = nextFiber.parent;\r\n    } else {\r\n      nextFiber = null;\r\n    }\r\n  }\r\n\r\n  if (!nextFiber) {\r\n    onComplete();\r\n  }\r\n}\r\n\r\nfunction createHook(): Hook {\r\n  return {\r\n    idx: 0,\r\n    values: [],\r\n  };\r\n}\r\n\r\ntype CreateUpdateCallbackOptions = {\r\n  rootId: number;\r\n  currentFiber: Fiber;\r\n  replacingFiberIdx?: number;\r\n  onCreateFiber?: (fiber: Fiber, idx: number) => void;\r\n};\r\n\r\nfunction createUpdateCallback(options: CreateUpdateCallbackOptions) {\r\n  const { rootId, currentFiber, replacingFiberIdx, onCreateFiber } = options;\r\n  const callback = () => {\r\n    effectStoreHelper.set(rootId); // important order!\r\n    fromHookUpdateHelper.set(true);\r\n\r\n    const fiber = new Fiber({\r\n      ...currentFiber,\r\n      child: null,\r\n      alternate: currentFiber,\r\n      effectTag: EffectTag.UPDATE,\r\n    });\r\n\r\n    detectIsFunction(onCreateFiber) && onCreateFiber(fiber, replacingFiberIdx);\r\n\r\n    currentFiber.alternate = null;\r\n    wipRootHelper.set(fiber);\r\n    componentFiberHelper.set(fiber);\r\n    fiber.instance = mountInstance(fiber, fiber.instance);\r\n    fiberMountHelper.reset();\r\n    nextUnitOfWorkHelper.set(fiber);\r\n  };\r\n\r\n  return callback;\r\n}\r\n\r\nexport { Fiber, workLoop, createHook, hasChildrenProp, createUpdateCallback };\r\n","import { platform } from '../global';\r\nimport { getRootId, componentFiberHelper } from '../scope';\r\nimport { createUpdateCallback } from '../fiber';\r\n\r\nfunction useUpdate() {\r\n  const rootId = getRootId();\r\n  const currentFiber = componentFiberHelper.get();\r\n  const update = () => {\r\n    const callback = createUpdateCallback({ rootId, currentFiber });\r\n\r\n    platform.scheduleCallback(callback);\r\n  };\r\n\r\n  return update;\r\n}\r\n\r\nexport { useUpdate };\r\n","import { useEffect } from '../use-effect';\r\nimport { useMemo } from '../use-memo';\r\nimport { componentFiberHelper } from '../scope';\r\nimport { useUpdate } from '../use-update';\r\nimport type { Fiber } from '../fiber';\r\nimport type { Context, ContextProviderValue } from '../context/model';\r\n\r\nfunction useContext<T>(context: Context<T>): T {\r\n  const { defaultValue } = context;\r\n  const fiber = componentFiberHelper.get();\r\n  const provider = getProvider<T>(context, fiber);\r\n  const value = provider ? provider.value : defaultValue;\r\n  const update = useUpdate();\r\n  const scope = useMemo(() => ({ prevValue: value, update }), []);\r\n  const hasProvider = Boolean(provider);\r\n\r\n  useEffect(() => {\r\n    if (!hasProvider) return;\r\n\r\n    const subscriber = (newValue: T) => {\r\n      if (!Object.is(scope.prevValue, newValue)) {\r\n        scope.update();\r\n      }\r\n    };\r\n\r\n    provider.subscribers.push(subscriber);\r\n\r\n    return () => {\r\n      const idx = provider.subscribers.findIndex(x => x === subscriber);\r\n\r\n      if (idx !== -1) {\r\n        provider.subscribers.splice(idx, 1);\r\n      }\r\n    };\r\n  }, [hasProvider]);\r\n\r\n  scope.prevValue = value;\r\n  scope.update = update;\r\n\r\n  return value;\r\n}\r\n\r\nfunction getProvider<T>(context: Context<T>, fiber: Fiber): ContextProviderValue<T> {\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    if (nextFiber.provider && nextFiber.provider.get(context)) {\r\n      return nextFiber.provider.get(context) as ContextProviderValue<T>;\r\n    }\r\n\r\n    nextFiber = nextFiber.parent;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { useContext };\r\n","import { createComponent } from '../component';\r\nimport { useEffect } from '../use-effect';\r\nimport { componentFiberHelper } from '../scope';\r\nimport { useContext } from '../use-context';\r\nimport { detectIsFunction } from '../helpers';\r\nimport type { Context, ContexProviderProps } from './model';\r\n\r\nfunction createContext<T>(defaultValue: T): Context<T> {\r\n  let displayName = 'Context';\r\n  const context: Context<T> = {\r\n    displayName,\r\n    defaultValue,\r\n    Provider: null,\r\n    Consumer: null,\r\n  };\r\n\r\n  mutateContext(context, defaultValue, displayName);\r\n\r\n  Object.defineProperty(context, 'displayName', {\r\n    get: () => displayName,\r\n    set: (newValue: string) => {\r\n      displayName = newValue;\r\n      mutateContext(context, defaultValue, displayName);\r\n    },\r\n  });\r\n\r\n  return context;\r\n}\r\n\r\nfunction mutateContext<T>(context: Context<T>, defaultValue: T, displayName: string) {\r\n  context.Provider = createProvider(context, defaultValue, displayName);\r\n  context.Consumer = createConsumer(context, displayName);\r\n}\r\n\r\nfunction createProvider<T>(context: Context<T>, defaultValue: T, displayName: string) {\r\n  return createComponent<ContexProviderProps<T>>(\r\n    ({ value = defaultValue, slot }) => {\r\n      const fiber = componentFiberHelper.get();\r\n\r\n      if (!fiber.provider) {\r\n        fiber.provider = new Map();\r\n      }\r\n\r\n      if (!fiber.provider.get(context)) {\r\n        fiber.provider.set(context, {\r\n          subscribers: [],\r\n          value,\r\n        });\r\n      }\r\n\r\n      const provider = fiber.provider.get(context);\r\n\r\n      useEffect(() => {\r\n        for (const subscriber of provider.subscribers) {\r\n          subscriber(value);\r\n        }\r\n      }, [value]);\r\n\r\n      provider.value = value;\r\n\r\n      return slot;\r\n    },\r\n    { displayName: `${displayName}.Provider` },\r\n  );\r\n}\r\n\r\nfunction createConsumer<T>(context: Context<T>, displayName: string) {\r\n  return createComponent(\r\n    ({ slot }) => {\r\n      const value = useContext(context);\r\n\r\n      return detectIsFunction(slot) ? slot(value) : null;\r\n    },\r\n    { displayName: `${displayName}.Consumer` },\r\n  );\r\n}\r\n\r\nexport { createContext };\r\n","import { detectIsNumber, detectIsString, detectIsFunction } from '../helpers';\r\nimport { View, Text, type TagVirtualNodeFactory } from '../view';\r\n\r\nfunction getChildren(children: Array<any>) {\r\n  children = children.map(x => (detectIsString(x) || detectIsNumber(x) ? Text(x.toString()) : x));\r\n\r\n  return children ? (Array.isArray(children) ? [...children] : [children]) : [];\r\n}\r\n\r\nfunction createElement(\r\n  tag: string | Function,\r\n  props: any,\r\n  ...children: Array<any>\r\n): TagVirtualNodeFactory | Function | null {\r\n  if (detectIsString(tag)) {\r\n    return View({\r\n      ...props,\r\n      as: tag,\r\n      slot: getChildren(children),\r\n    });\r\n  }\r\n\r\n  if (detectIsFunction(tag)) {\r\n    let slot = getChildren(children);\r\n\r\n    slot = slot.length === 1 ? slot[0] : slot;\r\n\r\n    return tag({ ...props, slot });\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { createElement };\r\n","import { type KeyProps, createComponent, detectIsComponentFactory } from '../component';\r\n\r\nconst $$fragment = Symbol('fragment');\r\n\r\nconst Fragment = createComponent<KeyProps>(({ slot }) => slot || null, {\r\n  token: $$fragment,\r\n});\r\n\r\nconst detectIsFragment = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$fragment;\r\n\r\nexport { Fragment, detectIsFragment };\r\n","import { detectIsUndefined } from '../helpers';\r\nimport { componentFiberHelper } from '../scope';\r\nimport { detectIsDepsDifferent } from '../shared';\r\n\r\nfunction useCallback<T = Function>(callback: T, deps: Array<any>): T {\r\n  const fiber = componentFiberHelper.get();\r\n  const { hook } = fiber;\r\n  const { idx, values } = hook;\r\n\r\n  if (detectIsUndefined(values[idx])) {\r\n    values[idx] = {\r\n      deps,\r\n      value: callback,\r\n    };\r\n\r\n    hook.idx++;\r\n\r\n    return callback;\r\n  }\r\n\r\n  const hookValue = values[idx];\r\n  const prevDeps = hookValue.deps as Array<any>;\r\n  const isDepsDifferent = detectIsDepsDifferent(deps, prevDeps);\r\n\r\n  if (isDepsDifferent) {\r\n    hookValue.deps = deps;\r\n    hookValue.value = callback;\r\n  }\r\n\r\n  hook.idx++;\r\n\r\n  return hookValue.value;\r\n}\r\n\r\nexport { useCallback };\r\n","import { detectIsUndefined, detectIsFunction } from '../helpers';\r\nimport { getRootId, effectStoreHelper, componentFiberHelper } from '../scope';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\n\r\ntype Value<T> = T | ((prevValue: T) => T);\r\ntype Scope = {\r\n  idx: number;\r\n  values: Array<any>;\r\n  update: () => void;\r\n};\r\n\r\nfunction useState<T = unknown>(initialValue: T): [T, (value: Value<T>) => void] {\r\n  const rootId = getRootId();\r\n  const fiber = componentFiberHelper.get();\r\n  const update = useUpdate();\r\n  const scope: Scope = useMemo(\r\n    () => ({\r\n      idx: fiber.hook.idx,\r\n      values: fiber.hook.values,\r\n      update,\r\n    }),\r\n    [],\r\n  );\r\n  const setState = useCallback((sourceValue: Value<T>) => {\r\n    effectStoreHelper.set(rootId);\r\n    const value = scope.values[scope.idx];\r\n    const newValue = detectIsFunction(sourceValue) ? sourceValue(value) : sourceValue;\r\n\r\n    if (!Object.is(value, newValue)) {\r\n      scope.values[scope.idx] = newValue; // important order\r\n      scope.update();\r\n    }\r\n  }, []);\r\n  const { hook } = fiber;\r\n  const { idx, values } = hook;\r\n  const value: T = !detectIsUndefined(values[idx]) ? values[idx] : initialValue;\r\n\r\n  values[idx] = value;\r\n  scope.idx = idx;\r\n  scope.update = update;\r\n  scope.values = values;\r\n  hook.idx++;\r\n\r\n  return [value, setState];\r\n}\r\n\r\nexport { useState };\r\n","import { createComponent } from '../component';\r\nimport { useState } from '../use-state';\r\nimport { createContext } from '../context';\r\nimport { useContext } from '../use-context';\r\nimport { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\nimport type { DarkElement } from '../shared';\r\n\r\ntype SuspenseProps = {\r\n  fallback: DarkElement;\r\n};\r\n\r\ntype SuspenseContextValue = {\r\n  fallback: DarkElement;\r\n  isLoaded: boolean;\r\n  trigger: () => void;\r\n};\r\n\r\nconst SuspenseContext = createContext<SuspenseContextValue>({\r\n  fallback: null,\r\n  isLoaded: true,\r\n  trigger: () => {},\r\n});\r\n\r\nconst Suspense = createComponent<SuspenseProps>(({ fallback, slot }) => {\r\n  if (!fallback) {\r\n    throw new Error(`Suspense fallback doesn't found`);\r\n  }\r\n  const { isLoaded: isSuspenseLoaded } = useContext(SuspenseContext);\r\n  const [isLoaded, setIsLoaded] = useState(false);\r\n  const trigger = useCallback(() => setIsLoaded(true), []);\r\n  const value = useMemo(() => ({ fallback, isLoaded, trigger }), [fallback, isLoaded]);\r\n\r\n  return SuspenseContext.Provider({\r\n    value,\r\n    slot: isSuspenseLoaded ? slot : null,\r\n  });\r\n});\r\n\r\nexport { SuspenseContext, Suspense };\r\n","import { type Component, createComponent, detectIsComponentFactory } from '../component';\r\nimport { useState } from '../use-state';\r\nimport { useEffect } from '../use-effect';\r\nimport { forwardRef } from '../ref';\r\nimport { SuspenseContext } from '../suspense';\r\nimport { useContext } from '../use-context';\r\n\r\nconst $$lazy = Symbol('lazy');\r\n\r\ntype LazyScope<P, R> = {\r\n  component: Component<P, R>;\r\n};\r\n\r\nfunction lazy<P, R = unknown>(dynamic: () => Promise<{ default: Component<P> }>) {\r\n  return forwardRef(\r\n    createComponent<P, R>(\r\n      (props, ref) => {\r\n        const { fallback, trigger } = useContext(SuspenseContext);\r\n        const [scope, setScope] = useState<LazyScope<P, R>>({\r\n          component: null,\r\n        });\r\n\r\n        useEffect(() => {\r\n          fetchModule(dynamic).then(component => {\r\n            setScope({ component });\r\n          });\r\n        }, []);\r\n\r\n        useEffect(() => {\r\n          scope.component && trigger();\r\n        }, [scope.component]);\r\n\r\n        return scope.component ? scope.component(props, ref) : fallback;\r\n      },\r\n      { token: $$lazy },\r\n    ),\r\n  );\r\n}\r\n\r\nconst detectIsLazy = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$lazy;\r\n\r\nfunction fetchModule(dynamic: () => Promise<{ default: Component }>) {\r\n  return new Promise<Component>(resolve => {\r\n    dynamic().then(module => {\r\n      if (!module.default) {\r\n        throw new Error('lazy loaded component should be exported as default!');\r\n      }\r\n\r\n      resolve(module.default);\r\n    });\r\n  });\r\n}\r\n\r\nexport { lazy, detectIsLazy };\r\n","import { componentFiberHelper } from '../scope';\r\nimport { useEffect } from '../use-effect';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\n\r\ntype ErrorScope = {\r\n  error: Error;\r\n};\r\n\r\nfunction useError(): Error | null {\r\n  const fiber = componentFiberHelper.get();\r\n  const update = useUpdate();\r\n  const scope: ErrorScope = useMemo(() => ({ error: null }), []);\r\n\r\n  fiber.catchException = (error: Error) => {\r\n    scope.error = error;\r\n    update();\r\n  };\r\n\r\n  useEffect(() => {\r\n    scope.error = null;\r\n  }, [scope.error]);\r\n\r\n  return scope.error;\r\n}\r\n\r\nexport { useError };\r\n","import { useMemo } from '../use-memo';\r\nimport type { MutableRef } from '../ref';\r\n\r\nfunction useImperativeHandle<T>(ref: MutableRef<T>, createHandle: () => object, deps: Array<any>) {\r\n  const current = useMemo(() => createHandle(), deps);\r\n\r\n  ref.current = current;\r\n}\r\n\r\nexport { useImperativeHandle };\r\n","import { useState } from '../use-state';\r\nimport { useCallback } from '../use-callback';\r\nimport { useMemo } from '../use-memo';\r\nimport { detectIsFunction } from '../helpers';\r\nimport type { Reducer, Dispatch, ReducerAction, ReducerState } from './model';\r\n\r\nfunction useReducer<R extends Reducer>(\r\n  reducer: R,\r\n  initialState: ReducerState<R>,\r\n  initializer?: (state: ReducerState<R>) => ReducerState<R>,\r\n): [ReducerState<R>, Dispatch<ReducerAction<R>>] {\r\n  const initialValue = useMemo(() => {\r\n    return detectIsFunction(initializer) ? initializer(initialState) : initialState;\r\n  }, []);\r\n  const [state, setState] = useState<ReducerState<R>>(initialValue);\r\n  const dispatch = useCallback((action: ReducerAction<R>) => setState(state => reducer(state, action)), []) as Dispatch<\r\n    ReducerAction<R>\r\n  >;\r\n\r\n  return [state, dispatch];\r\n}\r\n\r\nexport { useReducer };\r\n","import { useMemo } from '../use-memo';\r\nimport type { MutableRef } from '../ref/model';\r\n\r\nfunction useRef<T>(initialValue: T = null): MutableRef<T> {\r\n  const ref = useMemo(() => ({ current: initialValue }), []) as MutableRef<T>;\r\n\r\n  return ref;\r\n}\r\n\r\nexport { useRef };\r\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ROOT","EMPTY_NODE","ATTR_KEY","ATTR_REF","detectIsFunction","detectIsUndefined","detectIsNumber","detectIsString","detectIsObject","detectIsBoolean","detectIsArray","Array","isArray","detectIsNull","detectIsEmpty","error","str","console","flatten","source","list","levelMap","idx","level","item","length","push","getTime","performance","now","keyBy","fn","reduce","acc","x","takeListFromEnd","count","i","defaultOptions","displayName","defaultProps","token","options","children","this","type","props","ref","shouldUpdate","createComponent","createElement","computedOptions","computedProps","ComponentFactory","detectIsComponentFactory","getComponentFactoryKey","wipRoot","currentRoot","nextUnitOfWork","fromHookUpdate","events","Map","deletions","fiberMount","navigation","isDeepWalking","componentFiber","effects","rootId","stores","effectStoreHelper","set","id","effectStore","getRootId","Store","storeHelper","wipRootHelper","fiber","currentRootHelper","nextUnitOfWorkHelper","componentFiberHelper","fromHookUpdateHelper","eventsHelper","deletionsHelper","fiberMountHelper","reset","getIndex","jumpToChild","nextLevel","jumpToParent","jumpToSibling","deepWalking","effectsHelper","add","effect","detectIsDepsDifferent","deps","prevDeps","NodeType","$$useEffect","useEffect","hook","values","runEffect","run","setTimeout","cleanup","runEffectCleanup","hookValue","$$virtualNode","TAG","name","isVoid","attrs","VirtualNode","text","TEXT","COMMENT","detectIsVirtualNode","vNode","detectIsTagVirtualNode","TagVirtualNode","detectIsCommentVirtualNode","CommentVirtualNode","detectIsTextVirtualNode","TextVirtualNode","detectIsEmptyVirtualNode","getVirtualNodeKey","getAttribute","attrName","undefined","setAttribute","Text","Comment","View","def","as","slot","rest","createEmptyVirtualNode","detectIsVirtualNodeFactory","forwardRef","component","detectIsRef","mutableRef","$$memo","defaultShouldUpdate","nextProps","keys","detectIsMemo","memo","Memo","wrap","isDepsDifferent","processValue","getValue","map","useMemo","computedGetValue","EffectTag","platform","raf","Error","scheduleCallback","shouldYeildToHost","createNativeElement","applyCommits","detectIsPortal","unmountPortal","cloneTagMap","PLACEMENT","SKIP","nativeElement","parent","child","nextSibling","alternate","effectTag","instance","shadow","provider","transposition","mountedToHost","portalHost","childrenCount","markPortalHost","setError","catchException","workLoop","wipFiber","shouldYield","hasMoreWork","Boolean","performUnitOfWork","fromHook","onComplete","nextFiber","isReturn","commitWork","commitChanges","hasChildrenProp","performChild","performedFiber","performSibling","optimizedFiber","canOptimize","getElementKey","nextKey","isMemoPrev","isMemo","detectCanOptimizeFiber","childAlternate","createFibersByPositionMap","callback","createUpdateCallback","currentFiber","replacingFiberIdx","onCreateFiber","replacingFiberPrev","replacingFiber","tryOptimizeFiber","performedNextFiber","performedShadow","performedInstance","DELETION","getChildAlternate","Fiber","pertformInstance","mutateAlternate","mutateFiber","performMemo","childrenIdx","getNextSiblingAlternate","alternateType","getInstanceType","nextKeys","extractKeys","diffKeys","getDiffKeys","fibersMap","createFibersByKeyMap","diffCount","childAlternates","getSiblingFibers","performRemovingNodes","diffKeyMap","fibersByPositionsMap","usedKeyMap","keyIdx","insertionFiber","performInsertingNodes","memoFiber","alternateFactory","elements","splice","getAlternateByKey","getRootShadow","mountInstance","isComponentFactory","result","err","transformElementInstance","isDifferentKeys","isSameType","isUpdate","UPDATE","position","nextKeysMap","diff","element","createHook","useUpdate","useContext","context","defaultValue","getProvider","update","scope","prevValue","hasProvider","subscriber","newValue","is","subscribers","findIndex","createContext","Provider","Consumer","mutateContext","createProvider","createConsumer","getChildren","toString","tag","$$fragment","Fragment","detectIsFragment","useCallback","useState","initialValue","setState","sourceValue","SuspenseContext","fallback","isLoaded","trigger","Suspense","isSuspenseLoaded","setIsLoaded","$$lazy","lazy","dynamic","setScope","Promise","resolve","then","default","fetchModule","detectIsLazy","useError","useImperativeHandle","createHandle","current","useReducer","reducer","initialState","initializer","state","dispatch","action","useRef"],"sourceRoot":""}